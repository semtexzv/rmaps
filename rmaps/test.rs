#![feature(prelude_import)]
#![no_std]
//#![feature(custom_attribute)]
#![recursion_limit = "512"]
#![feature(slice_patterns)]
#![feature(proc_macro)]
#![feature(proc_macro_mod)]
#![feature(never_type)]
#![feature(associated_type_defaults)]
#![feature(box_syntax)]
#![feature(try_from)]
#![feature(trace_macros)]
#![feature(pattern_parentheses)]
#![feature(macro_literal_matcher)]
#![feature(macro_at_most_once_rep)]
#![feature(specialization)]
#![feature(unsize)]

#![allow(unused_imports,
         dead_code,
         unused_mut,
         unused_variables,
         unused_macros,
         unreachable_code,
         unreachable_patterns,
         unused_parens)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
pub extern crate common;
pub extern crate mvt;
#[macro_use]
pub extern crate rmaps_derive;

pub extern crate image;

pub extern crate tess2;
pub extern crate earcut;

extern crate serde;

pub mod prelude {




    //map::storage::actor_impls::setup();
    //map::storage::setup_FileSource();
    pub use ::common::export::*;
    pub use rmaps_derive::*;
    pub fn start_in_thread<A: Actor<Context = Context<A>> + Send + 'static,
                           F: FnOnce() -> A + Send + 'static>(a: F)
     -> Addr<Syn, A> {
        let (tx, rx) = ::std::sync::mpsc::channel();
        ::std::thread::spawn(move ||
                                 {
                                     let sys = System::new("aa");
                                     let actor = a();
                                     let addr = actor.start();
                                     let _ = tx.send(addr);
                                     let _ = sys.run();
                                 });
        rx.recv().unwrap()
    }
}
pub mod map {
    use prelude::*;
    pub mod render {
        use prelude::*;
        pub mod layers {
            use prelude::*;
            use map::{style, tiles::data, render::{self, property}};
            macro_rules! layer_program((
                                       $ facade : expr , $ name : expr , $
                                       uniforms : expr , $ features : expr )
                                       => {
                                       {
                                       let vert_src = include_str ! (
                                       concat ! (
                                       env ! ( "CARGO_MANIFEST_DIR" ) ,
                                       "/../shaders/" , $ name , ".vert.glsl"
                                       ) ) ; let frag_src = include_str ! (
                                       concat ! (
                                       env ! ( "CARGO_MANIFEST_DIR" ) ,
                                       "/../shaders/" , $ name , ".frag.glsl"
                                       ) ) ; :: map :: render :: shaders ::
                                       ShaderProcessor :: get_shader (
                                       $ facade , vert_src , frag_src , $
                                       uniforms , $ features ) } } ;);
            pub mod background {
                use prelude::*;
                use map::{style,
                          render::{self, layers::{self, Layer}, property::*},
                          tiles::data::{self}};
                #[properties(BackgroundLayer)]
                pub struct BackgroundLayerProperties {
                    #[property(src_name = "color", nofeature)]
                    color: BaseProp<Color>,
                    opacity: BaseProp<f32>,
                    #[property(src_name = "pattern", nofeature, nozoom)]
                    pattern: BaseProp<Option<String>>,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for BackgroundLayerProperties {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            BackgroundLayerProperties {
                            color: ref __self_0_0,
                            opacity: ref __self_0_1,
                            pattern: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("BackgroundLayerProperties");
                                let _ =
                                    debug_trait_builder.field("color",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("opacity",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("pattern",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for BackgroundLayerProperties {
                    #[inline]
                    fn clone(&self) -> BackgroundLayerProperties {
                        match *self {
                            BackgroundLayerProperties {
                            color: ref __self_0_0,
                            opacity: ref __self_0_1,
                            pattern: ref __self_0_2 } =>
                            BackgroundLayerProperties{color:
                                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                                      opacity:
                                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                                      pattern:
                                                          ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::default::Default for BackgroundLayerProperties {
                    #[inline]
                    fn default() -> BackgroundLayerProperties {
                        BackgroundLayerProperties{color:
                                                      ::std::default::Default::default(),
                                                  opacity:
                                                      ::std::default::Default::default(),
                                                  pattern:
                                                      ::std::default::Default::default(),}
                    }
                }
                impl ::map::render::property::Properties for
                 BackgroundLayerProperties {
                    type
                    SourceLayerType
                    =
                    ::map::style::BackgroundLayer;
                    fn accept<V: PropertiesVisitor>(&self,
                                                    layer:
                                                        &Self::SourceLayerType,
                                                    visitor: &mut V) {
                        use ::map::render::property::*;
                        use ::map::style::StyleLayer;
                        visitor.visit("color", &layer.get_paint().color,
                                      &self.color, true, false);
                        visitor.visit("opacity", &layer.get_paint().opacity,
                                      &self.opacity, true, true);
                        visitor.visit("pattern", &layer.get_paint().pattern,
                                      &self.pattern, false, false)
                    }
                    fn eval(&mut self, layer: &Self::SourceLayerType,
                            evaluator:
                                &::map::render::property::PropertiesEvaluator)
                     -> Result<bool> {
                        use map::style::StyleLayer;
                        let mut modified = false;
                        let expr = &layer.get_paint().color;
                        match evaluator.evaluate(&mut self.color, &expr, true,
                                                 false) {
                            Ok(true) => { modified = true; }
                            Ok(false) => { }
                            Err(e) => {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Error when evaluating ",
                                                                                                             " : "],
                                                                                                           &match (&"color",
                                                                                                                   &e)
                                                                                                                {
                                                                                                                (arg0,
                                                                                                                 arg1)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt),
                                                                                                                 ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                             ::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            }
                            _ => { }
                        }
                        let expr = &layer.get_paint().opacity;
                        match evaluator.evaluate(&mut self.opacity, &expr,
                                                 true, true) {
                            Ok(true) => { modified = true; }
                            Ok(false) => { }
                            Err(e) => {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Error when evaluating ",
                                                                                                             " : "],
                                                                                                           &match (&"opacity",
                                                                                                                   &e)
                                                                                                                {
                                                                                                                (arg0,
                                                                                                                 arg1)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt),
                                                                                                                 ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                             ::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            }
                            _ => { }
                        }
                        let expr = &layer.get_paint().pattern;
                        match evaluator.evaluate(&mut self.pattern, &expr,
                                                 false, false) {
                            Ok(true) => { modified = true; }
                            Ok(false) => { }
                            Err(e) => {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Error when evaluating ",
                                                                                                             " : "],
                                                                                                           &match (&"pattern",
                                                                                                                   &e)
                                                                                                                {
                                                                                                                (arg0,
                                                                                                                 arg1)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt),
                                                                                                                 ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                             ::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            }
                            _ => { }
                        }
                        Ok(modified)
                    }
                }
                pub struct BackgroundLayer {
                    style_layer: style::BackgroundLayer,
                    properties: BackgroundLayerProperties,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for BackgroundLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            BackgroundLayer {
                            style_layer: ref __self_0_0,
                            properties: ref __self_0_1 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("BackgroundLayer");
                                let _ =
                                    debug_trait_builder.field("style_layer",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("properties",
                                                              &&(*__self_0_1));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                impl Layer for BackgroundLayer {
                    fn new_tile(&mut self, display: &Display,
                                data: &Rc<data::TileData>) -> Result<()> {
                        Ok(())
                    }
                    fn evaluate(&mut self, params: &render::EvaluationParams)
                     -> Result<()> {
                        let evaluator = PropertiesEvaluator::from(params);
                        self.properties.eval(&self.style_layer,
                                             &evaluator).unwrap();
                        Ok(())
                    }
                    fn render(&mut self, params: &mut render::RenderParams)
                     -> Result<()> {
                        let mut c = self.properties.color.get().to_rgba();
                        params.frame.clear_color(c[0], c[1], c[2],
                                                 c[3] *
                                                     self.properties.opacity.get());
                        Ok(())
                    }
                }
                impl BackgroundLayer {
                    pub fn parse(layer: style::BackgroundLayer) -> Self {
                        return BackgroundLayer{style_layer: layer,
                                               properties:
                                                   Default::default(),};
                    }
                }
            }
            pub mod raster {
                use prelude::*;
                use map::{style,
                          render::{self, layers::{self, Layer}, property::*},
                          tiles::data::{self}};
                #[rustc_copy_clone_marker]
                pub struct RasterVertex {
                    pub pos: [f32; 2],
                    pub tex: [f32; 2],
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for RasterVertex {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            RasterVertex {
                            pos: ref __self_0_0, tex: ref __self_0_1 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("RasterVertex");
                                let _ =
                                    debug_trait_builder.field("pos",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("tex",
                                                              &&(*__self_0_1));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for RasterVertex {
                    #[inline]
                    fn clone(&self) -> RasterVertex {
                        {
                            let _: ::std::clone::AssertParamIsClone<[f32; 2]>;
                            let _: ::std::clone::AssertParamIsClone<[f32; 2]>;
                            *self
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::marker::Copy for RasterVertex { }
                impl ::glium::vertex::Vertex for RasterVertex {
                    #[inline]
                    fn build_bindings() -> ::glium::vertex::VertexFormat {
                        use std::borrow::Cow;
                        Cow::Owned(<[_]>::into_vec(box
                                                       [(Cow::Borrowed("pos"),
                                                         {
                                                             let dummy:
                                                                     RasterVertex =
                                                                 unsafe {
                                                                     ::std::mem::uninitialized()
                                                                 };
                                                             let offset:
                                                                     usize =
                                                                 {
                                                                     let dummy_ref =
                                                                         &dummy;
                                                                     let field_ref =
                                                                         &dummy.pos;
                                                                     (field_ref
                                                                          as
                                                                          *const _
                                                                          as
                                                                          usize)
                                                                         -
                                                                         (dummy_ref
                                                                              as
                                                                              *const _
                                                                              as
                                                                              usize)
                                                                 };
                                                             offset
                                                         },
                                                         {
                                                             fn attr_type_of_val<T: ::glium::vertex::Attribute>(_:
                                                                                                                    &T)
                                                              ->
                                                                  ::glium::vertex::AttributeType {
                                                                 <T as
                                                                     ::glium::vertex::Attribute>::get_type()
                                                             }
                                                             let dummy:
                                                                     &RasterVertex =
                                                                 unsafe {
                                                                     ::std::mem::transmute(0usize)
                                                                 };
                                                             attr_type_of_val(&dummy.pos)
                                                         }, false),
                                                        (Cow::Borrowed("tex"),
                                                         {
                                                             let dummy:
                                                                     RasterVertex =
                                                                 unsafe {
                                                                     ::std::mem::uninitialized()
                                                                 };
                                                             let offset:
                                                                     usize =
                                                                 {
                                                                     let dummy_ref =
                                                                         &dummy;
                                                                     let field_ref =
                                                                         &dummy.tex;
                                                                     (field_ref
                                                                          as
                                                                          *const _
                                                                          as
                                                                          usize)
                                                                         -
                                                                         (dummy_ref
                                                                              as
                                                                              *const _
                                                                              as
                                                                              usize)
                                                                 };
                                                             offset
                                                         },
                                                         {
                                                             fn attr_type_of_val<T: ::glium::vertex::Attribute>(_:
                                                                                                                    &T)
                                                              ->
                                                                  ::glium::vertex::AttributeType {
                                                                 <T as
                                                                     ::glium::vertex::Attribute>::get_type()
                                                             }
                                                             let dummy:
                                                                     &RasterVertex =
                                                                 unsafe {
                                                                     ::std::mem::transmute(0usize)
                                                                 };
                                                             attr_type_of_val(&dummy.tex)
                                                         }, false)]))
                    }
                }
                pub struct RasterBucket {
                    pub texture: glium::texture::Texture2d,
                    pub vbo: glium::VertexBuffer<RasterVertex>,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for RasterBucket {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            RasterBucket {
                            texture: ref __self_0_0, vbo: ref __self_0_1 } =>
                            {
                                let mut debug_trait_builder =
                                    f.debug_struct("RasterBucket");
                                let _ =
                                    debug_trait_builder.field("texture",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("vbo",
                                                              &&(*__self_0_1));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                pub struct RasterLayer {
                    style_layer: style::RasterLayer,
                    shader_program: glium::Program,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for RasterLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            RasterLayer {
                            style_layer: ref __self_0_0,
                            shader_program: ref __self_0_1 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("RasterLayer");
                                let _ =
                                    debug_trait_builder.field("style_layer",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("shader_program",
                                                              &&(*__self_0_1));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                impl Layer for RasterLayer {
                    fn new_tile(&mut self, display: &Display,
                                data: &Rc<data::TileData>) -> Result<()> {
                        Ok(())
                    }
                    fn evaluate(&mut self, params: &render::EvaluationParams)
                     -> Result<()> {
                        {
                            ::rt::begin_panic("not yet implemented",
                                              &("rmaps/src/map/render/layers/raster.rs",
                                                41u32, 9u32))
                        }
                    }
                    fn render(&mut self, params: &mut render::RenderParams)
                     -> Result<()> {
                        Ok(())
                    }
                }
                impl RasterLayer {
                    pub fn parse(f: &glium::backend::Facade,
                                 layer: style::RasterLayer) -> Self {
                        let shader_program =
                            {
                                let context =
                                    ::backend::Facade::get_context(f);
                                let version =
                                    {
                                        let num: u32 = 100;
                                        ::Version(::Api::GlEs,
                                                  (num / 100) as u8,
                                                  ((num % 100) / 10) as u8)
                                    };
                                if context.is_glsl_version_supported(&version)
                                   {
                                    let __vertex_shader: &str = "";
                                    let __tessellation_control_shader:
                                            Option<&str> = None;
                                    let __tessellation_evaluation_shader:
                                            Option<&str> = None;
                                    let __geometry_shader: Option<&str> =
                                        None;
                                    let __fragment_shader: &str = "";
                                    let __outputs_srgb: bool = false;
                                    let __uses_point_size: bool = false;
                                    let __vertex_shader =
                                        "#version 100\n\nuniform highp mat4 u_matrix;\n\nin vec2 pos;\nin vec2 tex;\nout vec2 v_texture_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(pos, 0.0, 1.0);\n    v_texture_pos = tex;\n}";
                                    let __fragment_shader =
                                        "#version 100\n\nuniform sampler2D u_texture;\nin vec2 v_texture_pos;\n\nvoid main() {\n    gl_FragColor = vec4(texture2D(u_texture,v_texture_pos).rgb,0.5);\n}";
                                    let input =
                                        ::program::ProgramCreationInput::SourceCode{vertex_shader:
                                                                                        __vertex_shader,
                                                                                    tessellation_control_shader:
                                                                                        __tessellation_control_shader,
                                                                                    tessellation_evaluation_shader:
                                                                                        __tessellation_evaluation_shader,
                                                                                    geometry_shader:
                                                                                        __geometry_shader,
                                                                                    fragment_shader:
                                                                                        __fragment_shader,
                                                                                    transform_feedback_varyings:
                                                                                        None,
                                                                                    outputs_srgb:
                                                                                        __outputs_srgb,
                                                                                    uses_point_size:
                                                                                        __uses_point_size,};
                                    ::program::Program::new(context,
                                                            input).map_err(|err|
                                                                               ::program::ProgramChooserCreationError::from(err))
                                } else {
                                    Err(::program::ProgramChooserCreationError::NoVersion)
                                }
                            }.unwrap();
                        return RasterLayer{style_layer: layer,
                                           shader_program,};
                    }
                }
            }
            pub mod fill {
                use prelude::*;
                use super::Vertex;
                use map::{style,
                          render::{self, layers::{self, Layer}, property::*},
                          tiles::data::{self}};
                use map::render::shaders::{UniformPropertyLayout,
                                           FeaturePropertyLayout,
                                           PropertyItemLayout};
                #[properties(FillLayer)]
                pub struct FillLayerProperties {
                    #[property(src_name = "antialias", nofeature)]
                    antialias: BaseProp<bool>,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FillLayerProperties {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FillLayerProperties { antialias: ref __self_0_0 }
                            => {
                                let mut debug_trait_builder =
                                    f.debug_struct("FillLayerProperties");
                                let _ =
                                    debug_trait_builder.field("antialias",
                                                              &&(*__self_0_0));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for FillLayerProperties {
                    #[inline]
                    fn clone(&self) -> FillLayerProperties {
                        match *self {
                            FillLayerProperties { antialias: ref __self_0_0 }
                            =>
                            FillLayerProperties{antialias:
                                                    ::std::clone::Clone::clone(&(*__self_0_0)),},
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::default::Default for FillLayerProperties {
                    #[inline]
                    fn default() -> FillLayerProperties {
                        FillLayerProperties{antialias:
                                                ::std::default::Default::default(),}
                    }
                }
                impl ::map::render::property::Properties for
                 FillLayerProperties {
                    type
                    SourceLayerType
                    =
                    ::map::style::FillLayer;
                    fn accept<V: PropertiesVisitor>(&self,
                                                    layer:
                                                        &Self::SourceLayerType,
                                                    visitor: &mut V) {
                        use ::map::render::property::*;
                        use ::map::style::StyleLayer;
                        visitor.visit("antialias",
                                      &layer.get_paint().antialias,
                                      &self.antialias, true, false)
                    }
                    fn eval(&mut self, layer: &Self::SourceLayerType,
                            evaluator:
                                &::map::render::property::PropertiesEvaluator)
                     -> Result<bool> {
                        use map::style::StyleLayer;
                        let mut modified = false;
                        let expr = &layer.get_paint().antialias;
                        match evaluator.evaluate(&mut self.antialias, &expr,
                                                 true, false) {
                            Ok(true) => { modified = true; }
                            Ok(false) => { }
                            Err(e) => {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Error when evaluating ",
                                                                                                             " : "],
                                                                                                           &match (&"antialias",
                                                                                                                   &e)
                                                                                                                {
                                                                                                                (arg0,
                                                                                                                 arg1)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt),
                                                                                                                 ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                             ::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            }
                            _ => { }
                        }
                        Ok(modified)
                    }
                }
                #[properties(FillLayer)]
                pub struct FillFeatureProperties {
                    #[property(src_name = "opacity")]
                    opacity: GpuProp<f32>,
                    #[property(src_name = "color")]
                    color: GpuProp<Color>,
                    #[property(src_name = "translate_anchor", nofeature)]
                    anchor: BaseProp<Option<String>>,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FillFeatureProperties {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FillFeatureProperties {
                            opacity: ref __self_0_0,
                            color: ref __self_0_1,
                            anchor: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("FillFeatureProperties");
                                let _ =
                                    debug_trait_builder.field("opacity",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("color",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("anchor",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for FillFeatureProperties {
                    #[inline]
                    fn clone(&self) -> FillFeatureProperties {
                        match *self {
                            FillFeatureProperties {
                            opacity: ref __self_0_0,
                            color: ref __self_0_1,
                            anchor: ref __self_0_2 } =>
                            FillFeatureProperties{opacity:
                                                      ::std::clone::Clone::clone(&(*__self_0_0)),
                                                  color:
                                                      ::std::clone::Clone::clone(&(*__self_0_1)),
                                                  anchor:
                                                      ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::default::Default for FillFeatureProperties {
                    #[inline]
                    fn default() -> FillFeatureProperties {
                        FillFeatureProperties{opacity:
                                                  ::std::default::Default::default(),
                                              color:
                                                  ::std::default::Default::default(),
                                              anchor:
                                                  ::std::default::Default::default(),}
                    }
                }
                impl ::map::render::property::Properties for
                 FillFeatureProperties {
                    type
                    SourceLayerType
                    =
                    ::map::style::FillLayer;
                    fn accept<V: PropertiesVisitor>(&self,
                                                    layer:
                                                        &Self::SourceLayerType,
                                                    visitor: &mut V) {
                        use ::map::render::property::*;
                        use ::map::style::StyleLayer;
                        visitor.visit("opacity", &layer.get_paint().opacity,
                                      &self.opacity, true, true);
                        visitor.visit("color", &layer.get_paint().color,
                                      &self.color, true, true);
                        visitor.visit("anchor",
                                      &layer.get_paint().translate_anchor,
                                      &self.anchor, true, false)
                    }
                    fn eval(&mut self, layer: &Self::SourceLayerType,
                            evaluator:
                                &::map::render::property::PropertiesEvaluator)
                     -> Result<bool> {
                        use map::style::StyleLayer;
                        let mut modified = false;
                        let expr = &layer.get_paint().opacity;
                        match evaluator.evaluate(&mut self.opacity, &expr,
                                                 true, true) {
                            Ok(true) => { modified = true; }
                            Ok(false) => { }
                            Err(e) => {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Error when evaluating ",
                                                                                                             " : "],
                                                                                                           &match (&"opacity",
                                                                                                                   &e)
                                                                                                                {
                                                                                                                (arg0,
                                                                                                                 arg1)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt),
                                                                                                                 ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                             ::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            }
                            _ => { }
                        }
                        let expr = &layer.get_paint().color;
                        match evaluator.evaluate(&mut self.color, &expr, true,
                                                 true) {
                            Ok(true) => { modified = true; }
                            Ok(false) => { }
                            Err(e) => {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Error when evaluating ",
                                                                                                             " : "],
                                                                                                           &match (&"color",
                                                                                                                   &e)
                                                                                                                {
                                                                                                                (arg0,
                                                                                                                 arg1)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt),
                                                                                                                 ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                             ::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            }
                            _ => { }
                        }
                        let expr = &layer.get_paint().translate_anchor;
                        match evaluator.evaluate(&mut self.anchor, &expr,
                                                 true, false) {
                            Ok(true) => { modified = true; }
                            Ok(false) => { }
                            Err(e) => {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Error when evaluating ",
                                                                                                             " : "],
                                                                                                           &match (&"anchor",
                                                                                                                   &e)
                                                                                                                {
                                                                                                                (arg0,
                                                                                                                 arg1)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt),
                                                                                                                 ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                             ::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            }
                            _ => { }
                        }
                        Ok(modified)
                    }
                }
                #[repr(C)]
                #[rustc_copy_clone_marker]
                pub struct FillVertexProperties {
                    col: Color,
                    opacity: f32,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FillVertexProperties {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FillVertexProperties {
                            col: ref __self_0_0, opacity: ref __self_0_1 } =>
                            {
                                let mut debug_trait_builder =
                                    f.debug_struct("FillVertexProperties");
                                let _ =
                                    debug_trait_builder.field("col",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("opacity",
                                                              &&(*__self_0_1));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for FillVertexProperties {
                    #[inline]
                    fn clone(&self) -> FillVertexProperties {
                        {
                            let _: ::std::clone::AssertParamIsClone<Color>;
                            let _: ::std::clone::AssertParamIsClone<f32>;
                            *self
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::marker::Copy for FillVertexProperties { }
                impl ::glium::vertex::Vertex for FillVertexProperties {
                    #[inline]
                    fn build_bindings() -> ::glium::vertex::VertexFormat {
                        use std::borrow::Cow;
                        Cow::Owned(<[_]>::into_vec(box
                                                       [(Cow::Borrowed("col"),
                                                         {
                                                             let dummy:
                                                                     FillVertexProperties =
                                                                 unsafe {
                                                                     ::std::mem::uninitialized()
                                                                 };
                                                             let offset:
                                                                     usize =
                                                                 {
                                                                     let dummy_ref =
                                                                         &dummy;
                                                                     let field_ref =
                                                                         &dummy.col;
                                                                     (field_ref
                                                                          as
                                                                          *const _
                                                                          as
                                                                          usize)
                                                                         -
                                                                         (dummy_ref
                                                                              as
                                                                              *const _
                                                                              as
                                                                              usize)
                                                                 };
                                                             offset
                                                         },
                                                         {
                                                             fn attr_type_of_val<T: ::glium::vertex::Attribute>(_:
                                                                                                                    &T)
                                                              ->
                                                                  ::glium::vertex::AttributeType {
                                                                 <T as
                                                                     ::glium::vertex::Attribute>::get_type()
                                                             }
                                                             let dummy:
                                                                     &FillVertexProperties =
                                                                 unsafe {
                                                                     ::std::mem::transmute(0usize)
                                                                 };
                                                             attr_type_of_val(&dummy.col)
                                                         }, false),
                                                        (Cow::Borrowed("opacity"),
                                                         {
                                                             let dummy:
                                                                     FillVertexProperties =
                                                                 unsafe {
                                                                     ::std::mem::uninitialized()
                                                                 };
                                                             let offset:
                                                                     usize =
                                                                 {
                                                                     let dummy_ref =
                                                                         &dummy;
                                                                     let field_ref =
                                                                         &dummy.opacity;
                                                                     (field_ref
                                                                          as
                                                                          *const _
                                                                          as
                                                                          usize)
                                                                         -
                                                                         (dummy_ref
                                                                              as
                                                                              *const _
                                                                              as
                                                                              usize)
                                                                 };
                                                             offset
                                                         },
                                                         {
                                                             fn attr_type_of_val<T: ::glium::vertex::Attribute>(_:
                                                                                                                    &T)
                                                              ->
                                                                  ::glium::vertex::AttributeType {
                                                                 <T as
                                                                     ::glium::vertex::Attribute>::get_type()
                                                             }
                                                             let dummy:
                                                                     &FillVertexProperties =
                                                                 unsafe {
                                                                     ::std::mem::transmute(0usize)
                                                                 };
                                                             attr_type_of_val(&dummy.opacity)
                                                         }, false)]))
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::default::Default for FillVertexProperties {
                    #[inline]
                    fn default() -> FillVertexProperties {
                        FillVertexProperties{col:
                                                 ::std::default::Default::default(),
                                             opacity:
                                                 ::std::default::Default::default(),}
                    }
                }
                pub struct FeatureBucketData {
                    pub feature: ::mvt::Feature,
                    pub props: FillFeatureProperties,
                    pub start: usize,
                    pub end: usize,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FeatureBucketData {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FeatureBucketData {
                            feature: ref __self_0_0,
                            props: ref __self_0_1,
                            start: ref __self_0_2,
                            end: ref __self_0_3 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("FeatureBucketData");
                                let _ =
                                    debug_trait_builder.field("feature",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("props",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("start",
                                                              &&(*__self_0_2));
                                let _ =
                                    debug_trait_builder.field("end",
                                                              &&(*__self_0_3));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                pub struct FillBucket {
                    pub coord: TileCoords,
                    pub features: BTreeMap<u64, FeatureBucketData>,
                    pub indices: Vec<u16>,
                    pub vertices: Vec<Vertex>,
                    pub properties: FillFeatureProperties,
                    pub uniforms: UniformPropertyData,
                    pub pos_vbo: Option<VertexBuffer<Vertex>>,
                    pub last_ibo: Option<IndexBuffer<u16>>,
                    pub eval_dirty: bool,
                    pub upload_dirty: bool,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FillBucket {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FillBucket {
                            coord: ref __self_0_0,
                            features: ref __self_0_1,
                            indices: ref __self_0_2,
                            vertices: ref __self_0_3,
                            properties: ref __self_0_4,
                            uniforms: ref __self_0_5,
                            pos_vbo: ref __self_0_6,
                            last_ibo: ref __self_0_7,
                            eval_dirty: ref __self_0_8,
                            upload_dirty: ref __self_0_9 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("FillBucket");
                                let _ =
                                    debug_trait_builder.field("coord",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("features",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("indices",
                                                              &&(*__self_0_2));
                                let _ =
                                    debug_trait_builder.field("vertices",
                                                              &&(*__self_0_3));
                                let _ =
                                    debug_trait_builder.field("properties",
                                                              &&(*__self_0_4));
                                let _ =
                                    debug_trait_builder.field("uniforms",
                                                              &&(*__self_0_5));
                                let _ =
                                    debug_trait_builder.field("pos_vbo",
                                                              &&(*__self_0_6));
                                let _ =
                                    debug_trait_builder.field("last_ibo",
                                                              &&(*__self_0_7));
                                let _ =
                                    debug_trait_builder.field("eval_dirty",
                                                              &&(*__self_0_8));
                                let _ =
                                    debug_trait_builder.field("upload_dirty",
                                                              &&(*__self_0_9));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                impl layers::Bucket for FillBucket {
                    fn upload(&mut self, display: &Display) -> Result<()> {
                        if self.upload_dirty {
                            self.last_ibo =
                                Some(IndexBuffer::new(display,
                                                      glium::index::PrimitiveType::TrianglesList,
                                                      &self.indices)?);
                            self.pos_vbo =
                                Some(VertexBuffer::new(display,
                                                       &self.vertices)?);
                            self.upload_dirty = false;
                        }
                        Ok(())
                    }
                }
                impl FillBucket {
                    fn new(data: Rc<data::TileData>, source_layer: &str)
                     -> Result<Option<Self>> {
                        let mut features: BTreeMap<u64, FeatureBucketData> =
                            BTreeMap::new();
                        let mut vertices: Vec<Vertex> =
                            <[_]>::into_vec(box []);
                        let mut indices: Vec<u16> = <[_]>::into_vec(box []);
                        if let data::DecodedTileData::Vector(ref vec) =
                               data.data {
                            if let Some(layer) =
                                   vec.layers.iter().find(|x|
                                                              &x.name ==
                                                                  source_layer)
                                   {
                                let mult =
                                    EXTENT as f32 / layer.extent as f32;
                                for f in layer.features.iter() {
                                    if f.typ == ::mvt::GeomType::Polygon {
                                        let geom = &f.geom;
                                        let g: Vec<Vec<[f32; 2]>> =
                                            f.geom.iter().map(|r|
                                                                  r.iter().map(|p|
                                                                                   [p[0]
                                                                                        as
                                                                                        _,
                                                                                    p[1]
                                                                                        as
                                                                                        _]).collect()).collect();
                                        let zer = 0 as _;
                                        let ext = layer.extent as _;
                                        let sq =
                                            <[_]>::into_vec(box
                                                                [<[_]>::into_vec(box
                                                                                     [[zer,
                                                                                       zer],
                                                                                      [ext,
                                                                                       zer],
                                                                                      [ext,
                                                                                       ext],
                                                                                      [zer,
                                                                                       ext]])]);
                                        if let Ok(res) =
                                               ::tess2::intersect(&g, &sq) {
                                            let vertices_begin =
                                                vertices.len();
                                            let indices_begin = indices.len();
                                            for v in res.vertices.iter() {
                                                vertices.push(Vertex{pos:
                                                                         [v[0]
                                                                              as
                                                                              f32
                                                                              *
                                                                              mult,
                                                                          v[1]
                                                                              as
                                                                              f32
                                                                              *
                                                                              mult],
                                                                     feature:
                                                                         features.len()
                                                                             as
                                                                             u16,})
                                            }
                                            for i in res.indices.iter() {
                                                indices.push(vertices_begin as
                                                                 u16 +
                                                                 *i as u16);
                                            }
                                            features.insert(f.id,
                                                            FeatureBucketData{feature:
                                                                                  f.clone(),
                                                                              props:
                                                                                  Default::default(),
                                                                              start:
                                                                                  vertices_begin,
                                                                              end:
                                                                                  vertices.len(),});
                                        }
                                    }
                                }
                                return Ok(Some(FillBucket{coord: data.coord,
                                                          features,
                                                          properties:
                                                              Default::default(),
                                                          uniforms:
                                                              Default::default(),
                                                          vertices,
                                                          indices,
                                                          eval_dirty: true,
                                                          upload_dirty: true,
                                                          pos_vbo: None,
                                                          last_ibo: None,}));
                            }
                        }
                        return Ok(None);
                    }
                }
                pub struct FillLayer {
                    style_layer: style::FillLayer,
                    shader_program: glium::Program,
                    layout: (UniformPropertyLayout, FeaturePropertyLayout),
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FillLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FillLayer {
                            style_layer: ref __self_0_0,
                            shader_program: ref __self_0_1,
                            layout: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("FillLayer");
                                let _ =
                                    debug_trait_builder.field("style_layer",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("shader_program",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("layout",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                impl layers::BucketLayer for FillLayer {
                    type
                    Bucket
                    =
                    FillBucket;
                    fn new_tile(&mut self, display: &Display,
                                data: &Rc<data::TileData>)
                     -> Result<Option<Self::Bucket>> {
                        if (Some(&data.source) ==
                                self.style_layer.common.source.as_ref()) {
                            if let Some(ref source_layer) =
                                   self.style_layer.common.source_layer {
                                return Ok(FillBucket::new(data.clone(),
                                                          &source_layer)?);
                            }
                        }
                        Ok(None)
                    }
                    fn eval_bucket(&mut self,
                                   params: &render::EvaluationParams,
                                   bucket: &mut Self::Bucket) -> Result<()> {
                        let evaluator =
                            PropertiesEvaluator::only_zoom(params.zoom);
                        bucket.properties.eval(&self.style_layer,
                                               &evaluator)?;
                        bucket.eval_dirty = false;
                        bucket.upload_dirty = true;
                        Ok(())
                    }
                    fn render_bucket(&mut self,
                                     params: &mut render::RenderParams,
                                     bucket: &Self::Bucket) -> Result<()> {
                        let tile_matrix =
                            Mercator::tile_to_world(&bucket.coord);
                        let matrix =
                            params.projection * params.view * tile_matrix;
                        let matrix: [[f32; 4]; 4] = matrix.into();
                        let u_t: [f32; 4] = Default::default();
                        let uniforms =
                            {
                                let uniforms =
                                    ::uniforms::UniformsStorage::new("u_matrix",
                                                                     matrix);
                                let uniforms = uniforms.add("u_t", u_t);
                                uniforms
                            };
                        let draw_params =
                            glium::DrawParameters{blend:
                                                      glium::Blend::alpha_blending(),
                                                                                        ..Default::default()};
                        let buffers = bucket.pos_vbo.as_ref().unwrap();
                        let indices = bucket.last_ibo.as_ref().unwrap();
                        (params.frame).draw(buffers, indices,
                                            &self.shader_program, &uniforms,
                                            &draw_params)?;
                        Ok(())
                    }
                }
                impl FillLayer {
                    pub fn parse(f: &glium::backend::Facade,
                                 layer: style::FillLayer) -> Self {
                        let (uni, feat) =
                            ::map::render::property::PropertyLayoutBuilder::build::<FillFeatureProperties>(&layer);
                        {
                            let lvl = ::Level::Trace;
                            if lvl <= ::STATIC_MAX_LEVEL &&
                                   lvl <= ::max_level() {
                                ::__private_api_log(::std::fmt::Arguments::new_v1_formatted(&["Fill layer layout:\n  uniforms: ",
                                                                                              ",\n  features: "],
                                                                                            &match (&uni,
                                                                                                    &feat)
                                                                                                 {
                                                                                                 (arg0,
                                                                                                  arg1)
                                                                                                 =>
                                                                                                 [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                              ::std::fmt::Debug::fmt),
                                                                                                  ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                              ::std::fmt::Debug::fmt)],
                                                                                             },
                                                                                            &[::std::fmt::rt::v1::Argument{position:
                                                                                                                               ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                           format:
                                                                                                                               ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                  ' ',
                                                                                                                                                              align:
                                                                                                                                                                  ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                              flags:
                                                                                                                                                                  0u32,
                                                                                                                                                              precision:
                                                                                                                                                                  ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                              width:
                                                                                                                                                                  ::std::fmt::rt::v1::Count::Implied,},},
                                                                                              ::std::fmt::rt::v1::Argument{position:
                                                                                                                               ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                           format:
                                                                                                                               ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                  ' ',
                                                                                                                                                              align:
                                                                                                                                                                  ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                              flags:
                                                                                                                                                                  0u32,
                                                                                                                                                              precision:
                                                                                                                                                                  ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                              width:
                                                                                                                                                                  ::std::fmt::rt::v1::Count::Implied,},}]),
                                                    lvl,
                                                    &("rmaps::map::render::layers::fill",
                                                      "rmaps::map::render::layers::fill",
                                                      "rmaps/src/map/render/layers/fill.rs",
                                                      247u32));
                            }
                        };
                        let shader_program =
                            {
                                let vert_src =
                                    "uniform mat4 u_matrix;\n\nin vec2 pos;\n\n#pragma property : define vec4 color\n#pragma property : define float opacity\n\n\n/*\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n*/\n\nvoid main() {\n    v_feature = feature;\n    #pragma property : init vec4 color\n    #pragma property : init float opacity\n\n    gl_Position = u_matrix *  vec4(pos, 0.0, 1.0);\n}";
                                let frag_src =
                                    "#pragma property : define vec4 color;\n#pragma property : define float opacity;\n\n\nvoid main() {\n\n    #pragma property : init vec4 color;\n    #pragma property : init float opacity;\n\n    gl_FragColor = color * opacity;\n}";
                                ::map::render::shaders::ShaderProcessor::get_shader(f,
                                                                                    vert_src,
                                                                                    frag_src,
                                                                                    &uni,
                                                                                    &feat)
                            };
                        FillLayer{layout: (uni, feat),
                                  style_layer: layer,
                                  shader_program: shader_program.unwrap(),}
                    }
                }
            }
            #[repr(C)]
            #[rustc_copy_clone_marker]
            pub struct Vertex {
                #[glium(attr = "pos")]
                pos: [f32; 2],
                feature: u16,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for Vertex {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        Vertex { pos: ref __self_0_0, feature: ref __self_0_1
                        } => {
                            let mut debug_trait_builder =
                                f.debug_struct("Vertex");
                            let _ =
                                debug_trait_builder.field("pos",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("feature",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Vertex {
                #[inline]
                fn clone(&self) -> Vertex {
                    {
                        let _: ::std::clone::AssertParamIsClone<[f32; 2]>;
                        let _: ::std::clone::AssertParamIsClone<u16>;
                        *self
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::marker::Copy for Vertex { }
            impl ::glium::vertex::Vertex for Vertex {
                #[inline]
                fn build_bindings() -> ::glium::vertex::VertexFormat {
                    use std::borrow::Cow;
                    Cow::Owned(<[_]>::into_vec(box
                                                   [(Cow::Borrowed("pos"),
                                                     {
                                                         let dummy: Vertex =
                                                             unsafe {
                                                                 ::std::mem::uninitialized()
                                                             };
                                                         let offset: usize =
                                                             {
                                                                 let dummy_ref =
                                                                     &dummy;
                                                                 let field_ref =
                                                                     &dummy.pos;
                                                                 (field_ref as
                                                                      *const _
                                                                      as
                                                                      usize) -
                                                                     (dummy_ref
                                                                          as
                                                                          *const _
                                                                          as
                                                                          usize)
                                                             };
                                                         offset
                                                     },
                                                     {
                                                         fn attr_type_of_val<T: ::glium::vertex::Attribute>(_:
                                                                                                                &T)
                                                          ->
                                                              ::glium::vertex::AttributeType {
                                                             <T as
                                                                 ::glium::vertex::Attribute>::get_type()
                                                         }
                                                         let dummy: &Vertex =
                                                             unsafe {
                                                                 ::std::mem::transmute(0usize)
                                                             };
                                                         attr_type_of_val(&dummy.pos)
                                                     }, false),
                                                    (Cow::Borrowed("feature"),
                                                     {
                                                         let dummy: Vertex =
                                                             unsafe {
                                                                 ::std::mem::uninitialized()
                                                             };
                                                         let offset: usize =
                                                             {
                                                                 let dummy_ref =
                                                                     &dummy;
                                                                 let field_ref =
                                                                     &dummy.feature;
                                                                 (field_ref as
                                                                      *const _
                                                                      as
                                                                      usize) -
                                                                     (dummy_ref
                                                                          as
                                                                          *const _
                                                                          as
                                                                          usize)
                                                             };
                                                         offset
                                                     },
                                                     {
                                                         fn attr_type_of_val<T: ::glium::vertex::Attribute>(_:
                                                                                                                &T)
                                                          ->
                                                              ::glium::vertex::AttributeType {
                                                             <T as
                                                                 ::glium::vertex::Attribute>::get_type()
                                                         }
                                                         let dummy: &Vertex =
                                                             unsafe {
                                                                 ::std::mem::transmute(0usize)
                                                             };
                                                         attr_type_of_val(&dummy.feature)
                                                     }, false)]))
                }
            }
            pub enum RenderPass { Opaque, Translucent, Extrusion, }
            pub trait Layer: Debug {
                /// Called when new tile data arrives, individual layers will need to copy the Rc, if they need to keep the data around
                fn new_tile(&mut self, display: &Display,
                            data: &Rc<data::TileData>)
                -> Result<()>;
                /// Called for new layers, or layers that have been explicitly changed
                /// Also called when zoom level changes
                fn evaluate(&mut self, params: &render::EvaluationParams)
                -> Result<()>;
                /// Called for each frame, GPU uploads and rendering happens here
                fn render(&mut self, params: &mut render::RenderParams)
                -> Result<()>;
                fn begin_pass(&mut self, params: &mut render::RenderParams,
                              pass: RenderPass) -> Result<()> {
                    Ok(())
                }
                fn has_render_pass(&self, pass: RenderPass) -> bool {
                    match pass { RenderPass::Opaque => true, _ => false, }
                }
                fn end_pass(&mut self, params: &mut render::RenderParams,
                            pass: RenderPass) -> Result<()> {
                    Ok(())
                }
            }
            pub trait Bucket: Debug {
                fn needs_explicit_eval(&self) -> bool { false }
                fn upload(&mut self, display: &Display)
                -> Result<()>;
            }
            pub trait BucketLayer: Debug {
                type
                Bucket: Bucket;
                fn begin_pass(&mut self, params: &mut render::RenderParams,
                              pass: RenderPass) -> Result<()> {
                    Ok(())
                }
                fn end_pass(&mut self, params: &mut render::RenderParams,
                            pass: RenderPass) -> Result<()> {
                    Ok(())
                }
                fn new_tile(&mut self, display: &Display,
                            data: &Rc<data::TileData>)
                -> Result<Option<Self::Bucket>>;
                fn eval_layer(&mut self, params: &render::EvaluationParams)
                 -> Result<()> {
                    Ok(())
                }
                fn eval_bucket(&mut self, params: &render::EvaluationParams,
                               bucket: &mut Self::Bucket)
                -> Result<()>;
                fn render_bucket(&mut self, params: &mut render::RenderParams,
                                 bucket: &Self::Bucket)
                -> Result<()>;
            }
            pub struct BucketState<B: Bucket> {
                pub bucket: B,
                pub evaluated: Option<render::EvaluationParams>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <B: ::std::fmt::Debug + Bucket> ::std::fmt::Debug for
             BucketState<B> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        BucketState {
                        bucket: ref __self_0_0, evaluated: ref __self_0_1 } =>
                        {
                            let mut debug_trait_builder =
                                f.debug_struct("BucketState");
                            let _ =
                                debug_trait_builder.field("bucket",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("evaluated",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            pub struct BucketLayerHolder<L: BucketLayer> {
                pub layer: L,
                pub buckets: BTreeMap<TileCoords, BucketState<L::Bucket>>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <L: ::std::fmt::Debug + BucketLayer> ::std::fmt::Debug for
             BucketLayerHolder<L> where L::Bucket: ::std::fmt::Debug {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        BucketLayerHolder {
                        layer: ref __self_0_0, buckets: ref __self_0_1 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("BucketLayerHolder");
                            let _ =
                                debug_trait_builder.field("layer",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("buckets",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            impl <L: BucketLayer> BucketLayerHolder<L> {
                pub fn new(l: L) -> Self {
                    BucketLayerHolder{layer: l, buckets: BTreeMap::new(),}
                }
            }
            impl <L: BucketLayer> Layer for BucketLayerHolder<L> {
                fn new_tile(&mut self, display: &Display,
                            data: &Rc<data::TileData>) -> Result<()> {
                    let coords = data.coord;
                    if let Some(bucket) = self.layer.new_tile(display, data)?
                           {
                        self.buckets.insert(coords,
                                            BucketState{bucket,
                                                        evaluated: None,});
                    };
                    Ok(())
                }
                /// TODO, better system for re-evaluating and uploading  modified data,
                /// Only re-evaluate on zoom change of integer coordinates ?
                fn evaluate(&mut self, params: &render::EvaluationParams)
                 -> Result<()> {
                    let zoom = params.zoom as _;
                    let pred =
                        |(k, _): &(&TileCoords, &mut BucketState<L::Bucket>)|
                            { k.z < zoom as i32 + 1 };
                    for (k, mut v) in self.buckets.iter_mut().filter(pred) {
                        let should_eval =
                            match v.evaluated {
                                None => true,
                                Some(ref e) if e.zoom != zoom => true,
                                _ => false,
                            };
                        if should_eval {
                            self.layer.eval_bucket(params, &mut v.bucket)?;
                        }
                        v.evaluated =
                            Some(render::EvaluationParams::new(zoom));
                    }
                    Ok(())
                }
                fn render(&mut self, params: &mut render::RenderParams)
                 -> Result<()> {
                    self.layer.begin_pass(params, RenderPass::Opaque)?;
                    let zoom = params.camera.zoom;
                    let pred =
                        |(k, _): &(&TileCoords, &mut BucketState<L::Bucket>)|
                            { k.z < zoom as i32 + 1 };
                    for (k, mut v) in self.buckets.iter_mut().filter(pred) {
                        v.bucket.upload(params.disp)?;
                        self.layer.render_bucket(params, &mut v.bucket)?;
                    }
                    self.layer.end_pass(params, RenderPass::Opaque)?;
                    Ok(())
                }
            }
            pub fn parse_style_layers(facade: &Display, style: &style::Style)
             -> Vec<Box<dyn Layer>> {
                let mut res: Vec<Box<Layer>> = <[_]>::into_vec(box []);
                for l in style.layers.iter() {
                    match l {
                        style::BaseStyleLayer::Background(l) => {
                            res.push(Box::new(background::BackgroundLayer::parse(l.clone())))
                        }
                        style::BaseStyleLayer::Fill(l) => {
                            res.push(Box::new(BucketLayerHolder::new(fill::FillLayer::parse(facade,
                                                                                            l.clone()))))
                        }
                        style::BaseStyleLayer::Raster(l) => {
                            res.push(Box::new(raster::RasterLayer::parse(facade,
                                                                         l.clone())))
                        }
                        _ => { }
                    }
                }
                res
            }
        }
        pub mod property {
            use ::prelude::*;
            use map::style::{StyleProp,
                             expr::{Expression, Expr, val::Value,
                                    DescribeType, Type, EvaluationContext}};
            use std::convert::{TryFrom, Into};
            /// Types that can be Property values
            pub trait Propertable: TryFrom<Value, Error = Type> +
             Into<Value> + Debug + Clone + Default + DescribeType {
            }
            impl <T: TryFrom<Value, Error = Type> + Into<Value> + Debug +
                  Clone + Default + DescribeType> Propertable for T {
            }
            pub trait Evaluable {
                type
                ValueType: Propertable;
                fn eval(&mut self, expr: &Expr, context: &EvaluationContext)
                -> bool;
                fn get(&self)
                -> Self::ValueType;
                fn set(&mut self, v: Self::ValueType);
            }
            pub trait Visitable<T: Propertable> {
                fn visit<V: PropertiesVisitor>(&self, visitor: &mut V);
            }
            #[repr(C)]
            pub struct BaseProp<T: Propertable> {
                val: T,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::fmt::Debug + Propertable> ::std::fmt::Debug for
             BaseProp<T> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        BaseProp { val: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("BaseProp");
                            let _ =
                                debug_trait_builder.field("val",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::clone::Clone + Propertable> ::std::clone::Clone
             for BaseProp<T> {
                #[inline]
                fn clone(&self) -> BaseProp<T> {
                    match *self {
                        BaseProp { val: ref __self_0_0 } =>
                        BaseProp{val:
                                     ::std::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::default::Default + Propertable>
             ::std::default::Default for BaseProp<T> {
                #[inline]
                fn default() -> BaseProp<T> {
                    BaseProp{val: ::std::default::Default::default(),}
                }
            }
            impl <T: Propertable> Evaluable for BaseProp<T> {
                type
                ValueType
                =
                T;
                fn eval(&mut self, expr: &Expr, context: &EvaluationContext)
                 -> bool {
                    let v = expr.eval(context).unwrap();
                    self.val = T::try_from(v).unwrap();
                    return true;
                }
                fn get(&self) -> Self::ValueType { self.val.clone() }
                fn set(&mut self, v: Self::ValueType) { self.val = v; }
            }
            impl <T: Propertable> Visitable<T> for BaseProp<T> {
                fn visit<V: PropertiesVisitor>(&self, visitor: &mut V) {
                    visitor.visit_base(self)
                }
            }
            #[repr(C)]
            pub struct GpuProp<T: Propertable +
                               glium::vertex::Attribute>(BaseProp<T>);
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::fmt::Debug + Propertable +
                  glium::vertex::Attribute> ::std::fmt::Debug for GpuProp<T> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        GpuProp(ref __self_0_0) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("GpuProp");
                            let _ =
                                debug_trait_builder.field(&&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::clone::Clone + Propertable +
                  glium::vertex::Attribute> ::std::clone::Clone for GpuProp<T>
             {
                #[inline]
                fn clone(&self) -> GpuProp<T> {
                    match *self {
                        GpuProp(ref __self_0_0) =>
                        GpuProp(::std::clone::Clone::clone(&(*__self_0_0))),
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::default::Default + Propertable +
                  glium::vertex::Attribute> ::std::default::Default for
             GpuProp<T> {
                #[inline]
                fn default() -> GpuProp<T> {
                    GpuProp(::std::default::Default::default())
                }
            }
            impl <T: Propertable + glium::vertex::Attribute> Evaluable for
             GpuProp<T> {
                type
                ValueType
                =
                T;
                fn eval(&mut self, expr: &Expr, context: &EvaluationContext)
                 -> bool {
                    self.0.eval(expr, context)
                }
                fn get(&self) -> Self::ValueType { self.0.get() }
                fn set(&mut self, v: Self::ValueType) { self.0.set(v) }
            }
            impl <T: Propertable + glium::vertex::Attribute> Visitable<T> for
             GpuProp<T> {
                fn visit<V: PropertiesVisitor>(&self, visitor: &mut V) {
                    visitor.visit_gpu(&self);
                }
            }
            pub struct PropertiesEvaluator<'a> {
                zoom: Option<f32>,
                feature: Option<&'a ::mvt::Feature>,
            }
            impl <'a, 'b: 'a> From<&'b super::EvaluationParams> for
             PropertiesEvaluator<'a> {
                fn from(p: &'b super::EvaluationParams) -> Self {
                    PropertiesEvaluator{zoom: Some(p.zoom), feature: None,}
                }
            }
            impl <'a> PropertiesEvaluator<'a> {
                pub fn only_zoom(zoom: f32) -> Self {
                    return PropertiesEvaluator{zoom: Some(zoom as _),
                                               feature: None,};
                }
                pub fn new(zoom: f32, feature: &'a ::mvt::Feature) -> Self {
                    return PropertiesEvaluator{zoom: Some(zoom as _),
                                               feature: Some(feature),};
                }
                pub fn with_feature(mut self, feature: &'a ::mvt::Feature)
                 -> Self {
                    self.feature = Some(feature);
                    self
                }
                pub fn evaluate<T: Propertable, E: Evaluable<ValueType =
                                T>>(&self, prop: &mut E,
                                    expr: &::map::style::StyleProp<T>,
                                    zoom_allowed: bool, feature_allowed: bool)
                 -> Result<bool> {
                    match expr {
                        ::map::style::StyleProp::Value(v) => {
                            prop.set((v.clone()));
                            return Ok(false);
                        }
                        ::map::style::StyleProp::Expr(e) => {
                            let ctx =
                                ::map::style::expr::EvaluationContext{zoom:
                                                                          self.zoom,
                                                                      feature_data:
                                                                          self.feature,
                                                                      bindings:
                                                                          ::std::cell::RefCell::new(BTreeMap::new()),};
                            if e.is_zoom() && !zoom_allowed {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Zoom expression not allowed for expression : "],
                                                                                                           &match (&e,)
                                                                                                                {
                                                                                                                (arg0,)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))));
                            } else if e.is_feature() && !feature_allowed {
                                return Err(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Feature expression not allowed for expression : "],
                                                                                                           &match (&e,)
                                                                                                                {
                                                                                                                (arg0,)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Debug::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))))
                            }
                            let res = prop.eval(&e.0, &ctx);
                            return Ok(res);
                        }
                    }
                    Ok(false)
                }
            }
            /// Struct used to build up "Layout" object from style layer properties
            pub trait PropertiesVisitor {
                fn visit_base<T: Propertable>(&mut self, v: &BaseProp<T>);
                fn visit_gpu<T: Propertable +
                             glium::vertex::Attribute>(&mut self,
                                                       v: &GpuProp<T>);
                fn visit<T: Propertable,
                         V: Visitable<T>>(&mut self, name: &str,
                                          style_prop: &StyleProp<T>,
                                          value_prop: &V, can_zoom: bool,
                                          can_feature: bool);
            }
            pub trait Properties: Default {
                type
                SourceLayerType: ::map::style::StyleLayer;
                /// Generates layout structure for shader compilation
                fn accept<V: PropertiesVisitor>(&self,
                                                layer: &Self::SourceLayerType,
                                                visitor: &mut V);
                /// Evaluates the property values, for this object, using specified evaluator
                fn eval(&mut self, layer: &Self::SourceLayerType,
                        evaluator: &PropertiesEvaluator)
                -> Result<bool>;
            }
            use map::render::shaders::{UniformPropertyLayout,
                                       FeaturePropertyLayout,
                                       PropertyItemLayout};
            pub struct PropertyLayoutBuilder {
                uniforms: UniformPropertyLayout,
                features: FeaturePropertyLayout,
                last_attr_type: Option<glium::vertex::AttributeType>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for PropertyLayoutBuilder {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        PropertyLayoutBuilder {
                        uniforms: ref __self_0_0,
                        features: ref __self_0_1,
                        last_attr_type: ref __self_0_2 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("PropertyLayoutBuilder");
                            let _ =
                                debug_trait_builder.field("uniforms",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("features",
                                                          &&(*__self_0_1));
                            let _ =
                                debug_trait_builder.field("last_attr_type",
                                                          &&(*__self_0_2));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::default::Default for PropertyLayoutBuilder {
                #[inline]
                fn default() -> PropertyLayoutBuilder {
                    PropertyLayoutBuilder{uniforms:
                                              ::std::default::Default::default(),
                                          features:
                                              ::std::default::Default::default(),
                                          last_attr_type:
                                              ::std::default::Default::default(),}
                }
            }
            impl PropertyLayoutBuilder {
                pub fn build<P: Properties>(layer: &P::SourceLayerType)
                 -> (UniformPropertyLayout, FeaturePropertyLayout) {
                    let mut builder = PropertyLayoutBuilder::default();
                    let tmp = P::default();
                    tmp.accept(&layer, &mut builder);
                    return (builder.uniforms, builder.features);
                }
            }
            impl PropertiesVisitor for PropertyLayoutBuilder {
                #[inline]
                fn visit_base<T: Propertable>(&mut self, v: &BaseProp<T>) {
                    self.last_attr_type = None;
                }
                #[inline]
                fn visit_gpu<T: Propertable +
                             glium::vertex::Attribute>(&mut self,
                                                       v: &GpuProp<T>) {
                    self.last_attr_type = Some(T::get_type());
                }
                #[inline]
                fn visit<T: Propertable,
                         V: Visitable<T>>(&mut self, name: &str,
                                          style_prop: &StyleProp<T>,
                                          value_prop: &V, can_zoom: bool,
                                          can_feature: bool) {
                    value_prop.visit(self);
                    if !can_zoom && style_prop.is_zoom() {
                        {
                            ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["Style not supported, `",
                                                                                             "` can\'t be a zoom property"],
                                                                                           &match (&name,)
                                                                                                {
                                                                                                (arg0,)
                                                                                                =>
                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::std::fmt::Display::fmt)],
                                                                                            },
                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                          format:
                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                 ' ',
                                                                                                                                                             align:
                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                             flags:
                                                                                                                                                                 0u32,
                                                                                                                                                             precision:
                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                             width:
                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]),
                                                  &("rmaps/src/map/render/property/mod.rs",
                                                    198u32, 13u32))
                        };
                    }
                    if !can_feature && style_prop.is_feature() {
                        {
                            ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["Style not supported, `",
                                                                                             "` can\'t be a feature property"],
                                                                                           &match (&name,)
                                                                                                {
                                                                                                (arg0,)
                                                                                                =>
                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                             ::std::fmt::Display::fmt)],
                                                                                            },
                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                          format:
                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                 ' ',
                                                                                                                                                             align:
                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                             flags:
                                                                                                                                                                 0u32,
                                                                                                                                                             precision:
                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                             width:
                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]),
                                                  &("rmaps/src/map/render/property/mod.rs",
                                                    202u32, 13u32))
                        };
                    }
                    {
                        let lvl = ::Level::Debug;
                        if lvl <= ::STATIC_MAX_LEVEL && lvl <= ::max_level() {
                            ::__private_api_log(::std::fmt::Arguments::new_v1_formatted(&["Visited : ",
                                                                                          " "],
                                                                                        &match (&name,)
                                                                                             {
                                                                                             (arg0,)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::std::fmt::Display::fmt)],
                                                                                         },
                                                                                        &[::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},}]),
                                                lvl,
                                                &("rmaps::map::render::property",
                                                  "rmaps::map::render::property",
                                                  "rmaps/src/map/render/property/mod.rs",
                                                  205u32));
                        }
                    };
                    {
                        let lvl = ::Level::Debug;
                        if lvl <= ::STATIC_MAX_LEVEL && lvl <= ::max_level() {
                            ::__private_api_log(::std::fmt::Arguments::new_v1_formatted(&["\t Zoom    : allowed ",
                                                                                          " , used : "],
                                                                                        &match (&can_zoom,
                                                                                                &style_prop.is_zoom())
                                                                                             {
                                                                                             (arg0,
                                                                                              arg1)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::std::fmt::Display::fmt),
                                                                                              ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                          ::std::fmt::Display::fmt)],
                                                                                         },
                                                                                        &[::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},},
                                                                                          ::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},}]),
                                                lvl,
                                                &("rmaps::map::render::property",
                                                  "rmaps::map::render::property",
                                                  "rmaps/src/map/render/property/mod.rs",
                                                  206u32));
                        }
                    };
                    {
                        let lvl = ::Level::Debug;
                        if lvl <= ::STATIC_MAX_LEVEL && lvl <= ::max_level() {
                            ::__private_api_log(::std::fmt::Arguments::new_v1_formatted(&["\t Feature : allowed ",
                                                                                          " , used : "],
                                                                                        &match (&can_feature,
                                                                                                &style_prop.is_feature())
                                                                                             {
                                                                                             (arg0,
                                                                                              arg1)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::std::fmt::Display::fmt),
                                                                                              ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                          ::std::fmt::Display::fmt)],
                                                                                         },
                                                                                        &[::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},},
                                                                                          ::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},}]),
                                                lvl,
                                                &("rmaps::map::render::property",
                                                  "rmaps::map::render::property",
                                                  "rmaps/src/map/render/property/mod.rs",
                                                  207u32));
                        }
                    };
                    {
                        let lvl = ::Level::Debug;
                        if lvl <= ::STATIC_MAX_LEVEL && lvl <= ::max_level() {
                            ::__private_api_log(::std::fmt::Arguments::new_v1_formatted(&["\t Attribute type : "],
                                                                                        &match (&self.last_attr_type,)
                                                                                             {
                                                                                             (arg0,)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::std::fmt::Debug::fmt)],
                                                                                         },
                                                                                        &[::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},}]),
                                                lvl,
                                                &("rmaps::map::render::property",
                                                  "rmaps::map::render::property",
                                                  "rmaps/src/map/render/property/mod.rs",
                                                  208u32));
                        }
                    };
                    if let Some(attr) = self.last_attr_type {
                        if style_prop.is_feature() {
                            self.features.push(name, attr);
                        } else { self.uniforms.push(name, attr); }
                    }
                }
            }
            pub struct FeaturePropertyData {
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for FeaturePropertyData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        FeaturePropertyData {  } => {
                            let mut debug_trait_builder =
                                f.debug_struct("FeaturePropertyData");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::default::Default for FeaturePropertyData {
                #[inline]
                fn default() -> FeaturePropertyData { FeaturePropertyData{} }
            }
            pub struct UniformPropertyData {
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for UniformPropertyData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        UniformPropertyData {  } => {
                            let mut debug_trait_builder =
                                f.debug_struct("UniformPropertyData");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::default::Default for UniformPropertyData {
                #[inline]
                fn default() -> UniformPropertyData { UniformPropertyData{} }
            }
            pub struct UniformPropertyBinder<'a> {
                gpu: bool,
                layout: &'a UniformPropertyLayout,
                data: &'a mut UniformPropertyData,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <'a> ::std::fmt::Debug for UniformPropertyBinder<'a> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        UniformPropertyBinder {
                        gpu: ref __self_0_0,
                        layout: ref __self_0_1,
                        data: ref __self_0_2 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("UniformPropertyBinder");
                            let _ =
                                debug_trait_builder.field("gpu",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("layout",
                                                          &&(*__self_0_1));
                            let _ =
                                debug_trait_builder.field("data",
                                                          &&(*__self_0_2));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            impl <'a> UniformPropertyBinder<'a> {
                fn new(layout: &'a UniformPropertyLayout,
                       data: &'a mut UniformPropertyData) -> Self {
                    UniformPropertyBinder{layout, gpu: false, data,}
                }
                pub fn bind<P: Properties>(layout: &UniformPropertyLayout,
                                           props: &P,
                                           style: &P::SourceLayerType,
                                           data: &mut UniformPropertyData)
                 -> Result<()> {
                    let mut binder = UniformPropertyBinder::new(layout, data);
                    props.accept(style, &mut binder);
                    Ok(())
                }
            }
            impl <'a> PropertiesVisitor for UniformPropertyBinder<'a> {
                fn visit_base<T: Propertable>(&mut self, v: &BaseProp<T>) {
                    self.gpu = false;
                }
                fn visit_gpu<T: Propertable +
                             glium::vertex::Attribute>(&mut self,
                                                       v: &GpuProp<T>) {
                    self.gpu = true;
                }
                fn visit<T: Propertable,
                         V: Visitable<T>>(&mut self, name: &str,
                                          style_prop: &StyleProp<T>,
                                          value_prop: &V, can_zoom: bool,
                                          can_feature: bool) {
                    value_prop.visit(self);
                    if self.gpu && self.layout.is_uniform(name) { }
                }
            }
        }
        pub mod shaders {
            use ::prelude::*;
            use ::common::glium::vertex::{AttributeType, Attribute};
            /// Layout of single property, can be bound to uniform value
            /// or sent in BufferTexture, and looked up based on feature ID
            pub struct PropertyItemLayout {
                pub name: String,
                pub format: AttributeType,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for PropertyItemLayout {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        PropertyItemLayout {
                        name: ref __self_0_0, format: ref __self_0_1 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("PropertyItemLayout");
                            let _ =
                                debug_trait_builder.field("name",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("format",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            /// Struct that holds information needed to bind per-feature property data into UBO or TBO, this data will be used by shader compilation
            /// to find out, which attributes need uniforms generated, and which need special retrieval function generated
            pub struct FeaturePropertyLayout {
                pub items: Vec<PropertyItemLayout>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for FeaturePropertyLayout {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        FeaturePropertyLayout { items: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("FeaturePropertyLayout");
                            let _ =
                                debug_trait_builder.field("items",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::default::Default for FeaturePropertyLayout {
                #[inline]
                fn default() -> FeaturePropertyLayout {
                    FeaturePropertyLayout{items:
                                              ::std::default::Default::default(),}
                }
            }
            impl FeaturePropertyLayout {
                pub fn push(&mut self, prop_name: &str,
                            format: AttributeType) {
                    self.items.push(PropertyItemLayout{name:
                                                           prop_name.to_string(),
                                                       format,});
                }
                pub fn is_feature(&self, prop_name: &str) -> bool {
                    return self.items.iter().any(|i| i.name == prop_name);
                }
            }
            /// Struct that holds information needed to bind Per-Layer data into shader uniforms, these are static or zoom-dependent
            /// properties
            pub struct UniformPropertyLayout {
                pub items: Vec<PropertyItemLayout>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for UniformPropertyLayout {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        UniformPropertyLayout { items: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("UniformPropertyLayout");
                            let _ =
                                debug_trait_builder.field("items",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::default::Default for UniformPropertyLayout {
                #[inline]
                fn default() -> UniformPropertyLayout {
                    UniformPropertyLayout{items:
                                              ::std::default::Default::default(),}
                }
            }
            impl UniformPropertyLayout {
                pub fn push(&mut self, prop_name: &str,
                            format: AttributeType) {
                    self.items.push(PropertyItemLayout{name:
                                                           prop_name.to_string(),
                                                       format,});
                }
                pub fn is_uniform(&self, prop_name: &str) -> bool {
                    return self.items.iter().any(|i| i.name == prop_name);
                }
            }
            pub struct ShaderProcessor;
            use common::regex::{Match, Matches, CaptureMatches, CaptureNames,
                                Captures};
            impl ShaderProcessor {
                fn uniform_name(prop_name: &str) -> String {
                    ::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["u_"],
                                                                          &match (&prop_name,)
                                                                               {
                                                                               (arg0,)
                                                                               =>
                                                                               [::std::fmt::ArgumentV1::new(arg0,
                                                                                                            ::std::fmt::Display::fmt)],
                                                                           },
                                                                          &[::std::fmt::rt::v1::Argument{position:
                                                                                                             ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                         format:
                                                                                                             ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                ' ',
                                                                                                                                            align:
                                                                                                                                                ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                            flags:
                                                                                                                                                0u32,
                                                                                                                                            precision:
                                                                                                                                                ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                            width:
                                                                                                                                                ::std::fmt::rt::v1::Count::Implied,},}]))
                }
                pub fn get_shader(displ: &glium::backend::Facade, vert: &str,
                                  frag: &str,
                                  uniforms: &UniformPropertyLayout,
                                  features: &FeaturePropertyLayout)
                 -> Result<glium::program::Program> {
                    let regex =
                        Regex::new(r"(?xm)

        \#pragma \s+ property \s* : \s* (?P<op>\w+) \s* (?P<type>\w+) \s+ (?P<name>\w+);?

        ").unwrap();
                    let common_defines =
                        "\n#define PER_FEATURE_SIZE float(128.0)\n\nfloat feature_get_float(float idx, float offset) {\n    return texelFetch(feature_data,int(idx * PER_FEATURE_SIZE + offset)).x;\n}\n\nvec2 feature_get_vec2(float idx, float offset) {\n    return texelFetch(feature_data,int(idx * PER_FEATURE_SIZE + offset)).xy;\n}\n\nvec3 feature_get_vec3(float idx, float offset) {\n    return texelFetch(feature_data,int(idx * PER_FEATURE_SIZE + offset)).xyz;\n}\n\nvec4 feature_get_vec4(float idx, float offset) {\n    return texelFetch(feature_data,int(idx * PER_FEATURE_SIZE + offset)).xyzw;\n}";
                    let vert_prelude =
                        "#version 300 es\n\n#extension GL_EXT_texture_buffer : require\n#extension GL_EXT_texture_buffer : enable\n\n// Only used on older version\n//#define in attribute\n//#define out varying\n\nprecision highp float;\n\nuniform samplerBuffer feature_data;\n\nin float feature;\nlayout(location = 7) out float v_feature;\n";
                    let frag_prelude =
                        "#version 300 es\n\n#extension GL_EXT_texture_buffer : require\n#extension GL_EXT_texture_buffer : enable\n\n\n//#define in varying\n\nprecision highp float;\nuniform samplerBuffer feature_data;\n\nlayout(location = 7) in float feature;";
                    let vert =
                        ::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["",
                                                                                "\n",
                                                                                "\n",
                                                                                "\n"],
                                                                              &match (&vert_prelude,
                                                                                      &common_defines,
                                                                                      &vert)
                                                                                   {
                                                                                   (arg0,
                                                                                    arg1,
                                                                                    arg2)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                ::std::fmt::Display::fmt),
                                                                                    ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                ::std::fmt::Display::fmt),
                                                                                    ::std::fmt::ArgumentV1::new(arg2,
                                                                                                                ::std::fmt::Display::fmt)],
                                                                               },
                                                                              &[::std::fmt::rt::v1::Argument{position:
                                                                                                                 ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                             format:
                                                                                                                 ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                    ' ',
                                                                                                                                                align:
                                                                                                                                                    ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                flags:
                                                                                                                                                    0u32,
                                                                                                                                                precision:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                width:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,},},
                                                                                ::std::fmt::rt::v1::Argument{position:
                                                                                                                 ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                             format:
                                                                                                                 ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                    ' ',
                                                                                                                                                align:
                                                                                                                                                    ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                flags:
                                                                                                                                                    0u32,
                                                                                                                                                precision:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                width:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,},},
                                                                                ::std::fmt::rt::v1::Argument{position:
                                                                                                                 ::std::fmt::rt::v1::Position::At(2usize),
                                                                                                             format:
                                                                                                                 ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                    ' ',
                                                                                                                                                align:
                                                                                                                                                    ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                flags:
                                                                                                                                                    0u32,
                                                                                                                                                precision:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                width:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,},}]));
                    let frag =
                        ::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["",
                                                                                "\n",
                                                                                "\n",
                                                                                "\n"],
                                                                              &match (&frag_prelude,
                                                                                      &common_defines,
                                                                                      &frag)
                                                                                   {
                                                                                   (arg0,
                                                                                    arg1,
                                                                                    arg2)
                                                                                   =>
                                                                                   [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                ::std::fmt::Display::fmt),
                                                                                    ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                ::std::fmt::Display::fmt),
                                                                                    ::std::fmt::ArgumentV1::new(arg2,
                                                                                                                ::std::fmt::Display::fmt)],
                                                                               },
                                                                              &[::std::fmt::rt::v1::Argument{position:
                                                                                                                 ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                             format:
                                                                                                                 ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                    ' ',
                                                                                                                                                align:
                                                                                                                                                    ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                flags:
                                                                                                                                                    0u32,
                                                                                                                                                precision:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                width:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,},},
                                                                                ::std::fmt::rt::v1::Argument{position:
                                                                                                                 ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                             format:
                                                                                                                 ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                    ' ',
                                                                                                                                                align:
                                                                                                                                                    ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                flags:
                                                                                                                                                    0u32,
                                                                                                                                                precision:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                width:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,},},
                                                                                ::std::fmt::rt::v1::Argument{position:
                                                                                                                 ::std::fmt::rt::v1::Position::At(2usize),
                                                                                                             format:
                                                                                                                 ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                    ' ',
                                                                                                                                                align:
                                                                                                                                                    ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                flags:
                                                                                                                                                    0u32,
                                                                                                                                                precision:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                width:
                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,},}]));
                    let process =
                        |caps: &Captures|
                            {
                                let op = caps.name("op").unwrap().as_str();
                                let typ = caps.name("type").unwrap().as_str();
                                let name =
                                    caps.name("name").unwrap().as_str();
                                let is_uniform = uniforms.is_uniform(name);
                                let is_feature = features.is_feature(name);
                                let feature_size_vec4 =
                                    if !(is_uniform ^ is_feature) {
                                        {
                                            ::rt::begin_panic("Property can\'t be both uniform and feature at the same time",
                                                              &("rmaps/src/map/render/shaders.rs",
                                                                88u32, 17u32))
                                        }
                                    };
                                let uniform_name =
                                    ShaderProcessor::uniform_name(name);
                                let res =
                                    match (op, typ, name, is_feature) {
                                        ("define", typ, name, false) => {
                                            ::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["uniform ",
                                                                                                    " ",
                                                                                                    ";"],
                                                                                                  &match (&typ,
                                                                                                          &uniform_name)
                                                                                                       {
                                                                                                       (arg0,
                                                                                                        arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                    ::std::fmt::Display::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                    ::std::fmt::Display::fmt)],
                                                                                                   },
                                                                                                  &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                    ::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},}]))
                                        }
                                        ("define", typ, name, true) => {
                                            ::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["\n                    ",
                                                                                                    " get_",
                                                                                                    " (float feature) {\n                       return feature_get_",
                                                                                                    "(feature,float(",
                                                                                                    "));\n                    }"],
                                                                                                  &match (&typ,
                                                                                                          &name,
                                                                                                          &0)
                                                                                                       {
                                                                                                       (arg0,
                                                                                                        arg1,
                                                                                                        arg2)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                    ::std::fmt::Display::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                    ::std::fmt::Display::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(arg2,
                                                                                                                                    ::std::fmt::Display::fmt)],
                                                                                                   },
                                                                                                  &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                    ::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                    ::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                    ::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(2usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},}]))
                                        }
                                        ("init", typ, name, false) => {
                                            ::fmt::format(::std::fmt::Arguments::new_v1(&["",
                                                                                          " ",
                                                                                          " = ",
                                                                                          ";"],
                                                                                        &match (&typ,
                                                                                                &name,
                                                                                                &uniform_name)
                                                                                             {
                                                                                             (arg0,
                                                                                              arg1,
                                                                                              arg2)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::std::fmt::Display::fmt),
                                                                                              ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                          ::std::fmt::Display::fmt),
                                                                                              ::std::fmt::ArgumentV1::new(arg2,
                                                                                                                          ::std::fmt::Display::fmt)],
                                                                                         }))
                                        }
                                        ("init", typ, name, true) => {
                                            ::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["",
                                                                                                    " ",
                                                                                                    " = get_",
                                                                                                    "(feature);"],
                                                                                                  &match (&typ,
                                                                                                          &name)
                                                                                                       {
                                                                                                       (arg0,
                                                                                                        arg1)
                                                                                                       =>
                                                                                                       [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                    ::std::fmt::Display::fmt),
                                                                                                        ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                    ::std::fmt::Display::fmt)],
                                                                                                   },
                                                                                                  &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                    ::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                    ::std::fmt::rt::v1::Argument{position:
                                                                                                                                     ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                 format:
                                                                                                                                     ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                        ' ',
                                                                                                                                                                    align:
                                                                                                                                                                        ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                    flags:
                                                                                                                                                                        0u32,
                                                                                                                                                                    precision:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                    width:
                                                                                                                                                                        ::std::fmt::rt::v1::Count::Implied,},}]))
                                        }
                                        (op, _, _, _) => {
                                            {
                                                ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["Invalid shader pragma operation : `",
                                                                                                                 "`"],
                                                                                                               &match (&op,)
                                                                                                                    {
                                                                                                                    (arg0,)
                                                                                                                    =>
                                                                                                                    [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                 ::std::fmt::Display::fmt)],
                                                                                                                },
                                                                                                               &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                  ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                              format:
                                                                                                                                                  ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                     ' ',
                                                                                                                                                                                 align:
                                                                                                                                                                                     ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                 flags:
                                                                                                                                                                                     0u32,
                                                                                                                                                                                 precision:
                                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                 width:
                                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,},}]),
                                                                      &("rmaps/src/map/render/shaders.rs",
                                                                        112u32,
                                                                        21u32))
                                            };
                                        }
                                        _ => { "".into() }
                                    };
                                ::io::_print(::std::fmt::Arguments::new_v1_formatted(&["op: `",
                                                                                       "`, typ : `",
                                                                                       "`, name : `",
                                                                                       "`\n"],
                                                                                     &match (&op,
                                                                                             &typ,
                                                                                             &name)
                                                                                          {
                                                                                          (arg0,
                                                                                           arg1,
                                                                                           arg2)
                                                                                          =>
                                                                                          [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                       ::std::fmt::Display::fmt),
                                                                                           ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                       ::std::fmt::Display::fmt),
                                                                                           ::std::fmt::ArgumentV1::new(arg2,
                                                                                                                       ::std::fmt::Display::fmt)],
                                                                                      },
                                                                                     &[::std::fmt::rt::v1::Argument{position:
                                                                                                                        ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                    format:
                                                                                                                        ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                           ' ',
                                                                                                                                                       align:
                                                                                                                                                           ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                       flags:
                                                                                                                                                           0u32,
                                                                                                                                                       precision:
                                                                                                                                                           ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                       width:
                                                                                                                                                           ::std::fmt::rt::v1::Count::Implied,},},
                                                                                       ::std::fmt::rt::v1::Argument{position:
                                                                                                                        ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                    format:
                                                                                                                        ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                           ' ',
                                                                                                                                                       align:
                                                                                                                                                           ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                       flags:
                                                                                                                                                           0u32,
                                                                                                                                                       precision:
                                                                                                                                                           ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                       width:
                                                                                                                                                           ::std::fmt::rt::v1::Count::Implied,},},
                                                                                       ::std::fmt::rt::v1::Argument{position:
                                                                                                                        ::std::fmt::rt::v1::Position::At(2usize),
                                                                                                                    format:
                                                                                                                        ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                           ' ',
                                                                                                                                                       align:
                                                                                                                                                           ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                       flags:
                                                                                                                                                           0u32,
                                                                                                                                                       precision:
                                                                                                                                                           ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                       width:
                                                                                                                                                           ::std::fmt::rt::v1::Count::Implied,},}]));
                                res
                            };
                    let vert_processed = regex.replace_all(&vert, process);
                    let frag_processed = regex.replace_all(&frag, process);
                    {
                        let lvl = ::Level::Trace;
                        if lvl <= ::STATIC_MAX_LEVEL && lvl <= ::max_level() {
                            ::__private_api_log(::std::fmt::Arguments::new_v1_formatted(&["Vertex shader processed \n Orig: \n",
                                                                                          "\n New : \n"],
                                                                                        &match (&vert,
                                                                                                &vert_processed)
                                                                                             {
                                                                                             (arg0,
                                                                                              arg1)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::std::fmt::Display::fmt),
                                                                                              ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                          ::std::fmt::Display::fmt)],
                                                                                         },
                                                                                        &[::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},},
                                                                                          ::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},}]),
                                                lvl,
                                                &("rmaps::map::render::shaders",
                                                  "rmaps::map::render::shaders",
                                                  "rmaps/src/map/render/shaders.rs",
                                                  127u32));
                        }
                    };
                    {
                        let lvl = ::Level::Trace;
                        if lvl <= ::STATIC_MAX_LEVEL && lvl <= ::max_level() {
                            ::__private_api_log(::std::fmt::Arguments::new_v1_formatted(&["Fragment shader processed \n Orig: \n",
                                                                                          "\n New : \n"],
                                                                                        &match (&frag,
                                                                                                &frag_processed)
                                                                                             {
                                                                                             (arg0,
                                                                                              arg1)
                                                                                             =>
                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                          ::std::fmt::Display::fmt),
                                                                                              ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                          ::std::fmt::Display::fmt)],
                                                                                         },
                                                                                        &[::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},},
                                                                                          ::std::fmt::rt::v1::Argument{position:
                                                                                                                           ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                       format:
                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                              ' ',
                                                                                                                                                          align:
                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                          flags:
                                                                                                                                                              0u32,
                                                                                                                                                          precision:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                          width:
                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},}]),
                                                lvl,
                                                &("rmaps::map::render::shaders",
                                                  "rmaps::map::render::shaders",
                                                  "rmaps/src/map/render/shaders.rs",
                                                  128u32));
                        }
                    };
                    Ok(glium::Program::from_source(displ, &vert_processed,
                                                   &frag_processed, None)?)
                }
            }
        }
        use map::style;
        use map::tiles::data;
        use std::hash;
        /// Idea:
        /// Stencil test for each tile, by utilizing encoding tile ids into 8 or 16 bits
        /// and using Equality tests for stencil clipping, therefore, no overlaps will be rendered
        ///
        pub struct RenderParams<'a> {
            pub disp: &'a Display,
            pub frame: &'a mut glium::Frame,
            pub projection: cgmath::Matrix4<f32>,
            pub view: cgmath::Matrix4<f32>,
            pub camera: &'a Camera,
            pub frame_start: PreciseTime,
        }
        pub struct EvaluationParams {
            pub zoom: f32,
            pub time: u64,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for EvaluationParams {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    EvaluationParams {
                    zoom: ref __self_0_0, time: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("EvaluationParams");
                        let _ =
                            debug_trait_builder.field("zoom",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("time",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        impl EvaluationParams {
            fn new(zoom: f32) -> Self { EvaluationParams{zoom, time: 0,} }
        }
        pub struct LayerData {
            pub layer: Box<layers::Layer>,
            pub evaluated: Option<EvaluationParams>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for LayerData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    LayerData {
                    layer: ref __self_0_0, evaluated: ref __self_0_1 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("LayerData");
                        let _ =
                            debug_trait_builder.field("layer",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("evaluated",
                                                      &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        pub struct Renderer {
            pub display: Box<Display>,
            pub layers: Vec<LayerData>,
        }
        impl Renderer {
            pub fn new(display: &Display) -> Self {
                Renderer{display: Box::new(display.clone()),
                         layers: <[_]>::into_vec(box []),}
            }
            pub fn style_changed(&mut self, style: &style::Style)
             -> Result<()> {
                self.layers =
                    layers::parse_style_layers(&self.display,
                                               style).into_iter().map(|l|
                                                                          {
                                                                              LayerData{layer:
                                                                                            l,
                                                                                        evaluated:
                                                                                            None,}
                                                                          }).collect();
                Ok(())
            }
            pub fn tile_ready(&mut self, tile: Rc<data::TileData>) {
                for l in self.layers.iter_mut() {
                    l.layer.new_tile(&self.display, &tile).unwrap();
                }
            }
            pub fn render(&mut self, mut params: RenderParams) -> Result<()> {
                let eval_params = EvaluationParams::new(params.camera.zoom);
                for l in self.layers.iter_mut() {
                    let (should_eval, really) =
                        match l.evaluated {
                            None => (true, true),
                            Some(ref e) if e.zoom != eval_params.zoom =>
                            (true, false),
                            _ => (false, false),
                        };
                    let t = PreciseTime::now();
                    if should_eval &&
                           (params.frame_start.to(t).num_milliseconds() < 2 ||
                                really) {
                        l.layer.evaluate(&eval_params)?;
                    }
                }
                for l in self.layers.iter_mut() {
                    l.layer.render(&mut params).unwrap();
                }
                Ok(())
            }
        }
    }
    pub mod style {
        use prelude::*;
        use common::json;
        pub mod expr {
            use prelude::*;
            pub use serde::{Deserializer, Deserialize, de::DeserializeOwned,
                            de::DeserializeSeed, de::Error as DeError};
            pub static TYPE: ::ScopedKey<Type> =
                ::ScopedKey{inner:
                                {
                                    const FOO:
                                          ::thread::LocalKey<::std::cell::Cell<usize>>
                                          =
                                        {
                                            #[inline]
                                            fn __init()
                                             -> ::std::cell::Cell<usize> {
                                                { ::std::cell::Cell::new(0) }
                                            }
                                            unsafe fn __getit()
                                             ->
                                                 ::option::Option<&'static ::cell::UnsafeCell<::option::Option<::std::cell::Cell<usize>>>> {
                                                #[thread_local]
                                                #[cfg(all(target_thread_local,
                                                          not(target_arch =
                                                                  "wasm32")))]
                                                static __KEY:
                                                       ::thread::__FastLocalKeyInner<::std::cell::Cell<usize>>
                                                       =
                                                    ::thread::__FastLocalKeyInner::new();
                                                __KEY.get()
                                            }
                                            unsafe {
                                                ::thread::LocalKey::new(__getit,
                                                                        __init)
                                            }
                                        };
                                    &FOO
                                },
                            _marker: ::std::marker::PhantomData,};
            pub static NAME: ::ScopedKey<String> =
                ::ScopedKey{inner:
                                {
                                    const FOO:
                                          ::thread::LocalKey<::std::cell::Cell<usize>>
                                          =
                                        {
                                            #[inline]
                                            fn __init()
                                             -> ::std::cell::Cell<usize> {
                                                { ::std::cell::Cell::new(0) }
                                            }
                                            unsafe fn __getit()
                                             ->
                                                 ::option::Option<&'static ::cell::UnsafeCell<::option::Option<::std::cell::Cell<usize>>>> {
                                                #[thread_local]
                                                #[cfg(all(target_thread_local,
                                                          not(target_arch =
                                                                  "wasm32")))]
                                                static __KEY:
                                                       ::thread::__FastLocalKeyInner<::std::cell::Cell<usize>>
                                                       =
                                                    ::thread::__FastLocalKeyInner::new();
                                                __KEY.get()
                                            }
                                            unsafe {
                                                ::thread::LocalKey::new(__getit,
                                                                        __init)
                                            }
                                        };
                                    &FOO
                                },
                            _marker: ::std::marker::PhantomData,};
            macro_rules! expr(( $ e : tt ) => {
                              Parse :: parse ( json ! ( $ e ) , Type :: Any )
                              } ;);
            macro_rules! delegate_to_inner(( @ pat $ var : path ; $ pat : pat
                                           ) => { $ var ( $ pat ) } ; (
                                           $ self : expr ; [
                                           $ ( $ variants : path ) , * ] ; $
                                           pat : pat => $ expr : expr $ (
                                           ; $ default : expr ) ? ) => {
                                           match $ self {
                                           $ (
                                           delegate_to_inner ! {
                                           @ pat $ variants ; $ pat } => $
                                           expr , ) * $ ( _ => $ default , ) ?
                                           } } ;);
            macro_rules! delegate_from_inner(( $ ( $ tt : tt ) * ) => {
                                             unimplemented ! (  ) } ;);
            #[macro_use]
            pub mod parse {
                use ::prelude::*;
                use super::*;
                pub enum ParseError { NotThis, Other(Error), }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for ParseError {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match (&*self,) {
                            (&ParseError::NotThis,) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("NotThis");
                                debug_trait_builder.finish()
                            }
                            (&ParseError::Other(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Other");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                impl ParseError {
                    fn not_this() -> Self { ParseError::NotThis }
                    fn other(e: Error) -> Self { ParseError::Other(e) }
                }
                impl <E: Into<::common::failure::Error>> From<E> for
                 ParseError {
                    fn from(v: E) -> Self { ParseError::Other(v.into()) }
                }
                pub type ParseResult<T> = StdResult<T, ParseError>;
                pub trait Parse: Sized {
                    fn parse(value: json::Value, expected: Type)
                    -> StdResult<Self, ParseError>;
                }
                pub fn parse_val<T: Parse>(val: json::Value)
                 -> ParseResult<T> {
                    parse_val_expect(val, Type::Any)
                }
                pub fn parse_val_expect<T: Parse>(val: json::Value,
                                                  expected: Type)
                 -> ParseResult<T> {
                    T::parse(val, expected)
                }
                pub struct First<H: Parse>(pub H, pub json::Value);
                impl <H: Parse> First<H> {
                    fn inner(self) -> (H, json::Value) {
                        return (self.0, self.1);
                    }
                }
                impl <H: Parse> Parse for First<H> {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        let mut arr: Vec<json::Value> =
                            json::from_value(value).map_err(|e|
                                                                ParseError::Other(e.into()))?;
                        if arr.len() == 0 {
                            return Err(ParseError::Other(::err_msg(::fmt::format(::std::fmt::Arguments::new_v1(&["Array to short"],
                                                                                                               &match ()
                                                                                                                    {
                                                                                                                    ()
                                                                                                                    =>
                                                                                                                    [],
                                                                                                                })))));
                        }
                        let head = parse_val(arr.remove(0))?;
                        return Ok(First(head, json::Value::Array(arr)));
                    }
                }
                macro_rules! derive_parse(( $ ( $ t : ty ) * ) => {
                                          $ (
                                          impl Parse for $ t {
                                          fn parse (
                                          value : json :: Value , expected :
                                          Type ) -> ParseResult < Self > {
                                          Ok (
                                          json :: from_value ( value ) .
                                          map_err (
                                          | e | ParseError :: Other (
                                          e . into (  ) ) ) ? ) } } ) * } ;);
                impl Parse for String {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for bool {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for u8 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for u16 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for u32 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for u64 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for usize {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for i8 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for i16 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for i32 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for i64 {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for isize {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for Type {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                impl Parse for json::Value {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        Ok(json::from_value(value).map_err(|e|
                                                               ParseError::Other(e.into()))?)
                    }
                }
                macro_rules! parse(( $ ( $ tt : tt ) * ) => {  } ;);
            }
            pub mod expressions {
                pub use ::prelude::*;
                mod prelude {
                    pub use ::prelude::*;
                    pub use super::super::{Type, Expr, Expression, NAME, TYPE,
                                           eval::*, val::*, parse::*,
                                           util::*};
                    pub use serde::{Deserializer, Deserialize,
                                    de::DeserializeOwned, de::DeserializeSeed,
                                    de::Error as DeError,
                                    de::{Visitor, SeqAccess}};
                }
                pub mod types {
                    use super::prelude::*;
                    pub enum Types {
                        Array(ArrayAssert),
                        Assert(Assert),
                        Literal(Literal),
                        Convert(Convert),
                        Typeof(TypeOf),
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Types {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&Types::Array(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Array");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Types::Assert(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Assert");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Types::Literal(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Literal");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Types::Convert(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Convert");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Types::Typeof(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Typeof");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Types {
                        #[inline]
                        fn clone(&self) -> Types {
                            match (&*self,) {
                                (&Types::Array(ref __self_0),) =>
                                Types::Array(::std::clone::Clone::clone(&(*__self_0))),
                                (&Types::Assert(ref __self_0),) =>
                                Types::Assert(::std::clone::Clone::clone(&(*__self_0))),
                                (&Types::Literal(ref __self_0),) =>
                                Types::Literal(::std::clone::Clone::clone(&(*__self_0))),
                                (&Types::Convert(ref __self_0),) =>
                                Types::Convert(::std::clone::Clone::clone(&(*__self_0))),
                                (&Types::Typeof(ref __self_0),) =>
                                Types::Typeof(::std::clone::Clone::clone(&(*__self_0))),
                            }
                        }
                    }
                    impl Expression for Types {
                        fn is_zoom(&self) -> bool {
                            match self {
                                Types::Array((v)) => v.is_zoom(),
                                Types::Assert((v)) => v.is_zoom(),
                                Types::Literal((v)) => v.is_zoom(),
                                Types::Convert((v)) => v.is_zoom(),
                                Types::Typeof((v)) => v.is_zoom(),
                            }
                        }
                        fn is_feature(&self) -> bool {
                            match self {
                                Types::Array((v)) => v.is_feature(),
                                Types::Assert((v)) => v.is_feature(),
                                Types::Literal((v)) => v.is_feature(),
                                Types::Convert((v)) => v.is_feature(),
                                Types::Typeof((v)) => v.is_feature(),
                            }
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            match self {
                                Types::Array((v)) => v.eval(ctx),
                                Types::Assert((v)) => v.eval(ctx),
                                Types::Literal((v)) => v.eval(ctx),
                                Types::Convert((v)) => v.eval(ctx),
                                Types::Typeof((v)) => v.eval(ctx),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Types {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            NAME.with(|n|
                                          {
                                              match n.deref() {
                                                  "array" =>
                                                  Ok(Types::Array(Deserialize::deserialize(deserializer)?)),
                                                  "boolean" | "number" |
                                                  "object" | "string" =>
                                                  Ok(Types::Assert(Deserialize::deserialize(deserializer)?)),
                                                  "literal" =>
                                                  Ok(Types::Literal(Deserialize::deserialize(deserializer)?)),
                                                  "to-boolean" | "to-color" |
                                                  "to-number" | "to-string" =>
                                                  Ok(Types::Convert(Deserialize::deserialize(deserializer)?)),
                                                  "typeof" =>
                                                  Ok(Types::Typeof(Deserialize::deserialize(deserializer)?)),
                                                  _ => {
                                                      {
                                                          ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["unknown expression "],
                                                                                                                         &match (&n,)
                                                                                                                              {
                                                                                                                              (arg0,)
                                                                                                                              =>
                                                                                                                              [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                           ::std::fmt::Debug::fmt)],
                                                                                                                          },
                                                                                                                         &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                            ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                        format:
                                                                                                                                                            ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                               ' ',
                                                                                                                                                                                           align:
                                                                                                                                                                                               ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                           flags:
                                                                                                                                                                                               0u32,
                                                                                                                                                                                           precision:
                                                                                                                                                                                               ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                           width:
                                                                                                                                                                                               ::std::fmt::rt::v1::Count::Implied,},}]),
                                                                                &("rmaps/src/map/style/expr/expressions/types.rs",
                                                                                  36u32,
                                                                                  21u32))
                                                      };
                                                  }
                                              }
                                          })
                        }
                    }
                    pub struct ArrayAssert(Option<Type>, Expr);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for ArrayAssert {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                ArrayAssert(ref __self_0_0, ref __self_0_1) =>
                                {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("ArrayAssert");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for ArrayAssert {
                        #[inline]
                        fn clone(&self) -> ArrayAssert {
                            match *self {
                                ArrayAssert(ref __self_0_0, ref __self_0_1) =>
                                ArrayAssert(::std::clone::Clone::clone(&(*__self_0_0)),
                                            ::std::clone::Clone::clone(&(*__self_0_1))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for ArrayAssert {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            #[serde(untagged)]
                            enum Help { ArrT(Type, Expr), Arr(Vec<Expr>), }
                            #[allow(non_upper_case_globals,
                                    unused_attributes,
                                    unused_qualifications)]
                            const _IMPL_DESERIALIZE_FOR_Help: () =
                                {
                                    #[allow(unknown_lints)]
                                    #[allow(rust_2018_idioms)]
                                    extern crate serde as _serde;
                                    #[allow(unused_macros)]
                                    macro_rules! try(( $ __expr : expr ) => {
                                                     match $ __expr {
                                                     _serde :: export :: Ok (
                                                     __val ) => __val , _serde
                                                     :: export :: Err ( __err
                                                     ) => {
                                                     return _serde :: export
                                                     :: Err ( __err ) ; } }
                                                     });
                                    #[automatically_derived]
                                    impl <'de> _serde::Deserialize<'de> for
                                     Help {
                                        fn deserialize<__D>(__deserializer:
                                                                __D)
                                         ->
                                             _serde::export::Result<Self,
                                                                    __D::Error>
                                         where
                                         __D: _serde::Deserializer<'de> {
                                            let __content =
                                                match <_serde::private::de::Content
                                                          as
                                                          _serde::Deserialize>::deserialize(__deserializer)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                            if let _serde::export::Ok(__ok) =
                                                   {
                                                       struct __Visitor<'de> {
                                                           marker: _serde::export::PhantomData<Help>,
                                                           lifetime: _serde::export::PhantomData<&'de ()>,
                                                       }
                                                       impl <'de>
                                                        _serde::de::Visitor<'de>
                                                        for __Visitor<'de> {
                                                           type
                                                           Value
                                                           =
                                                           Help;
                                                           fn expecting(&self,
                                                                        __formatter:
                                                                            &mut _serde::export::Formatter)
                                                            ->
                                                                _serde::export::fmt::Result {
                                                               _serde::export::Formatter::write_str(__formatter,
                                                                                                    "tuple variant Help::ArrT")
                                                           }
                                                           #[inline]
                                                           fn visit_seq<__A>(self,
                                                                             mut __seq:
                                                                                 __A)
                                                            ->
                                                                _serde::export::Result<Self::Value,
                                                                                       __A::Error>
                                                            where
                                                            __A: _serde::de::SeqAccess<'de> {
                                                               let __field0 =
                                                                   match match _serde::de::SeqAccess::next_element::<Type>(&mut __seq)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         } {
                                                                       _serde::export::Some(__value)
                                                                       =>
                                                                       __value,
                                                                       _serde::export::None
                                                                       => {
                                                                           return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                                        &"tuple variant Help::ArrT with 2 elements"));
                                                                       }
                                                                   };
                                                               let __field1 =
                                                                   match match _serde::de::SeqAccess::next_element::<Expr>(&mut __seq)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         } {
                                                                       _serde::export::Some(__value)
                                                                       =>
                                                                       __value,
                                                                       _serde::export::None
                                                                       => {
                                                                           return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                                                        &"tuple variant Help::ArrT with 2 elements"));
                                                                       }
                                                                   };
                                                               _serde::export::Ok(Help::ArrT(__field0,
                                                                                             __field1))
                                                           }
                                                       }
                                                       _serde::Deserializer::deserialize_tuple(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                                                                                               2usize,
                                                                                               __Visitor{marker:
                                                                                                             _serde::export::PhantomData::<Help>,
                                                                                                         lifetime:
                                                                                                             _serde::export::PhantomData,})
                                                   } {
                                                return _serde::export::Ok(__ok);
                                            }
                                            if let _serde::export::Ok(__ok) =
                                                   _serde::export::Result::map(<Vec<Expr>
                                                                                   as
                                                                                   _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                                               Help::Arr)
                                                   {
                                                return _serde::export::Ok(__ok);
                                            }
                                            _serde::export::Err(_serde::de::Error::custom("data did not match any variant of untagged enum Help"))
                                        }
                                    }
                                };
                            Ok(match Deserialize::deserialize(deserializer)? {
                                   Help::Arr(mut v) =>
                                   ArrayAssert(None, v.remove(0)),
                                   Help::ArrT(t, v) =>
                                   ArrayAssert(Some(t), v),
                               })
                        }
                    }
                    impl Expression for ArrayAssert {
                        fn is_zoom(&self) -> bool { self.1.is_zoom() }
                        fn is_feature(&self) -> bool { self.1.is_feature() }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            match self {
                                ArrayAssert(None, e) => {
                                    return Ok(if let Value::List(_) =
                                                     e.eval(ctx)? {
                                                  Value::Bool(true)
                                              } else { Value::Bool(false) });
                                }
                                ArrayAssert(Some(typ), e) => {
                                    return Ok(if let Value::List(l) =
                                                     e.eval(ctx)? {
                                                  return Ok(l.iter().all(|v|
                                                                             v.get_type()
                                                                                 ==
                                                                                 *typ).into());
                                              } else { Value::Bool(false) });
                                }
                            }
                        }
                    }
                    pub struct Assert(Type, Vec<Expr>);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Assert {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Assert(ref __self_0_0, ref __self_0_1) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Assert");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Assert {
                        #[inline]
                        fn clone(&self) -> Assert {
                            match *self {
                                Assert(ref __self_0_0, ref __self_0_1) =>
                                Assert(::std::clone::Clone::clone(&(*__self_0_0)),
                                       ::std::clone::Clone::clone(&(*__self_0_1))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Assert {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            return NAME.with(|n|
                                                 {
                                                     let t =
                                                         FromStr::from_str(&n).map_err(|_|
                                                                                           D::Error::custom("invalid type specifier for assert"))?;
                                                     let exprs =
                                                         Deserialize::deserialize(deserializer)?;
                                                     Ok(Assert(t, exprs))
                                                 });
                        }
                    }
                    impl Expression for Assert {
                        fn is_zoom(&self) -> bool {
                            return self.1.iter().any(|v| v.is_zoom());
                        }
                        fn is_feature(&self) -> bool {
                            return self.1.iter().any(|v| v.is_feature());
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            for e in self.1.iter() {
                                let v = e.eval(ctx)?;
                                if v.get_type() == self.0 { return Ok(v); }
                            }
                            return Ok(Value::Null);
                        }
                    }
                    pub struct Literal(Value);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Literal {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Literal(ref __self_0_0) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Literal");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Literal {
                        #[inline]
                        fn clone(&self) -> Literal {
                            match *self {
                                Literal(ref __self_0_0) =>
                                Literal(::std::clone::Clone::clone(&(*__self_0_0))),
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::cmp::PartialEq for Literal {
                        #[inline]
                        fn eq(&self, other: &Literal) -> bool {
                            match *other {
                                Literal(ref __self_1_0) =>
                                match *self {
                                    Literal(ref __self_0_0) =>
                                    (*__self_0_0) == (*__self_1_0),
                                },
                            }
                        }
                        #[inline]
                        fn ne(&self, other: &Literal) -> bool {
                            match *other {
                                Literal(ref __self_1_0) =>
                                match *self {
                                    Literal(ref __self_0_0) =>
                                    (*__self_0_0) != (*__self_1_0),
                                },
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Literal {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            TYPE.set(&Type::String,
                                     ||
                                         {
                                             let v =
                                                 Deserialize::deserialize(deserializer)?;
                                             Ok(Literal(v))
                                         })
                        }
                    }
                    impl Expression for Literal {
                        fn is_zoom(&self) -> bool { false }
                        fn is_feature(&self) -> bool { false }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            return Ok(self.0.clone());
                        }
                    }
                    pub struct Convert(Type, Vec<Expr>);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Convert {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Convert(ref __self_0_0, ref __self_0_1) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Convert");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Convert {
                        #[inline]
                        fn clone(&self) -> Convert {
                            match *self {
                                Convert(ref __self_0_0, ref __self_0_1) =>
                                Convert(::std::clone::Clone::clone(&(*__self_0_0)),
                                        ::std::clone::Clone::clone(&(*__self_0_1))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Convert {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            let typ =
                                NAME.with(|n|
                                              Ok(match n.deref() {
                                                     "to-boolean" =>
                                                     Type::Boolean,
                                                     "to-color" =>
                                                     Type::Color,
                                                     "to-number" =>
                                                     Type::Number,
                                                     "to-string" =>
                                                     Type::String,
                                                     _ => {
                                                         return Err(D::Error::custom("Invalid name for convert expr"));
                                                     }
                                                 }))?;
                            let v = Deserialize::deserialize(deserializer)?;
                            Ok(Convert(typ, v))
                        }
                    }
                    impl Expression for Convert {
                        fn is_zoom(&self) -> bool {
                            self.1.iter().any(|e| e.is_zoom())
                        }
                        fn is_feature(&self) -> bool {
                            self.1.iter().any(|e| e.is_feature())
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/types.rs",
                                                    186u32, 9u32))
                            }
                        }
                    }
                    pub struct TypeOf(Expr);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for TypeOf {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                TypeOf(ref __self_0_0) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("TypeOf");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for TypeOf {
                        #[inline]
                        fn clone(&self) -> TypeOf {
                            match *self {
                                TypeOf(ref __self_0_0) =>
                                TypeOf(::std::clone::Clone::clone(&(*__self_0_0))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for TypeOf {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            let mut v: Vec<Expr> =
                                Deserialize::deserialize(deserializer)?;
                            Ok(TypeOf(v.remove(0)))
                        }
                    }
                    impl Expression for TypeOf {
                        fn is_zoom(&self) -> bool { self.0.is_zoom() }
                        fn is_feature(&self) -> bool { self.0.is_feature() }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            let v = self.0.eval(ctx)?;
                            return Ok(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&[""],
                                                                                            &match (&v.get_type(),)
                                                                                                 {
                                                                                                 (arg0,)
                                                                                                 =>
                                                                                                 [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                              ::std::fmt::Debug::fmt)],
                                                                                             },
                                                                                            &[::std::fmt::rt::v1::Argument{position:
                                                                                                                               ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                           format:
                                                                                                                               ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                  ' ',
                                                                                                                                                              align:
                                                                                                                                                                  ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                              flags:
                                                                                                                                                                  0u32,
                                                                                                                                                              precision:
                                                                                                                                                                  ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                              width:
                                                                                                                                                                  ::std::fmt::rt::v1::Count::Implied,},}])).into());
                        }
                    }
                }
                pub mod feature {
                    use super::prelude::*;
                    pub enum FeatureExpr { GeomType, Id, Properties, }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for FeatureExpr {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&FeatureExpr::GeomType,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("GeomType");
                                    debug_trait_builder.finish()
                                }
                                (&FeatureExpr::Id,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Id");
                                    debug_trait_builder.finish()
                                }
                                (&FeatureExpr::Properties,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Properties");
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for FeatureExpr {
                        #[inline]
                        fn clone(&self) -> FeatureExpr {
                            match (&*self,) {
                                (&FeatureExpr::GeomType,) =>
                                FeatureExpr::GeomType,
                                (&FeatureExpr::Id,) => FeatureExpr::Id,
                                (&FeatureExpr::Properties,) =>
                                FeatureExpr::Properties,
                            }
                        }
                    }
                    impl Expression for FeatureExpr {
                        fn is_zoom(&self) -> bool { false }
                        fn is_feature(&self) -> bool { true }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/feature.rs",
                                                    19u32, 9u32))
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for FeatureExpr {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            NAME.with(|n|
                                          {
                                              match n.deref() {
                                                  "geometry-type" =>
                                                  Ok(FeatureExpr::GeomType),
                                                  "id" => Ok(FeatureExpr::Id),
                                                  "properties" =>
                                                  Ok(FeatureExpr::Properties),
                                                  _ =>
                                                  Err(D::Error::custom("Not a valid feature expression")),
                                              }
                                          })
                        }
                    }
                }
                pub mod lookup {
                    use super::prelude::*;
                    pub enum Lookup {
                        At(Expr, Expr),
                        Get(Expr, Option<Expr>),
                        Has(Expr, Option<Expr>),
                        Length(Expr),
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Lookup {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&Lookup::At(ref __self_0, ref __self_1),) =>
                                {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("At");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_1));
                                    debug_trait_builder.finish()
                                }
                                (&Lookup::Get(ref __self_0, ref __self_1),) =>
                                {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Get");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_1));
                                    debug_trait_builder.finish()
                                }
                                (&Lookup::Has(ref __self_0, ref __self_1),) =>
                                {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Has");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_1));
                                    debug_trait_builder.finish()
                                }
                                (&Lookup::Length(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Length");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Lookup {
                        #[inline]
                        fn clone(&self) -> Lookup {
                            match (&*self,) {
                                (&Lookup::At(ref __self_0, ref __self_1),) =>
                                Lookup::At(::std::clone::Clone::clone(&(*__self_0)),
                                           ::std::clone::Clone::clone(&(*__self_1))),
                                (&Lookup::Get(ref __self_0, ref __self_1),) =>
                                Lookup::Get(::std::clone::Clone::clone(&(*__self_0)),
                                            ::std::clone::Clone::clone(&(*__self_1))),
                                (&Lookup::Has(ref __self_0, ref __self_1),) =>
                                Lookup::Has(::std::clone::Clone::clone(&(*__self_0)),
                                            ::std::clone::Clone::clone(&(*__self_1))),
                                (&Lookup::Length(ref __self_0),) =>
                                Lookup::Length(::std::clone::Clone::clone(&(*__self_0))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Lookup {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            return NAME.with(|n|
                                                 {
                                                     match n.deref() {
                                                         "at" => {
                                                             struct Vis;
                                                             impl <'de>
                                                              Visitor<'de> for
                                                              Vis {
                                                                 type
                                                                 Value
                                                                 =
                                                                 Lookup;
                                                                 fn expecting(&self,
                                                                              formatter:
                                                                                  &mut fmt::Formatter)
                                                                  ->
                                                                      fmt::Result {
                                                                     formatter.write_str("arguments")
                                                                 }
                                                                 fn visit_seq<A>(self,
                                                                                 mut seq:
                                                                                     A)
                                                                  ->
                                                                      StdResult<Self::Value,
                                                                                A::Error>
                                                                  where
                                                                  A: SeqAccess<'de> {
                                                                     let first =
                                                                         TYPE.set(&Type::Number,
                                                                                  ||
                                                                                      {
                                                                                          seq.next_element()
                                                                                      })?.ok_or_else(||
                                                                                                         de::Error::invalid_length(1,
                                                                                                                                   &self))?;
                                                                     let second =
                                                                         TYPE.set(&Type::Array,
                                                                                  ||
                                                                                      {
                                                                                          seq.next_element()
                                                                                      })?.ok_or_else(||
                                                                                                         de::Error::invalid_length(1,
                                                                                                                                   &self))?;
                                                                     Ok(Lookup::At(first,
                                                                                   second))
                                                                 }
                                                             }
                                                             Ok(deserializer.deserialize_seq(Vis)?)
                                                         }
                                                         "get" => {
                                                             struct Vis;
                                                             impl <'de>
                                                              Visitor<'de> for
                                                              Vis {
                                                                 type
                                                                 Value
                                                                 =
                                                                 Lookup;
                                                                 fn expecting(&self,
                                                                              formatter:
                                                                                  &mut fmt::Formatter)
                                                                  ->
                                                                      fmt::Result {
                                                                     formatter.write_str("arguments")
                                                                 }
                                                                 fn visit_seq<A>(self,
                                                                                 mut seq:
                                                                                     A)
                                                                  ->
                                                                      StdResult<Self::Value,
                                                                                A::Error>
                                                                  where
                                                                  A: SeqAccess<'de> {
                                                                     let first =
                                                                         TYPE.set(&Type::String,
                                                                                  ||
                                                                                      {
                                                                                          seq.next_element()
                                                                                      })?.ok_or_else(||
                                                                                                         de::Error::invalid_length(1,
                                                                                                                                   &self))?;
                                                                     let second =
                                                                         TYPE.set(&Type::Object,
                                                                                  ||
                                                                                      {
                                                                                          seq.next_element()
                                                                                      })?;
                                                                     Ok(Lookup::Get(first,
                                                                                    second))
                                                                 }
                                                             }
                                                             Ok(deserializer.deserialize_seq(Vis)?)
                                                         }
                                                         "has" => {
                                                             struct Vis;
                                                             impl <'de>
                                                              Visitor<'de> for
                                                              Vis {
                                                                 type
                                                                 Value
                                                                 =
                                                                 Lookup;
                                                                 fn expecting(&self,
                                                                              formatter:
                                                                                  &mut fmt::Formatter)
                                                                  ->
                                                                      fmt::Result {
                                                                     formatter.write_str("arguments")
                                                                 }
                                                                 fn visit_seq<A>(self,
                                                                                 mut seq:
                                                                                     A)
                                                                  ->
                                                                      StdResult<Self::Value,
                                                                                A::Error>
                                                                  where
                                                                  A: SeqAccess<'de> {
                                                                     let first =
                                                                         TYPE.set(&Type::String,
                                                                                  ||
                                                                                      {
                                                                                          seq.next_element()
                                                                                      })?.ok_or_else(||
                                                                                                         de::Error::invalid_length(1,
                                                                                                                                   &self))?;
                                                                     let second =
                                                                         TYPE.set(&Type::Object,
                                                                                  ||
                                                                                      {
                                                                                          seq.next_element()
                                                                                      })?;
                                                                     Ok(Lookup::Has(first,
                                                                                    second))
                                                                 }
                                                             }
                                                             Ok(deserializer.deserialize_seq(Vis)?)
                                                         }
                                                         "length" => {
                                                             struct Vis;
                                                             impl <'de>
                                                              Visitor<'de> for
                                                              Vis {
                                                                 type
                                                                 Value
                                                                 =
                                                                 Lookup;
                                                                 fn expecting(&self,
                                                                              formatter:
                                                                                  &mut fmt::Formatter)
                                                                  ->
                                                                      fmt::Result {
                                                                     formatter.write_str("arguments")
                                                                 }
                                                                 fn visit_seq<A>(self,
                                                                                 mut seq:
                                                                                     A)
                                                                  ->
                                                                      StdResult<Self::Value,
                                                                                A::Error>
                                                                  where
                                                                  A: SeqAccess<'de> {
                                                                     let first =
                                                                         TYPE.set(&Type::String,
                                                                                  ||
                                                                                      {
                                                                                          seq.next_element()
                                                                                      })?.ok_or_else(||
                                                                                                         de::Error::invalid_length(1,
                                                                                                                                   &self))?;
                                                                     Ok(Lookup::Length(first))
                                                                 }
                                                             }
                                                             Ok(deserializer.deserialize_seq(Vis)?)
                                                         }
                                                         _ => {
                                                             {
                                                                 ::rt::begin_panic("Not a valid ident",
                                                                                   &("rmaps/src/map/style/expr/expressions/lookup.rs",
                                                                                     105u32,
                                                                                     21u32))
                                                             }
                                                         }
                                                     }
                                                 });
                        }
                    }
                    impl Expression for Lookup {
                        fn is_zoom(&self) -> bool { false }
                        fn is_feature(&self) -> bool { true }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/lookup.rs",
                                                    145u32, 9u32))
                            }
                        }
                    }
                }
                pub mod decision {
                    use super::prelude::*;
                    pub enum Decision {
                        Case(Case),
                        Match(Match),
                        Coalesce(Coalesce),
                        Logic(Logic),
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Decision {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&Decision::Case(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Case");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Decision::Match(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Match");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Decision::Coalesce(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Coalesce");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Decision::Logic(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Logic");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Decision {
                        #[inline]
                        fn clone(&self) -> Decision {
                            match (&*self,) {
                                (&Decision::Case(ref __self_0),) =>
                                Decision::Case(::std::clone::Clone::clone(&(*__self_0))),
                                (&Decision::Match(ref __self_0),) =>
                                Decision::Match(::std::clone::Clone::clone(&(*__self_0))),
                                (&Decision::Coalesce(ref __self_0),) =>
                                Decision::Coalesce(::std::clone::Clone::clone(&(*__self_0))),
                                (&Decision::Logic(ref __self_0),) =>
                                Decision::Logic(::std::clone::Clone::clone(&(*__self_0))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Decision {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            NAME.with(|n|
                                          {
                                              match n.deref() {
                                                  "case" =>
                                                  Ok(Decision::Case(Deserialize::deserialize(deserializer)?)),
                                                  "match" =>
                                                  Ok(Decision::Match(Deserialize::deserialize(deserializer)?)),
                                                  "coalesce" =>
                                                  Ok(Decision::Coalesce(Deserialize::deserialize(deserializer)?)),
                                                  _ =>
                                                  Ok(Decision::Logic(Deserialize::deserialize(deserializer)?)),
                                              }
                                          })
                        }
                    }
                    impl Expression for Decision {
                        fn is_zoom(&self) -> bool {
                            match self {
                                Decision::Case((v)) => v.is_zoom(),
                                Decision::Match((v)) => v.is_zoom(),
                                Decision::Coalesce((v)) => v.is_zoom(),
                                Decision::Logic((v)) => v.is_zoom(),
                            }
                        }
                        fn is_feature(&self) -> bool {
                            match self {
                                Decision::Case((v)) => v.is_feature(),
                                Decision::Match((v)) => v.is_feature(),
                                Decision::Coalesce((v)) => v.is_feature(),
                                Decision::Logic((v)) => v.is_feature(),
                            }
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            match self {
                                Decision::Case((v)) => v.eval(ctx),
                                Decision::Match((v)) => v.eval(ctx),
                                Decision::Coalesce((v)) => v.eval(ctx),
                                Decision::Logic((v)) => v.eval(ctx),
                            }
                        }
                    }
                    pub struct Case(Vec<(Expr, Expr)>, Expr);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Case {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Case(ref __self_0_0, ref __self_0_1) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Case");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Case {
                        #[inline]
                        fn clone(&self) -> Case {
                            match *self {
                                Case(ref __self_0_0, ref __self_0_1) =>
                                Case(::std::clone::Clone::clone(&(*__self_0_0)),
                                     ::std::clone::Clone::clone(&(*__self_0_1))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Case {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/decision.rs",
                                                    45u32, 9u32))
                            }
                        }
                    }
                    impl Expression for Case {
                        fn is_zoom(&self) -> bool {
                            return self.0.iter().any(|(a, b)|
                                                         a.is_zoom() ||
                                                             b.is_zoom()) ||
                                       self.1.is_zoom();
                        }
                        fn is_feature(&self) -> bool {
                            return self.0.iter().any(|(a, b)|
                                                         a.is_feature() ||
                                                             b.is_feature())
                                       || self.1.is_feature();
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            for (cond, val) in self.0.iter() {
                                let test =
                                    expect_type(Type::Boolean,
                                                cond.eval(ctx)?)?;
                                if let Value::Bool(test) = test {
                                    return val.eval(ctx);
                                }
                            }
                            self.1.eval(ctx)
                        }
                    }
                    pub struct Coalesce(Vec<Expr>);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Coalesce {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Coalesce(ref __self_0_0) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Coalesce");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Coalesce {
                        #[inline]
                        fn clone(&self) -> Coalesce {
                            match *self {
                                Coalesce(ref __self_0_0) =>
                                Coalesce(::std::clone::Clone::clone(&(*__self_0_0))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Coalesce {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/decision.rs",
                                                    76u32, 9u32))
                            }
                        }
                    }
                    impl Expression for Coalesce {
                        fn is_zoom(&self) -> bool {
                            self.0.iter().any(|v| v.is_zoom())
                        }
                        fn is_feature(&self) -> bool {
                            self.0.iter().any(|v| v.is_feature())
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            for e in self.0.iter() {
                                let v = e.eval(ctx)?;
                                if v.get_type() != Type::Null {
                                    return Ok(v);
                                }
                            }
                            return Ok(Value::Null);
                        }
                    }
                    pub struct MatchArm {
                        label: Value,
                        expr: Expr,
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for MatchArm {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                MatchArm {
                                label: ref __self_0_0, expr: ref __self_0_1 }
                                => {
                                    let mut debug_trait_builder =
                                        f.debug_struct("MatchArm");
                                    let _ =
                                        debug_trait_builder.field("label",
                                                                  &&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field("expr",
                                                                  &&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for MatchArm {
                        #[inline]
                        fn clone(&self) -> MatchArm {
                            match *self {
                                MatchArm {
                                label: ref __self_0_0, expr: ref __self_0_1 }
                                =>
                                MatchArm{label:
                                             ::std::clone::Clone::clone(&(*__self_0_0)),
                                         expr:
                                             ::std::clone::Clone::clone(&(*__self_0_1)),},
                            }
                        }
                    }
                    pub struct Match {
                        input: Expr,
                        arms: Vec<MatchArm>,
                        default: Expr,
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Match {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Match {
                                input: ref __self_0_0,
                                arms: ref __self_0_1,
                                default: ref __self_0_2 } => {
                                    let mut debug_trait_builder =
                                        f.debug_struct("Match");
                                    let _ =
                                        debug_trait_builder.field("input",
                                                                  &&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field("arms",
                                                                  &&(*__self_0_1));
                                    let _ =
                                        debug_trait_builder.field("default",
                                                                  &&(*__self_0_2));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Match {
                        #[inline]
                        fn clone(&self) -> Match {
                            match *self {
                                Match {
                                input: ref __self_0_0,
                                arms: ref __self_0_1,
                                default: ref __self_0_2 } =>
                                Match{input:
                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                      arms:
                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                      default:
                                          ::std::clone::Clone::clone(&(*__self_0_2)),},
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Match {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/decision.rs",
                                                    116u32, 9u32))
                            }
                        }
                    }
                    impl Expression for Match {
                        fn is_zoom(&self) -> bool {
                            return self.input.is_zoom() ||
                                       self.arms.iter().any(|a|
                                                                a.expr.is_zoom())
                                       || self.default.is_zoom();
                        }
                        fn is_feature(&self) -> bool {
                            return self.input.is_feature() ||
                                       self.arms.iter().any(|a|
                                                                a.expr.is_feature())
                                       || self.default.is_feature();
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            let val = self.input.eval(ctx)?;
                            for MatchArm { label, expr } in self.arms.iter() {
                                if &val == label { return expr.eval(ctx); }
                            }
                            return self.default.eval(ctx);
                        }
                    }
                    pub enum LogicOp {

                        #[serde(rename = "!")]
                        Not,

                        #[serde(rename = "==")]
                        Eq,

                        #[serde(rename = "!=")]
                        Neq,

                        #[serde(rename = ">")]
                        Gt,

                        #[serde(rename = ">=")]
                        Geq,

                        #[serde(rename = "<")]
                        Lt,

                        #[serde(rename = "<=")]
                        Leq,

                        #[serde(rename = "all")]
                        All,

                        #[serde(rename = "any")]
                        Any,

                        #[serde(rename = "none")]
                        None,
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for LogicOp {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&LogicOp::Not,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Not");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::Eq,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Eq");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::Neq,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Neq");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::Gt,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Gt");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::Geq,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Geq");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::Lt,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Lt");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::Leq,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Leq");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::All,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("All");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::Any,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Any");
                                    debug_trait_builder.finish()
                                }
                                (&LogicOp::None,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("None");
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for LogicOp {
                        #[inline]
                        fn clone(&self) -> LogicOp {
                            match (&*self,) {
                                (&LogicOp::Not,) => LogicOp::Not,
                                (&LogicOp::Eq,) => LogicOp::Eq,
                                (&LogicOp::Neq,) => LogicOp::Neq,
                                (&LogicOp::Gt,) => LogicOp::Gt,
                                (&LogicOp::Geq,) => LogicOp::Geq,
                                (&LogicOp::Lt,) => LogicOp::Lt,
                                (&LogicOp::Leq,) => LogicOp::Leq,
                                (&LogicOp::All,) => LogicOp::All,
                                (&LogicOp::Any,) => LogicOp::Any,
                                (&LogicOp::None,) => LogicOp::None,
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::cmp::PartialEq for LogicOp {
                        #[inline]
                        fn eq(&self, other: &LogicOp) -> bool {
                            {
                                let __self_vi =
                                    unsafe {
                                        ::std::intrinsics::discriminant_value(&*self)
                                    } as isize;
                                let __arg_1_vi =
                                    unsafe {
                                        ::std::intrinsics::discriminant_value(&*other)
                                    } as isize;
                                if true && __self_vi == __arg_1_vi {
                                    match (&*self, &*other) { _ => true, }
                                } else { false }
                            }
                        }
                    }
                    #[allow(non_upper_case_globals,
                            unused_attributes,
                            unused_qualifications)]
                    const _IMPL_DESERIALIZE_FOR_LogicOp: () =
                        {
                            #[allow(unknown_lints)]
                            #[allow(rust_2018_idioms)]
                            extern crate serde as _serde;
                            #[allow(unused_macros)]
                            macro_rules! try(( $ __expr : expr ) => {
                                             match $ __expr {
                                             _serde :: export :: Ok ( __val )
                                             => __val , _serde :: export ::
                                             Err ( __err ) => {
                                             return _serde :: export :: Err (
                                             __err ) ; } } });
                            #[automatically_derived]
                            impl <'de> _serde::Deserialize<'de> for LogicOp {
                                fn deserialize<__D>(__deserializer: __D)
                                 -> _serde::export::Result<Self, __D::Error>
                                 where __D: _serde::Deserializer<'de> {
                                    #[allow(non_camel_case_types)]
                                    enum __Field {
                                        __field0,
                                        __field1,
                                        __field2,
                                        __field3,
                                        __field4,
                                        __field5,
                                        __field6,
                                        __field7,
                                        __field8,
                                        __field9,
                                    }
                                    struct __FieldVisitor;
                                    impl <'de> _serde::de::Visitor<'de> for
                                     __FieldVisitor {
                                        type
                                        Value
                                        =
                                        __Field;
                                        fn expecting(&self,
                                                     __formatter:
                                                         &mut _serde::export::Formatter)
                                         -> _serde::export::fmt::Result {
                                            _serde::export::Formatter::write_str(__formatter,
                                                                                 "variant identifier")
                                        }
                                        fn visit_u64<__E>(self, __value: u64)
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __E> where
                                         __E: _serde::de::Error {
                                            match __value {
                                                0u64 =>
                                                _serde::export::Ok(__Field::__field0),
                                                1u64 =>
                                                _serde::export::Ok(__Field::__field1),
                                                2u64 =>
                                                _serde::export::Ok(__Field::__field2),
                                                3u64 =>
                                                _serde::export::Ok(__Field::__field3),
                                                4u64 =>
                                                _serde::export::Ok(__Field::__field4),
                                                5u64 =>
                                                _serde::export::Ok(__Field::__field5),
                                                6u64 =>
                                                _serde::export::Ok(__Field::__field6),
                                                7u64 =>
                                                _serde::export::Ok(__Field::__field7),
                                                8u64 =>
                                                _serde::export::Ok(__Field::__field8),
                                                9u64 =>
                                                _serde::export::Ok(__Field::__field9),
                                                _ =>
                                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                     &"variant index 0 <= i < 10")),
                                            }
                                        }
                                        fn visit_str<__E>(self, __value: &str)
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __E> where
                                         __E: _serde::de::Error {
                                            match __value {
                                                "!" =>
                                                _serde::export::Ok(__Field::__field0),
                                                "==" =>
                                                _serde::export::Ok(__Field::__field1),
                                                "!=" =>
                                                _serde::export::Ok(__Field::__field2),
                                                ">" =>
                                                _serde::export::Ok(__Field::__field3),
                                                ">=" =>
                                                _serde::export::Ok(__Field::__field4),
                                                "<" =>
                                                _serde::export::Ok(__Field::__field5),
                                                "<=" =>
                                                _serde::export::Ok(__Field::__field6),
                                                "all" =>
                                                _serde::export::Ok(__Field::__field7),
                                                "any" =>
                                                _serde::export::Ok(__Field::__field8),
                                                "none" =>
                                                _serde::export::Ok(__Field::__field9),
                                                _ => {
                                                    _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                           VARIANTS))
                                                }
                                            }
                                        }
                                        fn visit_bytes<__E>(self,
                                                            __value: &[u8])
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __E> where
                                         __E: _serde::de::Error {
                                            match __value {
                                                b"!" =>
                                                _serde::export::Ok(__Field::__field0),
                                                b"==" =>
                                                _serde::export::Ok(__Field::__field1),
                                                b"!=" =>
                                                _serde::export::Ok(__Field::__field2),
                                                b">" =>
                                                _serde::export::Ok(__Field::__field3),
                                                b">=" =>
                                                _serde::export::Ok(__Field::__field4),
                                                b"<" =>
                                                _serde::export::Ok(__Field::__field5),
                                                b"<=" =>
                                                _serde::export::Ok(__Field::__field6),
                                                b"all" =>
                                                _serde::export::Ok(__Field::__field7),
                                                b"any" =>
                                                _serde::export::Ok(__Field::__field8),
                                                b"none" =>
                                                _serde::export::Ok(__Field::__field9),
                                                _ => {
                                                    let __value =
                                                        &_serde::export::from_utf8_lossy(__value);
                                                    _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                           VARIANTS))
                                                }
                                            }
                                        }
                                    }
                                    impl <'de> _serde::Deserialize<'de> for
                                     __Field {
                                        #[inline]
                                        fn deserialize<__D>(__deserializer:
                                                                __D)
                                         ->
                                             _serde::export::Result<Self,
                                                                    __D::Error>
                                         where
                                         __D: _serde::Deserializer<'de> {
                                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                         __FieldVisitor)
                                        }
                                    }
                                    struct __Visitor<'de> {
                                        marker: _serde::export::PhantomData<LogicOp>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl <'de> _serde::de::Visitor<'de> for
                                     __Visitor<'de> {
                                        type
                                        Value
                                        =
                                        LogicOp;
                                        fn expecting(&self,
                                                     __formatter:
                                                         &mut _serde::export::Formatter)
                                         -> _serde::export::fmt::Result {
                                            _serde::export::Formatter::write_str(__formatter,
                                                                                 "enum LogicOp")
                                        }
                                        fn visit_enum<__A>(self, __data: __A)
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __A::Error>
                                         where
                                         __A: _serde::de::EnumAccess<'de> {
                                            match match _serde::de::EnumAccess::variant(__data)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                (__Field::__field0, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Not)
                                                }
                                                (__Field::__field1, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Eq)
                                                }
                                                (__Field::__field2, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Neq)
                                                }
                                                (__Field::__field3, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Gt)
                                                }
                                                (__Field::__field4, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Geq)
                                                }
                                                (__Field::__field5, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Lt)
                                                }
                                                (__Field::__field6, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Leq)
                                                }
                                                (__Field::__field7, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::All)
                                                }
                                                (__Field::__field8, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::Any)
                                                }
                                                (__Field::__field9, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(LogicOp::None)
                                                }
                                            }
                                        }
                                    }
                                    const VARIANTS: &'static [&'static str] =
                                        &["!", "==", "!=", ">", ">=", "<",
                                          "<=", "all", "any", "none"];
                                    _serde::Deserializer::deserialize_enum(__deserializer,
                                                                           "LogicOp",
                                                                           VARIANTS,
                                                                           __Visitor{marker:
                                                                                         _serde::export::PhantomData::<LogicOp>,
                                                                                     lifetime:
                                                                                         _serde::export::PhantomData,})
                                }
                            }
                        };
                    impl FromStr for LogicOp {
                        type
                        Err
                        =
                        serde::de::value::Error;
                        fn from_str(s: &str) -> StdResult<Self, Self::Err> {
                            use serde::de::IntoDeserializer;
                            let deser: serde::de::value::StrDeserializer<_> =
                                s.into_deserializer();
                            Ok(Self::deserialize(deser)?)
                        }
                    }
                    impl LogicOp {
                        fn min_args(&self) -> usize { 0 }
                    }
                    pub struct Logic(LogicOp, Vec<Expr>);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Logic {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Logic(ref __self_0_0, ref __self_0_1) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Logic");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Logic {
                        #[inline]
                        fn clone(&self) -> Logic {
                            match *self {
                                Logic(ref __self_0_0, ref __self_0_1) =>
                                Logic(::std::clone::Clone::clone(&(*__self_0_0)),
                                      ::std::clone::Clone::clone(&(*__self_0_1))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Logic {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/decision.rs",
                                                    224u32, 9u32))
                            }
                        }
                    }
                    impl Expression for Logic {
                        fn is_zoom(&self) -> bool {
                            return self.1.iter().any(|e| e.is_zoom());
                        }
                        fn is_feature(&self) -> bool {
                            return self.1.iter().any(|e| e.is_feature());
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            return Ok(match (&self.0, &self.1[..]) {
                                          (LogicOp::Not, [a]) => {
                                              (!expect_bool(a.eval(ctx)?)?).into()
                                          }
                                          (LogicOp::Neq, [a, b]) => {
                                              (a.eval(ctx)? != b.eval(ctx)?)
                                          }
                                          (LogicOp::Eq, [a, b]) => {
                                              (a.eval(ctx)? == b.eval(ctx)?)
                                          }
                                          (LogicOp::Lt, [a, b]) => {
                                              (a.eval(ctx)? < b.eval(ctx)?)
                                          }
                                          (LogicOp::Leq, [a, b]) => {
                                              (a.eval(ctx)? <= b.eval(ctx)?)
                                          }
                                          (LogicOp::Gt, [a, b]) => {
                                              (a.eval(ctx)? > b.eval(ctx)?)
                                          }
                                          (LogicOp::Geq, [a, b]) => {
                                              (a.eval(ctx)? >= b.eval(ctx)?)
                                          }
                                          (LogicOp::All, [exprs..]) => {
                                              let r: StdResult<Vec<_>, _> =
                                                  exprs.iter().map(|e|
                                                                       e.eval(ctx).and_then(|a|
                                                                                                expect_bool(a))).collect();
                                              r?.iter().all(|a| *a)
                                          }
                                          (LogicOp::Any, [exprs..]) => {
                                              let r: StdResult<Vec<_>, _> =
                                                  exprs.iter().map(|e|
                                                                       e.eval(ctx).and_then(|a|
                                                                                                expect_bool(a))).collect();
                                              r?.iter().any(|a| *a)
                                          }
                                          (LogicOp::None, [exprs..]) => {
                                              let r: StdResult<Vec<_>, _> =
                                                  exprs.iter().map(|e|
                                                                       e.eval(ctx).and_then(|a|
                                                                                                expect_bool(a))).collect();
                                              r?.iter().all(|a| !*a)
                                          }
                                          (a, b) => {
                                              return Err(EvalError::custom(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Invalid combination of logical operation and arguments: op ",
                                                                                                                                   ", args : "],
                                                                                                                                 &match (&self.0,
                                                                                                                                         &self.1)
                                                                                                                                      {
                                                                                                                                      (arg0,
                                                                                                                                       arg1)
                                                                                                                                      =>
                                                                                                                                      [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                   ::std::fmt::Debug::fmt),
                                                                                                                                       ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                   ::std::fmt::Debug::fmt)],
                                                                                                                                  },
                                                                                                                                 &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                    ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                format:
                                                                                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                       ' ',
                                                                                                                                                                                                   align:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                   flags:
                                                                                                                                                                                                       0u32,
                                                                                                                                                                                                   precision:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                   width:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                                                   ::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                    ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                                                format:
                                                                                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                       ' ',
                                                                                                                                                                                                   align:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                   flags:
                                                                                                                                                                                                       0u32,
                                                                                                                                                                                                   precision:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                   width:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},}]))));
                                          }
                                      }.into());
                        }
                    }
                }
                pub mod interp {
                    use super::prelude::*;
                    pub enum Interp { Interpolate(Interpolate), Step(Step), }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Interp {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&Interp::Interpolate(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Interpolate");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Interp::Step(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Step");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Interp {
                        #[inline]
                        fn clone(&self) -> Interp {
                            match (&*self,) {
                                (&Interp::Interpolate(ref __self_0),) =>
                                Interp::Interpolate(::std::clone::Clone::clone(&(*__self_0))),
                                (&Interp::Step(ref __self_0),) =>
                                Interp::Step(::std::clone::Clone::clone(&(*__self_0))),
                            }
                        }
                    }
                    impl Expression for Interp {
                        fn is_zoom(&self) -> bool {
                            match self {
                                Interp::Interpolate((v)) => v.is_zoom(),
                                Interp::Step((v)) => v.is_zoom(),
                            }
                        }
                        fn is_feature(&self) -> bool {
                            match self {
                                Interp::Interpolate((v)) => v.is_feature(),
                                Interp::Step((v)) => v.is_feature(),
                            }
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            match self {
                                Interp::Interpolate((v)) => v.eval(ctx),
                                Interp::Step((v)) => v.eval(ctx),
                            }
                        }
                    }
                    pub enum InterpolateType {
                        Linear,
                        Exponential(f64),
                        Cubic(f64, f64, f64, f64),
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for InterpolateType {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&InterpolateType::Linear,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Linear");
                                    debug_trait_builder.finish()
                                }
                                (&InterpolateType::Exponential(ref __self_0),)
                                => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Exponential");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&InterpolateType::Cubic(ref __self_0,
                                                         ref __self_1,
                                                         ref __self_2,
                                                         ref __self_3),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Cubic");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_1));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_2));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_3));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for InterpolateType {
                        #[inline]
                        fn clone(&self) -> InterpolateType {
                            match (&*self,) {
                                (&InterpolateType::Linear,) =>
                                InterpolateType::Linear,
                                (&InterpolateType::Exponential(ref __self_0),)
                                =>
                                InterpolateType::Exponential(::std::clone::Clone::clone(&(*__self_0))),
                                (&InterpolateType::Cubic(ref __self_0,
                                                         ref __self_1,
                                                         ref __self_2,
                                                         ref __self_3),) =>
                                InterpolateType::Cubic(::std::clone::Clone::clone(&(*__self_0)),
                                                       ::std::clone::Clone::clone(&(*__self_1)),
                                                       ::std::clone::Clone::clone(&(*__self_2)),
                                                       ::std::clone::Clone::clone(&(*__self_3))),
                            }
                        }
                    }
                    #[inline]
                    fn clamp(min: f64, max: f64, val: f64) -> f64 {
                        f64::min(f64::max(val, 0.0), 1.0)
                    }
                    use std::ops::{Add, Mul, Sub};
                    #[inline]
                    fn lerp<T: Clone + Add<Output = T> + Sub<Output = T> +
                            Mul<f64, Output = T>>(a: T, b: T, factor: f64)
                     -> T {
                        a.clone() + (b - a) * factor
                    }
                    impl InterpolateType {
                        fn get_factor(&self, a: f64, b: f64, value: f64)
                         -> f64 {
                            let range = b - a;
                            let progress = value - a;
                            return clamp(0., 1.,
                                         match self {
                                             InterpolateType::Linear => {
                                                 progress / range
                                             }
                                             InterpolateType::Exponential(base)
                                             => {
                                                 (f64::powf(*base, progress) -
                                                      1.) /
                                                     (f64::powf(*base, range)
                                                          - 1.)
                                             }
                                             InterpolateType::Cubic(x1, y1,
                                                                    x2, y2) =>
                                             {
                                                 {
                                                     ::rt::begin_panic("Cubic bezier interpolation not yet supported",
                                                                       &("rmaps/src/map/style/expr/expressions/interp.rs",
                                                                         57u32,
                                                                         17u32))
                                                 }
                                             }
                                         });
                        }
                    }
                    impl <'de> Deserialize<'de> for InterpolateType {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, <D as Deserializer<'de>>::Error>
                         where D: Deserializer<'de> {
                            let mut input: Vec<json::Value> =
                                Deserialize::deserialize(deserializer)?;
                            if input.len() < 1 {
                                return Err(D::Error::custom("Array too short"));
                            }
                            let name = input.remove(0);
                            return if name.as_str() == Some("linear") {
                                       Ok(InterpolateType::Linear)
                                   } else if name.as_str() ==
                                                 Some("exponential") &&
                                                 input.len() >= 1 {
                                       let base: StdResult<f64, _> =
                                           json::from_value(input.remove(0));
                                       base.map(|v|
                                                    InterpolateType::Exponential(v)).map_err(|_|
                                                                                                 D::Error::custom("Invalid exponential exponent"))
                                   } else if name.as_str() ==
                                                 Some("cubic-bezier") &&
                                                 input.len() >= 4 {
                                       let points: StdResult<Vec<f64>, _> =
                                           input.into_iter().map(json::from_value).collect();
                                       points.map(|p|
                                                      InterpolateType::Cubic(p[0],
                                                                             p[1],
                                                                             p[2],
                                                                             p[3])).map_err(|_|
                                                                                                D::Error::custom("Invalid bezier control points"))
                                   } else {
                                       Err(D::Error::custom("Could not parse expression as interpolation specifier"))
                                   };
                        }
                    }
                    pub struct Stop {
                        val: f64,
                        out: Expr,
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Stop {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Stop {
                                val: ref __self_0_0, out: ref __self_0_1 } =>
                                {
                                    let mut debug_trait_builder =
                                        f.debug_struct("Stop");
                                    let _ =
                                        debug_trait_builder.field("val",
                                                                  &&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field("out",
                                                                  &&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Stop {
                        #[inline]
                        fn clone(&self) -> Stop {
                            match *self {
                                Stop {
                                val: ref __self_0_0, out: ref __self_0_1 } =>
                                Stop{val:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     out:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),},
                            }
                        }
                    }
                    pub struct Interpolate {
                        typ: InterpolateType,
                        input: Expr,
                        stops: Vec<Stop>,
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Interpolate {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Interpolate {
                                typ: ref __self_0_0,
                                input: ref __self_0_1,
                                stops: ref __self_0_2 } => {
                                    let mut debug_trait_builder =
                                        f.debug_struct("Interpolate");
                                    let _ =
                                        debug_trait_builder.field("typ",
                                                                  &&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field("input",
                                                                  &&(*__self_0_1));
                                    let _ =
                                        debug_trait_builder.field("stops",
                                                                  &&(*__self_0_2));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Interpolate {
                        #[inline]
                        fn clone(&self) -> Interpolate {
                            match *self {
                                Interpolate {
                                typ: ref __self_0_0,
                                input: ref __self_0_1,
                                stops: ref __self_0_2 } =>
                                Interpolate{typ:
                                                ::std::clone::Clone::clone(&(*__self_0_0)),
                                            input:
                                                ::std::clone::Clone::clone(&(*__self_0_1)),
                                            stops:
                                                ::std::clone::Clone::clone(&(*__self_0_2)),},
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Interpolate {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            struct Vis;
                            impl <'de> Visitor<'de> for Vis {
                                type
                                Value
                                =
                                Interpolate;
                                fn expecting(&self,
                                             formatter: &mut fmt::Formatter)
                                 -> fmt::Result {
                                    formatter.write_str("Interpolate expression")
                                }
                                fn visit_seq<A>(self, mut seq: A)
                                 -> StdResult<Self::Value, A::Error> where
                                 A: SeqAccess<'de> {
                                    let typ =
                                        seq.next_element()?.ok_or_else(||
                                                                           de::Error::invalid_length(1,
                                                                                                     &self))?;
                                    let input =
                                        TYPE.set(&Type::Number,
                                                 ||
                                                     {
                                                         seq.next_element()
                                                     })?.ok_or_else(||
                                                                        de::Error::invalid_length(2,
                                                                                                  &self))?;
                                    let mut stops = <[_]>::into_vec(box []);
                                    while let (Some(val), Some(out)) =
                                              (seq.next_element()?,
                                               TYPE.set(&Type::Color,
                                                        ||
                                                            {
                                                                seq.next_element()
                                                            })?) {
                                        stops.push(Stop{val, out,})
                                    };
                                    Ok(Interpolate{typ, input, stops,})
                                }
                            }
                            Ok(deserializer.deserialize_seq(Vis)?)
                        }
                    }
                    impl Expression for Interpolate {
                        fn is_zoom(&self) -> bool {
                            self.input.is_zoom() ||
                                self.stops.iter().any(|s| s.out.is_zoom())
                        }
                        fn is_feature(&self) -> bool {
                            let inp = self.input.is_feature();
                            let stops =
                                self.stops.iter().any(|s| s.out.is_feature());
                            inp || stops
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            let val = expect_num(self.input.eval(ctx)?)?;
                            let lower =
                                self.stops.iter().rfind(|s| s.val <= val);
                            let upper =
                                self.stops.iter().find(|s| s.val >= val);
                            match (lower, upper) {
                                (Some(l), Some(h)) => {
                                    let factor =
                                        self.typ.get_factor(l.val, h.val,
                                                            val);
                                    let low = l.out.eval(ctx)?;
                                    let high = h.out.eval(ctx)?;
                                    fn do_lerp(low: &Value, high: &Value,
                                               factor: f64) -> ExprResult {
                                        if low.get_type() != high.get_type() {
                                            return Err(EvalError::custom(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Mismatch between interpolate output types: low: ",
                                                                                                                                 " high : ",
                                                                                                                                 " "],
                                                                                                                               &match (&low.get_type(),
                                                                                                                                       &high.get_type())
                                                                                                                                    {
                                                                                                                                    (arg0,
                                                                                                                                     arg1)
                                                                                                                                    =>
                                                                                                                                    [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                 ::std::fmt::Debug::fmt),
                                                                                                                                     ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                 ::std::fmt::Debug::fmt)],
                                                                                                                                },
                                                                                                                               &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                  ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                              format:
                                                                                                                                                                  ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                     ' ',
                                                                                                                                                                                                 align:
                                                                                                                                                                                                     ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                 flags:
                                                                                                                                                                                                     0u32,
                                                                                                                                                                                                 precision:
                                                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                 width:
                                                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                                                 ::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                  ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                                              format:
                                                                                                                                                                  ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                     ' ',
                                                                                                                                                                                                 align:
                                                                                                                                                                                                     ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                 flags:
                                                                                                                                                                                                     0u32,
                                                                                                                                                                                                 precision:
                                                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                 width:
                                                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,},}]))));
                                        }
                                        Ok(match (low, high) {
                                               (Value::Num(a), Value::Num(b))
                                               =>
                                               Value::Num(lerp(*a, *b,
                                                               factor)),
                                               (Value::Color(a),
                                                Value::Color(b)) =>
                                               Value::Color(lerp(*a, *b,
                                                                 factor)),
                                               (Value::String(a),
                                                Value::String(b)) =>
                                               Value::Color(lerp(Color::from_str(a).unwrap(),
                                                                 Color::from_str(b).unwrap(),
                                                                 factor)),
                                               (Value::List(a),
                                                Value::List(b)) => {
                                                   let mut res =
                                                       <[_]>::into_vec(box
                                                                           []);
                                                   if a.len() != b.len() {
                                                       return Err(EvalError::custom(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Mismatch between interpolate array lengths: a: ",
                                                                                                                                            " b : ",
                                                                                                                                            " "],
                                                                                                                                          &match (&a.len(),
                                                                                                                                                  &b.len())
                                                                                                                                               {
                                                                                                                                               (arg0,
                                                                                                                                                arg1)
                                                                                                                                               =>
                                                                                                                                               [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                            ::std::fmt::Debug::fmt),
                                                                                                                                                ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                            ::std::fmt::Debug::fmt)],
                                                                                                                                           },
                                                                                                                                          &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                             ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                         format:
                                                                                                                                                                             ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                                ' ',
                                                                                                                                                                                                            align:
                                                                                                                                                                                                                ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                            flags:
                                                                                                                                                                                                                0u32,
                                                                                                                                                                                                            precision:
                                                                                                                                                                                                                ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                            width:
                                                                                                                                                                                                                ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                                                            ::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                             ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                                                         format:
                                                                                                                                                                             ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                                ' ',
                                                                                                                                                                                                            align:
                                                                                                                                                                                                                ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                            flags:
                                                                                                                                                                                                                0u32,
                                                                                                                                                                                                            precision:
                                                                                                                                                                                                                ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                            width:
                                                                                                                                                                                                                ::std::fmt::rt::v1::Count::Implied,},}]))));
                                                   }
                                                   for (a, b) in
                                                       a.iter().zip(b.iter())
                                                       {
                                                       res.push(do_lerp(a, b,
                                                                        factor)?)
                                                   }
                                                   Value::List(res)
                                               }
                                               (a@_, b@_) => {
                                                   return Err(EvalError::custom(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Interpolate not supported for type pair: ",
                                                                                                                                        " and "],
                                                                                                                                      &match (&a.get_type(),
                                                                                                                                              &b.get_type())
                                                                                                                                           {
                                                                                                                                           (arg0,
                                                                                                                                            arg1)
                                                                                                                                           =>
                                                                                                                                           [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                        ::std::fmt::Debug::fmt),
                                                                                                                                            ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                        ::std::fmt::Debug::fmt)],
                                                                                                                                       },
                                                                                                                                      &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                         ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                     format:
                                                                                                                                                                         ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                            ' ',
                                                                                                                                                                                                        align:
                                                                                                                                                                                                            ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                        flags:
                                                                                                                                                                                                            0u32,
                                                                                                                                                                                                        precision:
                                                                                                                                                                                                            ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                        width:
                                                                                                                                                                                                            ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                                                        ::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                         ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                                                     format:
                                                                                                                                                                         ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                            ' ',
                                                                                                                                                                                                        align:
                                                                                                                                                                                                            ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                        flags:
                                                                                                                                                                                                            0u32,
                                                                                                                                                                                                        precision:
                                                                                                                                                                                                            ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                        width:
                                                                                                                                                                                                            ::std::fmt::rt::v1::Count::Implied,},}]))));
                                               }
                                           })
                                    }
                                    let res = do_lerp(&low, &high, factor);
                                    return res;
                                }
                                (Some(x), None) | (None, Some(x)) => {
                                    return x.out.eval(ctx);
                                }
                                (None, None) => {
                                    {
                                        ::rt::begin_panic("No values to interpolate between found",
                                                          &("rmaps/src/map/style/expr/expressions/interp.rs",
                                                            203u32, 17u32))
                                    }
                                }
                            }
                            {
                                ::rt::begin_panic("not yet implemented",
                                                  &("rmaps/src/map/style/expr/expressions/interp.rs",
                                                    207u32, 9u32))
                            }
                        }
                    }
                    pub struct Step {
                        input: Expr,
                        default: Expr,
                        stops: Vec<Stop>,
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Step {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Step {
                                input: ref __self_0_0,
                                default: ref __self_0_1,
                                stops: ref __self_0_2 } => {
                                    let mut debug_trait_builder =
                                        f.debug_struct("Step");
                                    let _ =
                                        debug_trait_builder.field("input",
                                                                  &&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field("default",
                                                                  &&(*__self_0_1));
                                    let _ =
                                        debug_trait_builder.field("stops",
                                                                  &&(*__self_0_2));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Step {
                        #[inline]
                        fn clone(&self) -> Step {
                            match *self {
                                Step {
                                input: ref __self_0_0,
                                default: ref __self_0_1,
                                stops: ref __self_0_2 } =>
                                Step{input:
                                         ::std::clone::Clone::clone(&(*__self_0_0)),
                                     default:
                                         ::std::clone::Clone::clone(&(*__self_0_1)),
                                     stops:
                                         ::std::clone::Clone::clone(&(*__self_0_2)),},
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Step {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            struct Vis;
                            impl <'de> Visitor<'de> for Vis {
                                type
                                Value
                                =
                                Step;
                                fn expecting(&self,
                                             formatter: &mut fmt::Formatter)
                                 -> fmt::Result {
                                    formatter.write_str("Step expression")
                                }
                                fn visit_seq<A>(self, mut seq: A)
                                 -> StdResult<Self::Value, A::Error> where
                                 A: SeqAccess<'de> {
                                    let input =
                                        TYPE.set(&Type::Number,
                                                 ||
                                                     {
                                                         seq.next_element()
                                                     })?.ok_or_else(||
                                                                        de::Error::invalid_length(1,
                                                                                                  &self))?;
                                    let default =
                                        seq.next_element()?.ok_or_else(||
                                                                           de::Error::invalid_length(2,
                                                                                                     &self))?;
                                    let mut stops = <[_]>::into_vec(box []);
                                    while let (Some(val), Some(out)) =
                                              (seq.next_element()?,
                                               seq.next_element()?) {
                                        stops.push(Stop{val, out,})
                                    };
                                    Ok(Step{input, default, stops,})
                                }
                            }
                            Ok(deserializer.deserialize_seq(Vis)?)
                        }
                    }
                    impl Expression for Step {
                        fn is_zoom(&self) -> bool {
                            self.input.is_zoom() || self.default.is_zoom() ||
                                self.stops.iter().any(|a| a.out.is_zoom())
                        }
                        fn is_feature(&self) -> bool {
                            self.input.is_feature() ||
                                self.default.is_feature() ||
                                self.stops.iter().any(|a| a.out.is_feature())
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            let val = expect_num(self.input.eval(ctx)?)?;
                            let stop =
                                self.stops.iter().find(|a| a.val <= val);
                            return if let Some(stop) = stop {
                                       stop.out.eval(ctx)
                                   } else { self.default.eval(ctx) };
                        }
                    }
                }
                pub mod variables {
                    use super::prelude::*;
                    pub enum Variable {
                        Let(Vec<(String, Expr)>, Expr),
                        Var(String),
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Variable {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&Variable::Let(ref __self_0, ref __self_1),)
                                => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Let");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_1));
                                    debug_trait_builder.finish()
                                }
                                (&Variable::Var(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Var");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Variable {
                        #[inline]
                        fn clone(&self) -> Variable {
                            match (&*self,) {
                                (&Variable::Let(ref __self_0, ref __self_1),)
                                =>
                                Variable::Let(::std::clone::Clone::clone(&(*__self_0)),
                                              ::std::clone::Clone::clone(&(*__self_1))),
                                (&Variable::Var(ref __self_0),) =>
                                Variable::Var(::std::clone::Clone::clone(&(*__self_0))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Variable {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            struct Vis;
                            impl <'de> Visitor<'de> for Vis {
                                type
                                Value
                                =
                                Variable;
                                fn expecting(&self,
                                             formatter: &mut fmt::Formatter)
                                 -> fmt::Result {
                                    formatter.write_str("Variable expression")
                                }
                                fn visit_seq<A>(self, mut seq: A)
                                 -> StdResult<Self::Value, A::Error> where
                                 A: SeqAccess<'de> {
                                    #[serde(untagged)]
                                    enum Wrap { Name(String), Expr(Expr), }
                                    #[allow(non_upper_case_globals,
                                            unused_attributes,
                                            unused_qualifications)]
                                    const _IMPL_DESERIALIZE_FOR_Wrap: () =
                                        {
                                            #[allow(unknown_lints)]
                                            #[allow(rust_2018_idioms)]
                                            extern crate serde as _serde;
                                            #[allow(unused_macros)]
                                            macro_rules! try(( $ __expr : expr
                                                             ) => {
                                                             match $ __expr {
                                                             _serde :: export
                                                             :: Ok ( __val )
                                                             => __val , _serde
                                                             :: export :: Err
                                                             ( __err ) => {
                                                             return _serde ::
                                                             export :: Err (
                                                             __err ) ; } } });
                                            #[automatically_derived]
                                            impl <'de>
                                             _serde::Deserialize<'de> for Wrap
                                             {
                                                fn deserialize<__D>(__deserializer:
                                                                        __D)
                                                 ->
                                                     _serde::export::Result<Self,
                                                                            __D::Error>
                                                 where
                                                 __D: _serde::Deserializer<'de> {
                                                    let __content =
                                                        match <_serde::private::de::Content
                                                                  as
                                                                  _serde::Deserialize>::deserialize(__deserializer)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                    if let _serde::export::Ok(__ok)
                                                           =
                                                           _serde::export::Result::map(<String
                                                                                           as
                                                                                           _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                                                       Wrap::Name)
                                                           {
                                                        return _serde::export::Ok(__ok);
                                                    }
                                                    if let _serde::export::Ok(__ok)
                                                           =
                                                           _serde::export::Result::map(<Expr
                                                                                           as
                                                                                           _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                                                       Wrap::Expr)
                                                           {
                                                        return _serde::export::Ok(__ok);
                                                    }
                                                    _serde::export::Err(_serde::de::Error::custom("data did not match any variant of untagged enum Wrap"))
                                                }
                                            }
                                        };
                                    let mut bindings =
                                        <[_]>::into_vec(box []);
                                    NAME.with(|n|
                                                  {
                                                      match n.deref() {
                                                          "let" => {
                                                              'l:
                                                                  loop  {
                                                                      match (seq.next_element()?,
                                                                             seq.next_element()?)
                                                                          {
                                                                          (Some(Wrap::Name(name)),
                                                                           Some(b))
                                                                          => {
                                                                              bindings.push((n.clone(),
                                                                                             b));
                                                                          }
                                                                          (Some(Wrap::Expr(e)),
                                                                           None)
                                                                          => {
                                                                              break
                                                                                  'l
                                                                                  Ok(Variable::Let(bindings,
                                                                                                   e))
                                                                                  ;
                                                                          }
                                                                          _ =>
                                                                          {
                                                                              {
                                                                                  ::rt::begin_panic("not yet implemented",
                                                                                                    &("rmaps/src/map/style/expr/expressions/variables.rs",
                                                                                                      45u32,
                                                                                                      41u32))
                                                                              }
                                                                          }
                                                                      }
                                                                  }
                                                          }
                                                          "var" => {
                                                              Ok(Variable::Var(seq.next_element()?.ok_or_else(||
                                                                                                                  de::Error::invalid_length(2,
                                                                                                                                            &self))?))
                                                          }
                                                          _ => {
                                                              {
                                                                  ::rt::begin_panic("Not a valid ident",
                                                                                    &("rmaps/src/map/style/expr/expressions/variables.rs",
                                                                                      54u32,
                                                                                      29u32))
                                                              }
                                                          }
                                                      }
                                                  })
                                }
                            }
                            Ok(deserializer.deserialize_seq(Vis)?)
                        }
                    }
                    impl Expression for Variable {
                        fn is_zoom(&self) -> bool {
                            return match self {
                                       Variable::Let(a, b) =>
                                       a.iter().any(|(k, v)| v.is_zoom()) ||
                                           b.is_zoom(),
                                       _ => false,
                                   };
                        }
                        fn is_feature(&self) -> bool {
                            return match self {
                                       Variable::Let(a, b) =>
                                       a.iter().any(|(k, v)| v.is_feature())
                                           || b.is_feature(),
                                       _ => false,
                                   };
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            match self {
                                Variable::Let(bindings, expr) => {
                                    let mut old_bindings = BTreeMap::new();
                                    if let Ok(mut ctx_bindings) =
                                           ctx.bindings.try_borrow_mut() {
                                        for (k, e) in bindings {
                                            if let Some(old) =
                                                   ctx_bindings.insert(k.clone(),
                                                                       e.clone())
                                                   {
                                                old_bindings.insert(k.clone(),
                                                                    old);
                                            }
                                        }
                                    }
                                    let res = expr.eval(ctx)?;
                                    if let Ok(mut ctx_bindings) =
                                           ctx.bindings.try_borrow_mut() {
                                        for (k, e) in old_bindings {
                                            ctx_bindings.insert(k, e);
                                        }
                                    }
                                    return Ok(res);
                                }
                                Variable::Var(name) => {
                                    let e =
                                        {
                                            ctx.bindings.borrow().get(name).map(|x|
                                                                                    x.clone())
                                        };
                                    if let Some(e) = e { return e.eval(ctx); }
                                    {
                                        ::rt::begin_panic("Did not find expression by name",
                                                          &("rmaps/src/map/style/expr/expressions/variables.rs",
                                                            137u32, 17u32))
                                    };
                                }
                            }
                        }
                    }
                }
                pub mod math {
                    use super::prelude::*;
                    use serde::Deserialize;
                    #[rustc_copy_clone_marker]
                    pub enum MathOp {

                        #[serde(rename = "-")]
                        Minus,

                        #[serde(rename = "*")]
                        Times,

                        #[serde(rename = "/")]
                        Div,

                        #[serde(rename = "%")]
                        Remainder,

                        #[serde(rename = "^")]
                        Power,

                        #[serde(rename = "+")]
                        Sum,

                        #[serde(rename = "abs")]
                        Abs,

                        #[serde(rename = "acos")]
                        Acos,

                        #[serde(rename = "asin")]
                        Asin,

                        #[serde(rename = "atan")]
                        Atan,

                        #[serde(rename = "ceil")]
                        Ceil,

                        #[serde(rename = "cos")]
                        Cos,

                        #[serde(rename = "e")]
                        E,

                        #[serde(rename = "floor")]
                        Floor,

                        #[serde(rename = "ln")]
                        Ln,

                        #[serde(rename = "ln2")]
                        Ln2,

                        #[serde(rename = "log10")]
                        Log10,

                        #[serde(rename = "log2")]
                        Log2,

                        #[serde(rename = "max")]
                        Max,

                        #[serde(rename = "min")]
                        Min,

                        #[serde(rename = "pi")]
                        Pi,

                        #[serde(rename = "round")]
                        Round,

                        #[serde(rename = "sin")]
                        Sin,

                        #[serde(rename = "sqrt")]
                        Sqrt,

                        #[serde(rename = "tan")]
                        Tan,
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for MathOp {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&MathOp::Minus,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Minus");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Times,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Times");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Div,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Div");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Remainder,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Remainder");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Power,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Power");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Sum,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Sum");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Abs,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Abs");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Acos,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Acos");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Asin,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Asin");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Atan,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Atan");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Ceil,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Ceil");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Cos,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Cos");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::E,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("E");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Floor,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Floor");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Ln,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Ln");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Ln2,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Ln2");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Log10,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Log10");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Log2,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Log2");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Max,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Max");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Min,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Min");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Pi,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Pi");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Round,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Round");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Sin,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Sin");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Sqrt,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Sqrt");
                                    debug_trait_builder.finish()
                                }
                                (&MathOp::Tan,) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Tan");
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for MathOp {
                        #[inline]
                        fn clone(&self) -> MathOp { { *self } }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::marker::Copy for MathOp { }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::cmp::PartialEq for MathOp {
                        #[inline]
                        fn eq(&self, other: &MathOp) -> bool {
                            {
                                let __self_vi =
                                    unsafe {
                                        ::std::intrinsics::discriminant_value(&*self)
                                    } as isize;
                                let __arg_1_vi =
                                    unsafe {
                                        ::std::intrinsics::discriminant_value(&*other)
                                    } as isize;
                                if true && __self_vi == __arg_1_vi {
                                    match (&*self, &*other) { _ => true, }
                                } else { false }
                            }
                        }
                    }
                    #[allow(non_upper_case_globals,
                            unused_attributes,
                            unused_qualifications)]
                    const _IMPL_DESERIALIZE_FOR_MathOp: () =
                        {
                            #[allow(unknown_lints)]
                            #[allow(rust_2018_idioms)]
                            extern crate serde as _serde;
                            #[allow(unused_macros)]
                            macro_rules! try(( $ __expr : expr ) => {
                                             match $ __expr {
                                             _serde :: export :: Ok ( __val )
                                             => __val , _serde :: export ::
                                             Err ( __err ) => {
                                             return _serde :: export :: Err (
                                             __err ) ; } } });
                            #[automatically_derived]
                            impl <'de> _serde::Deserialize<'de> for MathOp {
                                fn deserialize<__D>(__deserializer: __D)
                                 -> _serde::export::Result<Self, __D::Error>
                                 where __D: _serde::Deserializer<'de> {
                                    #[allow(non_camel_case_types)]
                                    enum __Field {
                                        __field0,
                                        __field1,
                                        __field2,
                                        __field3,
                                        __field4,
                                        __field5,
                                        __field6,
                                        __field7,
                                        __field8,
                                        __field9,
                                        __field10,
                                        __field11,
                                        __field12,
                                        __field13,
                                        __field14,
                                        __field15,
                                        __field16,
                                        __field17,
                                        __field18,
                                        __field19,
                                        __field20,
                                        __field21,
                                        __field22,
                                        __field23,
                                        __field24,
                                    }
                                    struct __FieldVisitor;
                                    impl <'de> _serde::de::Visitor<'de> for
                                     __FieldVisitor {
                                        type
                                        Value
                                        =
                                        __Field;
                                        fn expecting(&self,
                                                     __formatter:
                                                         &mut _serde::export::Formatter)
                                         -> _serde::export::fmt::Result {
                                            _serde::export::Formatter::write_str(__formatter,
                                                                                 "variant identifier")
                                        }
                                        fn visit_u64<__E>(self, __value: u64)
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __E> where
                                         __E: _serde::de::Error {
                                            match __value {
                                                0u64 =>
                                                _serde::export::Ok(__Field::__field0),
                                                1u64 =>
                                                _serde::export::Ok(__Field::__field1),
                                                2u64 =>
                                                _serde::export::Ok(__Field::__field2),
                                                3u64 =>
                                                _serde::export::Ok(__Field::__field3),
                                                4u64 =>
                                                _serde::export::Ok(__Field::__field4),
                                                5u64 =>
                                                _serde::export::Ok(__Field::__field5),
                                                6u64 =>
                                                _serde::export::Ok(__Field::__field6),
                                                7u64 =>
                                                _serde::export::Ok(__Field::__field7),
                                                8u64 =>
                                                _serde::export::Ok(__Field::__field8),
                                                9u64 =>
                                                _serde::export::Ok(__Field::__field9),
                                                10u64 =>
                                                _serde::export::Ok(__Field::__field10),
                                                11u64 =>
                                                _serde::export::Ok(__Field::__field11),
                                                12u64 =>
                                                _serde::export::Ok(__Field::__field12),
                                                13u64 =>
                                                _serde::export::Ok(__Field::__field13),
                                                14u64 =>
                                                _serde::export::Ok(__Field::__field14),
                                                15u64 =>
                                                _serde::export::Ok(__Field::__field15),
                                                16u64 =>
                                                _serde::export::Ok(__Field::__field16),
                                                17u64 =>
                                                _serde::export::Ok(__Field::__field17),
                                                18u64 =>
                                                _serde::export::Ok(__Field::__field18),
                                                19u64 =>
                                                _serde::export::Ok(__Field::__field19),
                                                20u64 =>
                                                _serde::export::Ok(__Field::__field20),
                                                21u64 =>
                                                _serde::export::Ok(__Field::__field21),
                                                22u64 =>
                                                _serde::export::Ok(__Field::__field22),
                                                23u64 =>
                                                _serde::export::Ok(__Field::__field23),
                                                24u64 =>
                                                _serde::export::Ok(__Field::__field24),
                                                _ =>
                                                _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                     &"variant index 0 <= i < 25")),
                                            }
                                        }
                                        fn visit_str<__E>(self, __value: &str)
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __E> where
                                         __E: _serde::de::Error {
                                            match __value {
                                                "-" =>
                                                _serde::export::Ok(__Field::__field0),
                                                "*" =>
                                                _serde::export::Ok(__Field::__field1),
                                                "/" =>
                                                _serde::export::Ok(__Field::__field2),
                                                "%" =>
                                                _serde::export::Ok(__Field::__field3),
                                                "^" =>
                                                _serde::export::Ok(__Field::__field4),
                                                "+" =>
                                                _serde::export::Ok(__Field::__field5),
                                                "abs" =>
                                                _serde::export::Ok(__Field::__field6),
                                                "acos" =>
                                                _serde::export::Ok(__Field::__field7),
                                                "asin" =>
                                                _serde::export::Ok(__Field::__field8),
                                                "atan" =>
                                                _serde::export::Ok(__Field::__field9),
                                                "ceil" =>
                                                _serde::export::Ok(__Field::__field10),
                                                "cos" =>
                                                _serde::export::Ok(__Field::__field11),
                                                "e" =>
                                                _serde::export::Ok(__Field::__field12),
                                                "floor" =>
                                                _serde::export::Ok(__Field::__field13),
                                                "ln" =>
                                                _serde::export::Ok(__Field::__field14),
                                                "ln2" =>
                                                _serde::export::Ok(__Field::__field15),
                                                "log10" =>
                                                _serde::export::Ok(__Field::__field16),
                                                "log2" =>
                                                _serde::export::Ok(__Field::__field17),
                                                "max" =>
                                                _serde::export::Ok(__Field::__field18),
                                                "min" =>
                                                _serde::export::Ok(__Field::__field19),
                                                "pi" =>
                                                _serde::export::Ok(__Field::__field20),
                                                "round" =>
                                                _serde::export::Ok(__Field::__field21),
                                                "sin" =>
                                                _serde::export::Ok(__Field::__field22),
                                                "sqrt" =>
                                                _serde::export::Ok(__Field::__field23),
                                                "tan" =>
                                                _serde::export::Ok(__Field::__field24),
                                                _ => {
                                                    _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                           VARIANTS))
                                                }
                                            }
                                        }
                                        fn visit_bytes<__E>(self,
                                                            __value: &[u8])
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __E> where
                                         __E: _serde::de::Error {
                                            match __value {
                                                b"-" =>
                                                _serde::export::Ok(__Field::__field0),
                                                b"*" =>
                                                _serde::export::Ok(__Field::__field1),
                                                b"/" =>
                                                _serde::export::Ok(__Field::__field2),
                                                b"%" =>
                                                _serde::export::Ok(__Field::__field3),
                                                b"^" =>
                                                _serde::export::Ok(__Field::__field4),
                                                b"+" =>
                                                _serde::export::Ok(__Field::__field5),
                                                b"abs" =>
                                                _serde::export::Ok(__Field::__field6),
                                                b"acos" =>
                                                _serde::export::Ok(__Field::__field7),
                                                b"asin" =>
                                                _serde::export::Ok(__Field::__field8),
                                                b"atan" =>
                                                _serde::export::Ok(__Field::__field9),
                                                b"ceil" =>
                                                _serde::export::Ok(__Field::__field10),
                                                b"cos" =>
                                                _serde::export::Ok(__Field::__field11),
                                                b"e" =>
                                                _serde::export::Ok(__Field::__field12),
                                                b"floor" =>
                                                _serde::export::Ok(__Field::__field13),
                                                b"ln" =>
                                                _serde::export::Ok(__Field::__field14),
                                                b"ln2" =>
                                                _serde::export::Ok(__Field::__field15),
                                                b"log10" =>
                                                _serde::export::Ok(__Field::__field16),
                                                b"log2" =>
                                                _serde::export::Ok(__Field::__field17),
                                                b"max" =>
                                                _serde::export::Ok(__Field::__field18),
                                                b"min" =>
                                                _serde::export::Ok(__Field::__field19),
                                                b"pi" =>
                                                _serde::export::Ok(__Field::__field20),
                                                b"round" =>
                                                _serde::export::Ok(__Field::__field21),
                                                b"sin" =>
                                                _serde::export::Ok(__Field::__field22),
                                                b"sqrt" =>
                                                _serde::export::Ok(__Field::__field23),
                                                b"tan" =>
                                                _serde::export::Ok(__Field::__field24),
                                                _ => {
                                                    let __value =
                                                        &_serde::export::from_utf8_lossy(__value);
                                                    _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                           VARIANTS))
                                                }
                                            }
                                        }
                                    }
                                    impl <'de> _serde::Deserialize<'de> for
                                     __Field {
                                        #[inline]
                                        fn deserialize<__D>(__deserializer:
                                                                __D)
                                         ->
                                             _serde::export::Result<Self,
                                                                    __D::Error>
                                         where
                                         __D: _serde::Deserializer<'de> {
                                            _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                         __FieldVisitor)
                                        }
                                    }
                                    struct __Visitor<'de> {
                                        marker: _serde::export::PhantomData<MathOp>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl <'de> _serde::de::Visitor<'de> for
                                     __Visitor<'de> {
                                        type
                                        Value
                                        =
                                        MathOp;
                                        fn expecting(&self,
                                                     __formatter:
                                                         &mut _serde::export::Formatter)
                                         -> _serde::export::fmt::Result {
                                            _serde::export::Formatter::write_str(__formatter,
                                                                                 "enum MathOp")
                                        }
                                        fn visit_enum<__A>(self, __data: __A)
                                         ->
                                             _serde::export::Result<Self::Value,
                                                                    __A::Error>
                                         where
                                         __A: _serde::de::EnumAccess<'de> {
                                            match match _serde::de::EnumAccess::variant(__data)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                (__Field::__field0, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Minus)
                                                }
                                                (__Field::__field1, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Times)
                                                }
                                                (__Field::__field2, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Div)
                                                }
                                                (__Field::__field3, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Remainder)
                                                }
                                                (__Field::__field4, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Power)
                                                }
                                                (__Field::__field5, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Sum)
                                                }
                                                (__Field::__field6, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Abs)
                                                }
                                                (__Field::__field7, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Acos)
                                                }
                                                (__Field::__field8, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Asin)
                                                }
                                                (__Field::__field9, __variant)
                                                => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Atan)
                                                }
                                                (__Field::__field10,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Ceil)
                                                }
                                                (__Field::__field11,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Cos)
                                                }
                                                (__Field::__field12,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::E)
                                                }
                                                (__Field::__field13,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Floor)
                                                }
                                                (__Field::__field14,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Ln)
                                                }
                                                (__Field::__field15,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Ln2)
                                                }
                                                (__Field::__field16,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Log10)
                                                }
                                                (__Field::__field17,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Log2)
                                                }
                                                (__Field::__field18,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Max)
                                                }
                                                (__Field::__field19,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Min)
                                                }
                                                (__Field::__field20,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Pi)
                                                }
                                                (__Field::__field21,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Round)
                                                }
                                                (__Field::__field22,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Sin)
                                                }
                                                (__Field::__field23,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Sqrt)
                                                }
                                                (__Field::__field24,
                                                 __variant) => {
                                                    match _serde::de::VariantAccess::unit_variant(__variant)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                    _serde::export::Ok(MathOp::Tan)
                                                }
                                            }
                                        }
                                    }
                                    const VARIANTS: &'static [&'static str] =
                                        &["-", "*", "/", "%", "^", "+", "abs",
                                          "acos", "asin", "atan", "ceil",
                                          "cos", "e", "floor", "ln", "ln2",
                                          "log10", "log2", "max", "min", "pi",
                                          "round", "sin", "sqrt", "tan"];
                                    _serde::Deserializer::deserialize_enum(__deserializer,
                                                                           "MathOp",
                                                                           VARIANTS,
                                                                           __Visitor{marker:
                                                                                         _serde::export::PhantomData::<MathOp>,
                                                                                     lifetime:
                                                                                         _serde::export::PhantomData,})
                                }
                            }
                        };
                    impl FromStr for MathOp {
                        type
                        Err
                        =
                        serde::de::value::Error;
                        fn from_str(s: &str) -> StdResult<Self, Self::Err> {
                            use serde::de::IntoDeserializer;
                            let deser: serde::de::value::StrDeserializer<_> =
                                s.into_deserializer();
                            Ok(Self::deserialize(deser)?)
                        }
                    }
                    impl Parse for MathOp {
                        fn parse(value: json::Value, expected: Type)
                         -> ParseResult<Self> {
                            Ok(json::from_value(value).map_err(|e|
                                                                   ParseError::Other(e.into()))?)
                        }
                    }
                    pub struct Math(MathOp, Vec<Expr>);
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Math {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Math(ref __self_0_0, ref __self_0_1) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Math");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0_1));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Math {
                        #[inline]
                        fn clone(&self) -> Math {
                            match *self {
                                Math(ref __self_0_0, ref __self_0_1) =>
                                Math(::std::clone::Clone::clone(&(*__self_0_0)),
                                     ::std::clone::Clone::clone(&(*__self_0_1))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Math {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            NAME.with(|n|
                                          {
                                              let t =
                                                  FromStr::from_str(&n).map_err(|_|
                                                                                    D::Error::custom("invalid type specifier for math operation"))?;
                                              let exprs =
                                                  Deserialize::deserialize(deserializer)?;
                                              Ok(Math(t, exprs))
                                          })
                        }
                    }
                    impl Math {
                        fn min_args(&self) -> usize {
                            return match self.0 {
                                       MathOp::Minus => 1,
                                       MathOp::Times => 2,
                                       MathOp::Div => 2,
                                       MathOp::Remainder => 2,
                                       MathOp::Power => 2,
                                       MathOp::Sum => 2,
                                       MathOp::Abs => 1,
                                       MathOp::Acos => 1,
                                       MathOp::Asin => 1,
                                       MathOp::Atan => 1,
                                       MathOp::Ceil => 1,
                                       MathOp::Cos => 1,
                                       MathOp::E => 0,
                                       MathOp::Floor => 1,
                                       MathOp::Ln => 1,
                                       MathOp::Ln2 => 0,
                                       MathOp::Log10 => 1,
                                       MathOp::Log2 => 1,
                                       MathOp::Max => 1,
                                       MathOp::Min => 1,
                                       MathOp::Pi => 0,
                                       MathOp::Round => 1,
                                       MathOp::Sin => 1,
                                       MathOp::Sqrt => 1,
                                       MathOp::Tan => 1,
                                   };
                        }
                    }
                    fn eval_num(e: &Expr, ctx: &EvaluationContext)
                     -> StdResult<f64, EvalError> {
                        let e = e.eval(ctx)?;
                        return Ok(e.as_number().unwrap());
                    }
                    impl Expression for Math {
                        fn is_zoom(&self) -> bool {
                            return self.1.iter().any(|e| e.is_zoom());
                        }
                        fn is_feature(&self) -> bool {
                            return self.1.iter().any(|e| e.is_feature());
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            let _ = expect_len(&self.1, self.min_args())?;
                            return Ok(match (&self.0, &self.1[..]) {
                                          (MathOp::Minus, [e]) => {
                                              (-eval_num(e, ctx)?)
                                          }
                                          (MathOp::Minus, [a, b]) => {
                                              (eval_num(a, ctx)? -
                                                   eval_num(b, ctx)?)
                                          }
                                          (MathOp::Times, [a, rest..]) => {
                                              let mut r = eval_num(a, ctx)?;
                                              for b in rest {
                                                  r *= eval_num(b, ctx)?;
                                              }
                                              r
                                          }
                                          (MathOp::Div, [a, b]) => {
                                              eval_num(a, ctx)? /
                                                  eval_num(b, ctx)?
                                          }
                                          (MathOp::Remainder, [a, b]) => {
                                              (eval_num(a, ctx)? as i64 %
                                                   eval_num(b, ctx)? as i64)
                                                  as f64
                                          }
                                          (MathOp::Power, [a, b]) => {
                                              f64::powf(eval_num(a, ctx)?,
                                                        eval_num(b, ctx)?)
                                          }
                                          (MathOp::Sum, [a, rest..]) => {
                                              let mut r = eval_num(a, ctx)?;
                                              for b in rest {
                                                  r += eval_num(b, ctx)?;
                                              }
                                              r
                                          }
                                          (MathOp::Abs, [a]) => {
                                              f64::abs(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Acos, [a]) => {
                                              f64::acos(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Asin, [a]) => {
                                              f64::asin(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Atan, [a]) => {
                                              f64::atan(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Ceil, [a]) => {
                                              f64::ceil(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Cos, [a]) => {
                                              f64::cos(eval_num(a, ctx)?)
                                          }
                                          (MathOp::E, []) => {
                                              ::std::f64::consts::E
                                          }
                                          (MathOp::Floor, [a]) => {
                                              f64::floor(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Ln, [a]) => {
                                              f64::log(eval_num(a, ctx)?,
                                                       ::std::f64::consts::E)
                                          }
                                          (MathOp::Ln2, []) => {
                                              f64::log(2.,
                                                       ::std::f64::consts::E)
                                          }
                                          (MathOp::Log10, [a]) => {
                                              f64::log10(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Log2, [a]) => {
                                              f64::log2(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Max, [a, rest..]) => {
                                              let mut r = eval_num(a, ctx)?;
                                              for b in rest {
                                                  r =
                                                      f64::max(r,
                                                               eval_num(b,
                                                                        ctx)?);
                                              }
                                              r
                                          }
                                          (MathOp::Min, [a, rest..]) => {
                                              let mut r = eval_num(a, ctx)?;
                                              for b in rest {
                                                  r =
                                                      f64::min(r,
                                                               eval_num(b,
                                                                        ctx)?);
                                              }
                                              r
                                          }
                                          (MathOp::Pi, []) => {
                                              ::std::f64::consts::PI
                                          }
                                          (MathOp::Round, [a]) => {
                                              f64::round(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Sin, [a]) => {
                                              f64::sin(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Sqrt, [a]) => {
                                              f64::sqrt(eval_num(a, ctx)?)
                                          }
                                          (MathOp::Tan, [a]) => {
                                              f64::tan(eval_num(a, ctx)?)
                                          }
                                          _ => {
                                              return Err(EvalError::custom(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["Mismatched math operation and arguments : ",
                                                                                                                                   " used on "],
                                                                                                                                 &match (&self.0,
                                                                                                                                         &self.1)
                                                                                                                                      {
                                                                                                                                      (arg0,
                                                                                                                                       arg1)
                                                                                                                                      =>
                                                                                                                                      [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                   ::std::fmt::Debug::fmt),
                                                                                                                                       ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                                                   ::std::fmt::Debug::fmt)],
                                                                                                                                  },
                                                                                                                                 &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                    ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                format:
                                                                                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                       ' ',
                                                                                                                                                                                                   align:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                   flags:
                                                                                                                                                                                                       0u32,
                                                                                                                                                                                                   precision:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                   width:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                                                   ::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                    ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                                                format:
                                                                                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                       ' ',
                                                                                                                                                                                                   align:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                   flags:
                                                                                                                                                                                                       0u32,
                                                                                                                                                                                                   precision:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                   width:
                                                                                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},}]))));
                                          }
                                      }.into());
                        }
                    }
                }
                pub mod string {
                    use super::prelude::*;
                    pub enum Str {
                        Concat(Vec<Expr>),
                        Downcase(Expr),
                        Upcase(Expr),
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Str {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&Str::Concat(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Concat");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Str::Downcase(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Downcase");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                                (&Str::Upcase(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Upcase");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Str {
                        #[inline]
                        fn clone(&self) -> Str {
                            match (&*self,) {
                                (&Str::Concat(ref __self_0),) =>
                                Str::Concat(::std::clone::Clone::clone(&(*__self_0))),
                                (&Str::Downcase(ref __self_0),) =>
                                Str::Downcase(::std::clone::Clone::clone(&(*__self_0))),
                                (&Str::Upcase(ref __self_0),) =>
                                Str::Upcase(::std::clone::Clone::clone(&(*__self_0))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for Str {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            struct Vis;
                            impl <'de> Visitor<'de> for Vis {
                                type
                                Value
                                =
                                Str;
                                fn expecting(&self,
                                             formatter: &mut fmt::Formatter)
                                 -> fmt::Result {
                                    formatter.write_str("String expr")
                                }
                                fn visit_seq<A>(self, mut seq: A)
                                 -> StdResult<Self::Value, A::Error> where
                                 A: SeqAccess<'de> {
                                    NAME.with(|n|
                                                  {
                                                      match n.deref() {
                                                          "concat" => {
                                                              let d =
                                                                  Deserialize::deserialize(de::value::SeqAccessDeserializer::new(seq))?;
                                                              Ok(Str::Concat(d))
                                                          }
                                                          "downcase" => {
                                                              let s =
                                                                  seq.next_element()?.ok_or_else(||
                                                                                                     de::Error::invalid_length(1,
                                                                                                                               &self))?;
                                                              Ok(Str::Downcase(s))
                                                          }
                                                          "upcase" => {
                                                              let s =
                                                                  seq.next_element()?.ok_or_else(||
                                                                                                     de::Error::invalid_length(1,
                                                                                                                               &self))?;
                                                              Ok(Str::Upcase(s))
                                                          }
                                                          _ => {
                                                              ::rt::begin_panic("not yet implemented",
                                                                                &("rmaps/src/map/style/expr/expressions/string.rs",
                                                                                  39u32,
                                                                                  30u32))
                                                          }
                                                      }
                                                  })
                                }
                            }
                            Ok(deserializer.deserialize_seq(Vis)?)
                        }
                    }
                    impl Expression for Str {
                        fn is_zoom(&self) -> bool {
                            return match self {
                                       Str::Concat(v) =>
                                       v.iter().any(|e| e.is_zoom()),
                                       Str::Downcase(e) => e.is_zoom(),
                                       Str::Upcase(e) => e.is_zoom(),
                                   };
                        }
                        fn is_feature(&self) -> bool {
                            return match self {
                                       Str::Concat(v) =>
                                       v.iter().any(|e| e.is_feature()),
                                       Str::Downcase(e) => e.is_feature(),
                                       Str::Upcase(e) => e.is_feature(),
                                   };
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            return match self {
                                       Str::Concat(exprs) => {
                                           let mut res = String::new();
                                           for e in exprs {
                                               let v =
                                                   expect_type(Type::String,
                                                               e.eval(ctx)?)?;
                                               if let Value::String(s) = v {
                                                   res.push_str(&s);
                                               }
                                           }
                                           Ok(Value::String(res))
                                       }
                                       Str::Downcase(e) => {
                                           let mut v =
                                               expect_type(Type::String,
                                                           e.eval(ctx)?)?;
                                           if let Value::String(s) = v {
                                               return Ok(Value::String(s.to_lowercase()));
                                           };
                                           {
                                               ::rt::begin_panic("Unexpected expression value ",
                                                                 &("rmaps/src/map/style/expr/expressions/string.rs",
                                                                   96u32,
                                                                   17u32))
                                           }
                                       }
                                       Str::Upcase(e) => {
                                           let mut v =
                                               expect_type(Type::String,
                                                           e.eval(ctx)?)?;
                                           if let Value::String(s) = v {
                                               return Ok(Value::String(s.to_uppercase()));
                                           };
                                           {
                                               ::rt::begin_panic("Unexpected expression value ",
                                                                 &("rmaps/src/map/style/expr/expressions/string.rs",
                                                                   103u32,
                                                                   17u32))
                                           }
                                       }
                                   };
                        }
                    }
                }
                pub mod color {
                    use super::prelude::*;
                    pub enum ColorExpr {
                        Rgb(Expr, Expr, Expr),
                        Rgba(Expr, Expr, Expr, Expr),
                        ToRgba(Expr),
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for ColorExpr {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match (&*self,) {
                                (&ColorExpr::Rgb(ref __self_0, ref __self_1,
                                                 ref __self_2),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Rgb");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_1));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_2));
                                    debug_trait_builder.finish()
                                }
                                (&ColorExpr::Rgba(ref __self_0, ref __self_1,
                                                  ref __self_2,
                                                  ref __self_3),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("Rgba");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_1));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_2));
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_3));
                                    debug_trait_builder.finish()
                                }
                                (&ColorExpr::ToRgba(ref __self_0),) => {
                                    let mut debug_trait_builder =
                                        f.debug_tuple("ToRgba");
                                    let _ =
                                        debug_trait_builder.field(&&(*__self_0));
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for ColorExpr {
                        #[inline]
                        fn clone(&self) -> ColorExpr {
                            match (&*self,) {
                                (&ColorExpr::Rgb(ref __self_0, ref __self_1,
                                                 ref __self_2),) =>
                                ColorExpr::Rgb(::std::clone::Clone::clone(&(*__self_0)),
                                               ::std::clone::Clone::clone(&(*__self_1)),
                                               ::std::clone::Clone::clone(&(*__self_2))),
                                (&ColorExpr::Rgba(ref __self_0, ref __self_1,
                                                  ref __self_2,
                                                  ref __self_3),) =>
                                ColorExpr::Rgba(::std::clone::Clone::clone(&(*__self_0)),
                                                ::std::clone::Clone::clone(&(*__self_1)),
                                                ::std::clone::Clone::clone(&(*__self_2)),
                                                ::std::clone::Clone::clone(&(*__self_3))),
                                (&ColorExpr::ToRgba(ref __self_0),) =>
                                ColorExpr::ToRgba(::std::clone::Clone::clone(&(*__self_0))),
                            }
                        }
                    }
                    impl <'de> Deserialize<'de> for ColorExpr {
                        fn deserialize<D>(deserializer: D)
                         -> StdResult<Self, D::Error> where
                         D: Deserializer<'de> {
                            struct Vis;
                            impl <'de> Visitor<'de> for Vis {
                                type
                                Value
                                =
                                ColorExpr;
                                fn expecting(&self,
                                             formatter: &mut fmt::Formatter)
                                 -> fmt::Result {
                                    formatter.write_str("color expression")
                                }
                                fn visit_seq<A>(self, mut seq: A)
                                 -> StdResult<Self::Value, A::Error> where
                                 A: SeqAccess<'de> {
                                    NAME.with(|n|
                                                  {
                                                      match n.deref() {
                                                          "rgb" => {
                                                              let r =
                                                                  TYPE.set(&Type::Number,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(1,
                                                                                                                            &self))?;
                                                              let g =
                                                                  TYPE.set(&Type::Number,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(2,
                                                                                                                            &self))?;
                                                              let b =
                                                                  TYPE.set(&Type::Number,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(3,
                                                                                                                            &self))?;
                                                              Ok(ColorExpr::Rgb(r,
                                                                                g,
                                                                                b))
                                                          }
                                                          "rgba" => {
                                                              let r =
                                                                  TYPE.set(&Type::Number,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(1,
                                                                                                                            &self))?;
                                                              let g =
                                                                  TYPE.set(&Type::Number,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(2,
                                                                                                                            &self))?;
                                                              let b =
                                                                  TYPE.set(&Type::Number,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(3,
                                                                                                                            &self))?;
                                                              let a =
                                                                  TYPE.set(&Type::Number,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(3,
                                                                                                                            &self))?;
                                                              Ok(ColorExpr::Rgba(r,
                                                                                 g,
                                                                                 b,
                                                                                 a))
                                                          }
                                                          "to-rgba" => {
                                                              let c =
                                                                  TYPE.set(&Type::Color,
                                                                           ||
                                                                               {
                                                                                   seq.next_element()
                                                                               })?.ok_or_else(||
                                                                                                  de::Error::invalid_length(1,
                                                                                                                            &self))?;
                                                              Ok(ColorExpr::ToRgba(c))
                                                          }
                                                          _ => {
                                                              {
                                                                  ::rt::begin_panic("Unknown color expr",
                                                                                    &("rmaps/src/map/style/expr/expressions/color.rs",
                                                                                      61u32,
                                                                                      29u32))
                                                              }
                                                          }
                                                      }
                                                  })
                                }
                            }
                            Ok(deserializer.deserialize_seq(Vis)?)
                        }
                    }
                    impl Expression for ColorExpr {
                        fn is_zoom(&self) -> bool {
                            match self {
                                ColorExpr::Rgb(a, b, c) =>
                                a.is_zoom() || b.is_zoom() || c.is_zoom(),
                                ColorExpr::Rgba(a, b, c, d) =>
                                a.is_zoom() || b.is_zoom() || c.is_zoom() ||
                                    d.is_zoom(),
                                ColorExpr::ToRgba(x) => x.is_zoom(),
                            }
                        }
                        fn is_feature(&self) -> bool {
                            match self {
                                ColorExpr::Rgb(a, b, c) =>
                                a.is_feature() || b.is_feature() ||
                                    c.is_feature(),
                                ColorExpr::Rgba(a, b, c, d) =>
                                a.is_feature() || b.is_feature() ||
                                    c.is_feature() || d.is_feature(),
                                ColorExpr::ToRgba(x) => x.is_feature(),
                            }
                        }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            match self {
                                ColorExpr::Rgb(a, b, c) => {
                                    let ea = expect_num(a.eval(ctx)?)?;
                                    let eb = expect_num(b.eval(ctx)?)?;
                                    let ec = expect_num(c.eval(ctx)?)?;
                                    return Ok(Value::Color(Color::new(ea as
                                                                          f32,
                                                                      eb as
                                                                          f32,
                                                                      ec as
                                                                          f32,
                                                                      1.)));
                                }
                                ColorExpr::Rgba(a, b, c, d) => {
                                    let ea = expect_num(a.eval(ctx)?)?;
                                    let eb = expect_num(b.eval(ctx)?)?;
                                    let ec = expect_num(c.eval(ctx)?)?;
                                    let ed = expect_num(d.eval(ctx)?)?;
                                    return Ok(Value::Color(Color::new(ea as
                                                                          f32,
                                                                      eb as
                                                                          f32,
                                                                      ec as
                                                                          f32,
                                                                      ed as
                                                                          f32)));
                                }
                                ColorExpr::ToRgba(x) => {
                                    let ea = expect_color(x.eval(ctx)?)?;
                                    return Ok(Value::List(<[_]>::into_vec(box
                                                                              [ea.r().into(),
                                                                               ea.g().into(),
                                                                               ea.b().into(),
                                                                               ea.a().into()])));
                                }
                            }
                        }
                    }
                }
                pub mod zoom {
                    use super::prelude::*;
                    pub struct Zoom {
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::fmt::Debug for Zoom {
                        fn fmt(&self, f: &mut ::std::fmt::Formatter)
                         -> ::std::fmt::Result {
                            match *self {
                                Zoom {  } => {
                                    let mut debug_trait_builder =
                                        f.debug_struct("Zoom");
                                    debug_trait_builder.finish()
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::clone::Clone for Zoom {
                        #[inline]
                        fn clone(&self) -> Zoom {
                            match *self { Zoom {  } => Zoom{}, }
                        }
                    }
                    #[automatically_derived]
                    #[allow(unused_qualifications)]
                    impl ::std::cmp::PartialEq for Zoom {
                        #[inline]
                        fn eq(&self, other: &Zoom) -> bool {
                            match *other {
                                Zoom {  } =>
                                match *self { Zoom {  } => true, },
                            }
                        }
                    }
                    impl Expression for Zoom {
                        fn is_zoom(&self) -> bool { true }
                        fn is_feature(&self) -> bool { false }
                        fn eval(&self, ctx: &EvaluationContext)
                         -> ExprResult {
                            Ok(Value::Num(ctx.zoom.unwrap() as _))
                        }
                    }
                }
            }
            pub mod util {
                use ::prelude::*;
                use super::{Type, eval::*, val::*};
                pub fn expect_type(t: Type, v: Value) -> ExprResult {
                    return if v.get_type() == t {
                               Ok(v)
                           } else {
                               Err(EvalError::InvalidType{expected: t,
                                                          got: v.get_type(),})
                           };
                }
                pub fn expect_num(v: Value) -> StdResult<f64, EvalError> {
                    return if let Value::Num(n) = v {
                               Ok(n)
                           } else {
                               Err(EvalError::InvalidType{expected:
                                                              Type::Number,
                                                          got: v.get_type(),})
                           };
                }
                pub fn expect_bool(v: Value) -> StdResult<bool, EvalError> {
                    return if let Value::Bool(n) = v {
                               Ok(n)
                           } else {
                               Err(EvalError::InvalidType{expected:
                                                              Type::Boolean,
                                                          got: v.get_type(),})
                           };
                }
                pub fn expect_color(v: Value) -> StdResult<Color, EvalError> {
                    return if let Value::Color(n) = v {
                               Ok(n)
                           } else {
                               Err(EvalError::InvalidType{expected:
                                                              Type::Color,
                                                          got: v.get_type(),})
                           };
                }
                pub fn expect_len<T>(a: &[T], count: usize)
                 -> StdResult<(), EvalError> {
                    if a.len() >= count {
                        return Ok(());
                    } else {
                        return Err(EvalError::InvalidNumberOfArguments{got:
                                                                           a.len(),
                                                                       expected:
                                                                           count,});
                    }
                }
                use std::fmt;
                use std::marker::PhantomData;
                use serde::de::{self, Deserialize, Deserializer, SeqAccess,
                                Visitor};
                pub struct Prefix<T, R>(T, R);
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl <T: ::std::fmt::Debug, R: ::std::fmt::Debug>
                 ::std::fmt::Debug for Prefix<T, R> {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            Prefix(ref __self_0_0, ref __self_0_1) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Prefix");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0_1));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl <T: ::std::clone::Clone, R: ::std::clone::Clone>
                 ::std::clone::Clone for Prefix<T, R> {
                    #[inline]
                    fn clone(&self) -> Prefix<T, R> {
                        match *self {
                            Prefix(ref __self_0_0, ref __self_0_1) =>
                            Prefix(::std::clone::Clone::clone(&(*__self_0_0)),
                                   ::std::clone::Clone::clone(&(*__self_0_1))),
                        }
                    }
                }
                impl <'de, T, R> Deserialize<'de> for Prefix<T, R> where
                 T: Deserialize<'de>, R: Deserialize<'de> {
                    fn deserialize<D>(deserializer: D)
                     -> StdResult<Self, D::Error> where D: Deserializer<'de> {
                        struct PrefixVisitor<T, R>(PhantomData<(T, R)>);
                        impl <'de, T, R> Visitor<'de> for PrefixVisitor<T, R>
                         where T: Deserialize<'de>, R: Deserialize<'de> {
                            type
                            Value
                            =
                            Prefix<T, R>;
                            fn expecting(&self,
                                         formatter: &mut fmt::Formatter)
                             -> fmt::Result {
                                formatter.write_str("sequence")
                            }
                            fn visit_seq<A>(self, mut seq: A)
                             -> StdResult<Self::Value, A::Error> where
                             A: SeqAccess<'de> {
                                let t =
                                    seq.next_element()?.ok_or_else(||
                                                                       de::Error::invalid_length(0,
                                                                                                 &self))?;
                                let r =
                                    R::deserialize(de::value::SeqAccessDeserializer::new(seq))?;
                                Ok(Prefix(t, r))
                            }
                        }
                        deserializer.deserialize_seq(PrefixVisitor(PhantomData))
                    }
                }
            }
            pub mod val {
                use ::prelude::*;
                use super::*;
                pub type Array = Vec<Value>;
                pub type Object = BTreeMap<String, Value>;
                impl From<::common::geometry::Value> for Value {
                    fn from(v: ::common::geometry::Value) -> Self {
                        match v {
                            ::common::geometry::Value::Null => Value::Null,
                            ::common::geometry::Value::Bool(b) =>
                            Value::Bool(b),
                            ::common::geometry::Value::Int(a) =>
                            Value::Num(a as _),
                            ::common::geometry::Value::UInt(a) =>
                            Value::Num(a as _),
                            ::common::geometry::Value::Float(a) =>
                            Value::Num(a as _),
                            ::common::geometry::Value::String(s) =>
                            Value::String(s),
                            ::common::geometry::Value::List(a) =>
                            Value::List(a.into_iter().map(|v|
                                                              v.into()).collect()),
                            ::common::geometry::Value::Object(o) =>
                            Value::Object(o.into_iter().map(|(k, v)|
                                                                (k,
                                                                 v.into())).collect()),
                        }
                    }
                }
                pub enum Value {
                    Null,
                    Bool(bool),
                    Num(f64),
                    String(String),
                    Color(Color),
                    List(Array),
                    Object(Object),
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for Value {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match (&*self,) {
                            (&Value::Null,) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Null");
                                debug_trait_builder.finish()
                            }
                            (&Value::Bool(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Bool");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                            (&Value::Num(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Num");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                            (&Value::String(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("String");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                            (&Value::Color(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Color");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                            (&Value::List(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("List");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                            (&Value::Object(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Object");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for Value {
                    #[inline]
                    fn clone(&self) -> Value {
                        match (&*self,) {
                            (&Value::Null,) => Value::Null,
                            (&Value::Bool(ref __self_0),) =>
                            Value::Bool(::std::clone::Clone::clone(&(*__self_0))),
                            (&Value::Num(ref __self_0),) =>
                            Value::Num(::std::clone::Clone::clone(&(*__self_0))),
                            (&Value::String(ref __self_0),) =>
                            Value::String(::std::clone::Clone::clone(&(*__self_0))),
                            (&Value::Color(ref __self_0),) =>
                            Value::Color(::std::clone::Clone::clone(&(*__self_0))),
                            (&Value::List(ref __self_0),) =>
                            Value::List(::std::clone::Clone::clone(&(*__self_0))),
                            (&Value::Object(ref __self_0),) =>
                            Value::Object(::std::clone::Clone::clone(&(*__self_0))),
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::cmp::PartialEq for Value {
                    #[inline]
                    fn eq(&self, other: &Value) -> bool {
                        {
                            let __self_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*self)
                                } as isize;
                            let __arg_1_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*other)
                                } as isize;
                            if true && __self_vi == __arg_1_vi {
                                match (&*self, &*other) {
                                    (&Value::Bool(ref __self_0),
                                     &Value::Bool(ref __arg_1_0)) =>
                                    (*__self_0) == (*__arg_1_0),
                                    (&Value::Num(ref __self_0),
                                     &Value::Num(ref __arg_1_0)) =>
                                    (*__self_0) == (*__arg_1_0),
                                    (&Value::String(ref __self_0),
                                     &Value::String(ref __arg_1_0)) =>
                                    (*__self_0) == (*__arg_1_0),
                                    (&Value::Color(ref __self_0),
                                     &Value::Color(ref __arg_1_0)) =>
                                    (*__self_0) == (*__arg_1_0),
                                    (&Value::List(ref __self_0),
                                     &Value::List(ref __arg_1_0)) =>
                                    (*__self_0) == (*__arg_1_0),
                                    (&Value::Object(ref __self_0),
                                     &Value::Object(ref __arg_1_0)) =>
                                    (*__self_0) == (*__arg_1_0),
                                    _ => true,
                                }
                            } else { false }
                        }
                    }
                    #[inline]
                    fn ne(&self, other: &Value) -> bool {
                        {
                            let __self_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*self)
                                } as isize;
                            let __arg_1_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*other)
                                } as isize;
                            if true && __self_vi == __arg_1_vi {
                                match (&*self, &*other) {
                                    (&Value::Bool(ref __self_0),
                                     &Value::Bool(ref __arg_1_0)) =>
                                    (*__self_0) != (*__arg_1_0),
                                    (&Value::Num(ref __self_0),
                                     &Value::Num(ref __arg_1_0)) =>
                                    (*__self_0) != (*__arg_1_0),
                                    (&Value::String(ref __self_0),
                                     &Value::String(ref __arg_1_0)) =>
                                    (*__self_0) != (*__arg_1_0),
                                    (&Value::Color(ref __self_0),
                                     &Value::Color(ref __arg_1_0)) =>
                                    (*__self_0) != (*__arg_1_0),
                                    (&Value::List(ref __self_0),
                                     &Value::List(ref __arg_1_0)) =>
                                    (*__self_0) != (*__arg_1_0),
                                    (&Value::Object(ref __self_0),
                                     &Value::Object(ref __arg_1_0)) =>
                                    (*__self_0) != (*__arg_1_0),
                                    _ => false,
                                }
                            } else { true }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::cmp::PartialOrd for Value {
                    #[inline]
                    fn partial_cmp(&self, other: &Value)
                     -> ::std::option::Option<::std::cmp::Ordering> {
                        {
                            let __self_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*self)
                                } as isize;
                            let __arg_1_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*other)
                                } as isize;
                            if true && __self_vi == __arg_1_vi {
                                match (&*self, &*other) {
                                    (&Value::Bool(ref __self_0),
                                     &Value::Bool(ref __arg_1_0)) =>
                                    match ::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                              &(*__arg_1_0))
                                        {
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                        =>
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                                        cmp => cmp,
                                    },
                                    (&Value::Num(ref __self_0),
                                     &Value::Num(ref __arg_1_0)) =>
                                    match ::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                              &(*__arg_1_0))
                                        {
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                        =>
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                                        cmp => cmp,
                                    },
                                    (&Value::String(ref __self_0),
                                     &Value::String(ref __arg_1_0)) =>
                                    match ::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                              &(*__arg_1_0))
                                        {
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                        =>
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                                        cmp => cmp,
                                    },
                                    (&Value::Color(ref __self_0),
                                     &Value::Color(ref __arg_1_0)) =>
                                    match ::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                              &(*__arg_1_0))
                                        {
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                        =>
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                                        cmp => cmp,
                                    },
                                    (&Value::List(ref __self_0),
                                     &Value::List(ref __arg_1_0)) =>
                                    match ::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                              &(*__arg_1_0))
                                        {
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                        =>
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                                        cmp => cmp,
                                    },
                                    (&Value::Object(ref __self_0),
                                     &Value::Object(ref __arg_1_0)) =>
                                    match ::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                              &(*__arg_1_0))
                                        {
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal)
                                        =>
                                        ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                                        cmp => cmp,
                                    },
                                    _ =>
                                    ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                                }
                            } else { __self_vi.partial_cmp(&__arg_1_vi) }
                        }
                    }
                    #[inline]
                    fn lt(&self, other: &Value) -> bool {
                        {
                            let __self_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*self)
                                } as isize;
                            let __arg_1_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*other)
                                } as isize;
                            if true && __self_vi == __arg_1_vi {
                                match (&*self, &*other) {
                                    (&Value::Bool(ref __self_0),
                                     &Value::Bool(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        == ::std::cmp::Ordering::Less,
                                    (&Value::Num(ref __self_0),
                                     &Value::Num(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        == ::std::cmp::Ordering::Less,
                                    (&Value::String(ref __self_0),
                                     &Value::String(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        == ::std::cmp::Ordering::Less,
                                    (&Value::Color(ref __self_0),
                                     &Value::Color(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        == ::std::cmp::Ordering::Less,
                                    (&Value::List(ref __self_0),
                                     &Value::List(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        == ::std::cmp::Ordering::Less,
                                    (&Value::Object(ref __self_0),
                                     &Value::Object(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        == ::std::cmp::Ordering::Less,
                                    _ => false,
                                }
                            } else { __self_vi.lt(&__arg_1_vi) }
                        }
                    }
                    #[inline]
                    fn le(&self, other: &Value) -> bool {
                        {
                            let __self_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*self)
                                } as isize;
                            let __arg_1_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*other)
                                } as isize;
                            if true && __self_vi == __arg_1_vi {
                                match (&*self, &*other) {
                                    (&Value::Bool(ref __self_0),
                                     &Value::Bool(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        != ::std::cmp::Ordering::Greater,
                                    (&Value::Num(ref __self_0),
                                     &Value::Num(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        != ::std::cmp::Ordering::Greater,
                                    (&Value::String(ref __self_0),
                                     &Value::String(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        != ::std::cmp::Ordering::Greater,
                                    (&Value::Color(ref __self_0),
                                     &Value::Color(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        != ::std::cmp::Ordering::Greater,
                                    (&Value::List(ref __self_0),
                                     &Value::List(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        != ::std::cmp::Ordering::Greater,
                                    (&Value::Object(ref __self_0),
                                     &Value::Object(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Greater)
                                        != ::std::cmp::Ordering::Greater,
                                    _ => true,
                                }
                            } else { __self_vi.le(&__arg_1_vi) }
                        }
                    }
                    #[inline]
                    fn gt(&self, other: &Value) -> bool {
                        {
                            let __self_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*self)
                                } as isize;
                            let __arg_1_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*other)
                                } as isize;
                            if true && __self_vi == __arg_1_vi {
                                match (&*self, &*other) {
                                    (&Value::Bool(ref __self_0),
                                     &Value::Bool(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        == ::std::cmp::Ordering::Greater,
                                    (&Value::Num(ref __self_0),
                                     &Value::Num(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        == ::std::cmp::Ordering::Greater,
                                    (&Value::String(ref __self_0),
                                     &Value::String(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        == ::std::cmp::Ordering::Greater,
                                    (&Value::Color(ref __self_0),
                                     &Value::Color(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        == ::std::cmp::Ordering::Greater,
                                    (&Value::List(ref __self_0),
                                     &Value::List(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        == ::std::cmp::Ordering::Greater,
                                    (&Value::Object(ref __self_0),
                                     &Value::Object(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        == ::std::cmp::Ordering::Greater,
                                    _ => false,
                                }
                            } else { __self_vi.gt(&__arg_1_vi) }
                        }
                    }
                    #[inline]
                    fn ge(&self, other: &Value) -> bool {
                        {
                            let __self_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*self)
                                } as isize;
                            let __arg_1_vi =
                                unsafe {
                                    ::std::intrinsics::discriminant_value(&*other)
                                } as isize;
                            if true && __self_vi == __arg_1_vi {
                                match (&*self, &*other) {
                                    (&Value::Bool(ref __self_0),
                                     &Value::Bool(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        != ::std::cmp::Ordering::Less,
                                    (&Value::Num(ref __self_0),
                                     &Value::Num(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        != ::std::cmp::Ordering::Less,
                                    (&Value::String(ref __self_0),
                                     &Value::String(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        != ::std::cmp::Ordering::Less,
                                    (&Value::Color(ref __self_0),
                                     &Value::Color(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        != ::std::cmp::Ordering::Less,
                                    (&Value::List(ref __self_0),
                                     &Value::List(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        != ::std::cmp::Ordering::Less,
                                    (&Value::Object(ref __self_0),
                                     &Value::Object(ref __arg_1_0)) =>
                                    ::std::option::Option::unwrap_or(::std::cmp::PartialOrd::partial_cmp(&(*__self_0),
                                                                                                         &(*__arg_1_0)),
                                                                     ::std::cmp::Ordering::Less)
                                        != ::std::cmp::Ordering::Less,
                                    _ => true,
                                }
                            } else { __self_vi.ge(&__arg_1_vi) }
                        }
                    }
                }
                pub struct ValueVisitor;
                impl <'de> serde::de::Visitor<'de> for ValueVisitor {
                    type
                    Value
                    =
                    Value;
                    fn expecting(&self, formatter: &mut fmt::Formatter)
                     -> fmt::Result {
                        formatter.write_str("Value")
                    }
                    fn visit_bool<E>(self, v: bool)
                     -> StdResult<Self::Value, E> where E: de::Error {
                        Ok(Value::Bool(v))
                    }
                    fn visit_i64<E>(self, v: i64) -> StdResult<Self::Value, E>
                     where E: de::Error {
                        Ok(Value::Num(v as _))
                    }
                    fn visit_u64<E>(self, v: u64) -> StdResult<Self::Value, E>
                     where E: de::Error {
                        Ok(Value::Num(v as _))
                    }
                    fn visit_f64<E>(self, v: f64) -> StdResult<Self::Value, E>
                     where E: de::Error {
                        Ok(Value::Num(v as _))
                    }
                    fn visit_str<E>(self, v: &str)
                     -> StdResult<Self::Value, E> where E: de::Error {
                        if TYPE.is_set() {
                            TYPE.with(|t|
                                          {
                                              match t {
                                                  Type::Color => {
                                                      let c =
                                                          Color::from_str(v).map_err(|_|
                                                                                         de::Error::invalid_type(de::Unexpected::Str(v),
                                                                                                                 &"Color"));
                                                      Ok(Value::Color(c?))
                                                  }
                                                  _ => {
                                                      Ok(Value::String(v.into()))
                                                  }
                                              }
                                          })
                        } else { Ok(Value::String(v.into())) }
                    }
                    fn visit_bytes<E>(self, v: &[u8])
                     -> StdResult<Self::Value, E> where E: de::Error {
                        {
                            ::rt::begin_panic("not yet implemented",
                                              &("rmaps/src/map/style/expr/val.rs",
                                                83u32, 9u32))
                        }
                    }
                    fn visit_none<E>(self) -> StdResult<Self::Value, E> where
                     E: de::Error {
                        Ok(Value::Null)
                    }
                    fn visit_unit<E>(self) -> StdResult<Self::Value, E> where
                     E: de::Error {
                        Ok(Value::Null)
                    }
                    fn visit_seq<A>(self, seq: A)
                     -> StdResult<Self::Value, A::Error> where
                     A: de::SeqAccess<'de> {
                        Ok(Value::List(Vec::<Value>::deserialize(de::value::SeqAccessDeserializer::new(seq))?))
                    }
                    fn visit_map<A>(self, map: A)
                     -> StdResult<Self::Value, A::Error> where
                     A: de::MapAccess<'de> {
                        Ok(Value::Object(BTreeMap::<String,
                                                    Value>::deserialize(de::value::MapAccessDeserializer::new(map))?))
                    }
                }
                impl <'de> Deserialize<'de> for Value {
                    fn deserialize<D>(deserializer: D)
                     -> StdResult<Self, D::Error> where D: Deserializer<'de> {
                        deserializer.deserialize_any(ValueVisitor)
                    }
                }
                impl Value {
                    pub fn as_bool(&self) -> Option<bool> {
                        if let Value::Bool(b) = self {
                            Some(*b)
                        } else { None }
                    }
                    pub fn as_number(&self) -> Option<f64> {
                        if let Value::Num(n) = self { Some(*n) } else { None }
                    }
                    pub fn as_str(&self) -> Option<&str> {
                        if let Value::String(s) = self {
                            Some(s)
                        } else { None }
                    }
                    pub fn as_array(&self) -> Option<&Array> {
                        if let Value::List(a) = self { Some(a) } else { None }
                    }
                    pub fn as_object(&self) -> Option<&Object> {
                        if let Value::Object(o) = self {
                            Some(o)
                        } else { None }
                    }
                }
                use std::convert::{TryInto, TryFrom};
                macro_rules! impl_converts(( $ arm : tt , $ ( $ typ : ty ) * )
                                           => {
                                           $ (
                                           impl From < $ typ > for Value {
                                           fn from ( t : $ typ ) -> Self {
                                           Value :: $ arm ( t as _ ) } } impl
                                           TryFrom < Value > for $ typ {
                                           type Error = Type ; fn try_from (
                                           value : Value ) -> StdResult < Self
                                           , Type > {
                                           match value {
                                           Value :: $ arm ( v ) => Ok ( v as _
                                           ) , a @ _ => Err (
                                           a . get_type (  ) ) , } } } impl
                                           From < Option < $ typ >> for Value
                                           {
                                           fn from ( t : Option < $ typ > ) ->
                                           Self {
                                           match t {
                                           Some ( t ) => Value :: $ arm (
                                           t as _ ) , None => Value :: Null ,
                                           } } } impl TryFrom < Value > for
                                           Option < $ typ > {
                                           type Error = Type ; fn try_from (
                                           value : Value ) -> StdResult < Self
                                           , Type > {
                                           match value {
                                           Value :: Null => Ok ( None ) ,
                                           Value :: $ arm ( v ) => Ok (
                                           Some ( v as _ ) ) , a @ _ => Err (
                                           a . get_type (  ) ) , } } } ) * }
                                           ;);
                impl From<bool> for Value {
                    fn from(t: bool) -> Self { Value::Bool(t as _) }
                }
                impl TryFrom<Value> for bool {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Bool(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<bool>> for Value {
                    fn from(t: Option<bool>) -> Self {
                        match t {
                            Some(t) => Value::Bool(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<bool> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Bool(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<String> for Value {
                    fn from(t: String) -> Self { Value::String(t as _) }
                }
                impl TryFrom<Value> for String {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::String(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<String>> for Value {
                    fn from(t: Option<String>) -> Self {
                        match t {
                            Some(t) => Value::String(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<String> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::String(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<f64> for Value {
                    fn from(t: f64) -> Self { Value::Num(t as _) }
                }
                impl TryFrom<Value> for f64 {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Num(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<f64>> for Value {
                    fn from(t: Option<f64>) -> Self {
                        match t {
                            Some(t) => Value::Num(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<f64> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Num(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<f32> for Value {
                    fn from(t: f32) -> Self { Value::Num(t as _) }
                }
                impl TryFrom<Value> for f32 {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Num(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<f32>> for Value {
                    fn from(t: Option<f32>) -> Self {
                        match t {
                            Some(t) => Value::Num(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<f32> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Num(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<i32> for Value {
                    fn from(t: i32) -> Self { Value::Num(t as _) }
                }
                impl TryFrom<Value> for i32 {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Num(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<i32>> for Value {
                    fn from(t: Option<i32>) -> Self {
                        match t {
                            Some(t) => Value::Num(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<i32> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Num(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<i64> for Value {
                    fn from(t: i64) -> Self { Value::Num(t as _) }
                }
                impl TryFrom<Value> for i64 {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Num(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<i64>> for Value {
                    fn from(t: Option<i64>) -> Self {
                        match t {
                            Some(t) => Value::Num(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<i64> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Num(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<u32> for Value {
                    fn from(t: u32) -> Self { Value::Num(t as _) }
                }
                impl TryFrom<Value> for u32 {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Num(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<u32>> for Value {
                    fn from(t: Option<u32>) -> Self {
                        match t {
                            Some(t) => Value::Num(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<u32> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Num(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<u64> for Value {
                    fn from(t: u64) -> Self { Value::Num(t as _) }
                }
                impl TryFrom<Value> for u64 {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Num(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<u64>> for Value {
                    fn from(t: Option<u64>) -> Self {
                        match t {
                            Some(t) => Value::Num(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<u64> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Num(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Color> for Value {
                    fn from(t: Color) -> Self { Value::Color(t as _) }
                }
                impl TryFrom<Value> for Color {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Color(v) => Ok(v as _),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl From<Option<Color>> for Value {
                    fn from(t: Option<Color>) -> Self {
                        match t {
                            Some(t) => Value::Color(t as _),
                            None => Value::Null,
                        }
                    }
                }
                impl TryFrom<Value> for Option<Color> {
                    type
                    Error
                    =
                    Type;
                    fn try_from(value: Value) -> StdResult<Self, Type> {
                        match value {
                            Value::Null => Ok(None),
                            Value::Color(v) => Ok(Some(v as _)),
                            a@_ => Err(a.get_type()),
                        }
                    }
                }
                impl Value {
                    fn typ(&self) -> Type {
                        return match self {
                                   Value::Null => Type::Null,
                                   Value::Bool(_) => Type::Boolean,
                                   Value::Num(_) => Type::Number,
                                   Value::String(_) => Type::String,
                                   Value::Color(_) => Type::Color,
                                   Value::List(_) => Type::Array,
                                   Value::Object(_) => Type::Object,
                               };
                    }
                    pub fn get_type(&self) -> Type { return self.typ(); }
                }
                impl Parse for Value {
                    fn parse(value: json::Value, expected: Type)
                     -> ParseResult<Self> {
                        match expected {
                            Type::Color =>
                            Ok(Value::Color(json::from_value(value.clone())?)),
                            Type::String =>
                            Ok(Value::String(json::from_value(value.clone())?)),
                            _ => { Ok(json::from_value(value.clone())?) }
                        }
                    }
                }
                impl Expression for Value {
                    fn is_zoom(&self) -> bool { false }
                    fn is_feature(&self) -> bool { false }
                    fn eval(&self, ctx: &EvaluationContext) -> ExprResult {
                        return Ok(self.clone());
                    }
                }
            }
            pub mod eval {
                use prelude::*;
                use super::*;
                use std::cell::RefCell;
                pub struct EvaluationContext<'a> {
                    pub zoom: Option<f32>,
                    pub feature_data: Option<&'a ::mvt::Feature>,
                    pub bindings: RefCell<BTreeMap<String, Expr>>,
                }
                impl <'a> EvaluationContext<'a> {
                    fn get(&self, name: &str) -> Option<&Value> {
                        {
                            ::rt::begin_panic("None",
                                              &("rmaps/src/map/style/expr/eval.rs",
                                                14u32, 9u32))
                        }
                    }
                }
                pub enum EvalError {
                    InvalidType {
                        expected: Type,
                        got: Type,
                    },
                    InvalidNumberOfArguments {
                        expected: usize,
                        got: usize,
                    },
                    Custom(String),
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for EvalError {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match (&*self,) {
                            (&EvalError::InvalidType {
                             expected: ref __self_0, got: ref __self_1 },) =>
                            {
                                let mut debug_trait_builder =
                                    f.debug_struct("InvalidType");
                                let _ =
                                    debug_trait_builder.field("expected",
                                                              &&(*__self_0));
                                let _ =
                                    debug_trait_builder.field("got",
                                                              &&(*__self_1));
                                debug_trait_builder.finish()
                            }
                            (&EvalError::InvalidNumberOfArguments {
                             expected: ref __self_0, got: ref __self_1 },) =>
                            {
                                let mut debug_trait_builder =
                                    f.debug_struct("InvalidNumberOfArguments");
                                let _ =
                                    debug_trait_builder.field("expected",
                                                              &&(*__self_0));
                                let _ =
                                    debug_trait_builder.field("got",
                                                              &&(*__self_1));
                                debug_trait_builder.finish()
                            }
                            (&EvalError::Custom(ref __self_0),) => {
                                let mut debug_trait_builder =
                                    f.debug_tuple("Custom");
                                let _ =
                                    debug_trait_builder.field(&&(*__self_0));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                impl EvalError {
                    pub fn invalid_type(expected: Type, got: Type)
                     -> EvalError {
                        EvalError::InvalidType{expected, got,}
                    }
                    pub fn invalid_arguments(expected: usize, got: usize)
                     -> EvalError {
                        EvalError::InvalidNumberOfArguments{expected, got,}
                    }
                    pub fn custom(m: impl Into<String>) -> EvalError {
                        EvalError::Custom(m.into())
                    }
                }
                pub type ExprResult = StdResult<Value, EvalError>;
            }
            pub use self::{parse::*, util::*, val::*, eval::*,
                           expressions::*};
            #[structural_match]
            #[rustc_copy_clone_marker]
            pub enum Type {

                #[serde(rename = "null")]
                Null,

                #[serde(rename = "color")]
                Color,

                #[serde(rename = "object")]
                Object,

                #[serde(rename = "array")]
                Array,

                #[serde(rename = "string")]
                String,

                #[serde(rename = "number")]
                Number,

                #[serde(rename = "boolean")]
                Boolean,

                #[serde(rename = "_")]
                Any,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for Type {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&Type::Null,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Null");
                            debug_trait_builder.finish()
                        }
                        (&Type::Color,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Color");
                            debug_trait_builder.finish()
                        }
                        (&Type::Object,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Object");
                            debug_trait_builder.finish()
                        }
                        (&Type::Array,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Array");
                            debug_trait_builder.finish()
                        }
                        (&Type::String,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("String");
                            debug_trait_builder.finish()
                        }
                        (&Type::Number,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Number");
                            debug_trait_builder.finish()
                        }
                        (&Type::Boolean,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Boolean");
                            debug_trait_builder.finish()
                        }
                        (&Type::Any,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Any");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[allow(non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications)]
            const _IMPL_DESERIALIZE_FOR_Type: () =
                {
                    #[allow(unknown_lints)]
                    #[allow(rust_2018_idioms)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try(( $ __expr : expr ) => {
                                     match $ __expr {
                                     _serde :: export :: Ok ( __val ) => __val
                                     , _serde :: export :: Err ( __err ) => {
                                     return _serde :: export :: Err ( __err )
                                     ; } } });
                    #[automatically_derived]
                    impl <'de> _serde::Deserialize<'de> for Type {
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            #[allow(non_camel_case_types)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __field4,
                                __field5,
                                __field6,
                                __field7,
                            }
                            struct __FieldVisitor;
                            impl <'de> _serde::de::Visitor<'de> for
                             __FieldVisitor {
                                type
                                Value
                                =
                                __Field;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "variant identifier")
                                }
                                fn visit_u64<__E>(self, __value: u64)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        0u64 =>
                                        _serde::export::Ok(__Field::__field0),
                                        1u64 =>
                                        _serde::export::Ok(__Field::__field1),
                                        2u64 =>
                                        _serde::export::Ok(__Field::__field2),
                                        3u64 =>
                                        _serde::export::Ok(__Field::__field3),
                                        4u64 =>
                                        _serde::export::Ok(__Field::__field4),
                                        5u64 =>
                                        _serde::export::Ok(__Field::__field5),
                                        6u64 =>
                                        _serde::export::Ok(__Field::__field6),
                                        7u64 =>
                                        _serde::export::Ok(__Field::__field7),
                                        _ =>
                                        _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                             &"variant index 0 <= i < 8")),
                                    }
                                }
                                fn visit_str<__E>(self, __value: &str)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        "null" =>
                                        _serde::export::Ok(__Field::__field0),
                                        "color" =>
                                        _serde::export::Ok(__Field::__field1),
                                        "object" =>
                                        _serde::export::Ok(__Field::__field2),
                                        "array" =>
                                        _serde::export::Ok(__Field::__field3),
                                        "string" =>
                                        _serde::export::Ok(__Field::__field4),
                                        "number" =>
                                        _serde::export::Ok(__Field::__field5),
                                        "boolean" =>
                                        _serde::export::Ok(__Field::__field6),
                                        "_" =>
                                        _serde::export::Ok(__Field::__field7),
                                        _ => {
                                            _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                   VARIANTS))
                                        }
                                    }
                                }
                                fn visit_bytes<__E>(self, __value: &[u8])
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        b"null" =>
                                        _serde::export::Ok(__Field::__field0),
                                        b"color" =>
                                        _serde::export::Ok(__Field::__field1),
                                        b"object" =>
                                        _serde::export::Ok(__Field::__field2),
                                        b"array" =>
                                        _serde::export::Ok(__Field::__field3),
                                        b"string" =>
                                        _serde::export::Ok(__Field::__field4),
                                        b"number" =>
                                        _serde::export::Ok(__Field::__field5),
                                        b"boolean" =>
                                        _serde::export::Ok(__Field::__field6),
                                        b"_" =>
                                        _serde::export::Ok(__Field::__field7),
                                        _ => {
                                            let __value =
                                                &_serde::export::from_utf8_lossy(__value);
                                            _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                   VARIANTS))
                                        }
                                    }
                                }
                            }
                            impl <'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(__deserializer: __D)
                                 -> _serde::export::Result<Self, __D::Error>
                                 where __D: _serde::Deserializer<'de> {
                                    _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                 __FieldVisitor)
                                }
                            }
                            struct __Visitor<'de> {
                                marker: _serde::export::PhantomData<Type>,
                                lifetime: _serde::export::PhantomData<&'de ()>,
                            }
                            impl <'de> _serde::de::Visitor<'de> for
                             __Visitor<'de> {
                                type
                                Value
                                =
                                Type;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "enum Type")
                                }
                                fn visit_enum<__A>(self, __data: __A)
                                 ->
                                     _serde::export::Result<Self::Value,
                                                            __A::Error> where
                                 __A: _serde::de::EnumAccess<'de> {
                                    match match _serde::de::EnumAccess::variant(__data)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        (__Field::__field0, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::Null)
                                        }
                                        (__Field::__field1, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::Color)
                                        }
                                        (__Field::__field2, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::Object)
                                        }
                                        (__Field::__field3, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::Array)
                                        }
                                        (__Field::__field4, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::String)
                                        }
                                        (__Field::__field5, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::Number)
                                        }
                                        (__Field::__field6, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::Boolean)
                                        }
                                        (__Field::__field7, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Type::Any)
                                        }
                                    }
                                }
                            }
                            const VARIANTS: &'static [&'static str] =
                                &["null", "color", "object", "array",
                                  "string", "number", "boolean", "_"];
                            _serde::Deserializer::deserialize_enum(__deserializer,
                                                                   "Type",
                                                                   VARIANTS,
                                                                   __Visitor{marker:
                                                                                 _serde::export::PhantomData::<Type>,
                                                                             lifetime:
                                                                                 _serde::export::PhantomData,})
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Type {
                #[inline]
                fn clone(&self) -> Type { { *self } }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::marker::Copy for Type { }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::hash::Hash for Type {
                fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H)
                 -> () {
                    match (&*self,) {
                        _ => {
                            ::std::hash::Hash::hash(&unsafe {
                                                         ::std::intrinsics::discriminant_value(self)
                                                     }, state)
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::cmp::PartialOrd for Type {
                #[inline]
                fn partial_cmp(&self, other: &Type)
                 -> ::std::option::Option<::std::cmp::Ordering> {
                    {
                        let __self_vi =
                            unsafe {
                                ::std::intrinsics::discriminant_value(&*self)
                            } as isize;
                        let __arg_1_vi =
                            unsafe {
                                ::std::intrinsics::discriminant_value(&*other)
                            } as isize;
                        if true && __self_vi == __arg_1_vi {
                            match (&*self, &*other) {
                                _ =>
                                ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                            }
                        } else { __self_vi.partial_cmp(&__arg_1_vi) }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::cmp::PartialEq for Type {
                #[inline]
                fn eq(&self, other: &Type) -> bool {
                    {
                        let __self_vi =
                            unsafe {
                                ::std::intrinsics::discriminant_value(&*self)
                            } as isize;
                        let __arg_1_vi =
                            unsafe {
                                ::std::intrinsics::discriminant_value(&*other)
                            } as isize;
                        if true && __self_vi == __arg_1_vi {
                            match (&*self, &*other) { _ => true, }
                        } else { false }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::cmp::Ord for Type {
                #[inline]
                fn cmp(&self, other: &Type) -> ::std::cmp::Ordering {
                    {
                        let __self_vi =
                            unsafe {
                                ::std::intrinsics::discriminant_value(&*self)
                            } as isize;
                        let __arg_1_vi =
                            unsafe {
                                ::std::intrinsics::discriminant_value(&*other)
                            } as isize;
                        if true && __self_vi == __arg_1_vi {
                            match (&*self, &*other) {
                                _ => ::std::cmp::Ordering::Equal,
                            }
                        } else { __self_vi.cmp(&__arg_1_vi) }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::cmp::Eq for Type {
                #[inline]
                #[doc(hidden)]
                fn assert_receiver_is_total_eq(&self) -> () { { } }
            }
            impl FromStr for Type {
                type
                Err
                =
                serde::de::value::Error;
                fn from_str(s: &str) -> StdResult<Self, Self::Err> {
                    use serde::de::IntoDeserializer;
                    let deser: serde::de::value::StrDeserializer<_> =
                        s.into_deserializer();
                    Ok(Self::deserialize(deser)?)
                }
            }
            pub struct Expr(Box<dyn Expression>);
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for Expr {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        Expr(ref __self_0_0) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Expr");
                            let _ =
                                debug_trait_builder.field(&&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Expr {
                #[inline]
                fn clone(&self) -> Expr {
                    match *self {
                        Expr(ref __self_0_0) =>
                        Expr(::std::clone::Clone::clone(&(*__self_0_0))),
                    }
                }
            }
            use serde::de::{self, Visitor, SeqAccess, MapAccess};
            use ::std::fmt;
            impl <'de> Deserialize<'de> for Expr {
                fn deserialize<D>(deserializer: D)
                 -> StdResult<Self, D::Error> where D: Deserializer<'de> {
                    struct ExprVisitor;
                    impl <'de> Visitor<'de> for ExprVisitor {
                        type
                        Value
                        =
                        Box<dyn Expression>;
                        fn expecting(&self, formatter: &mut fmt::Formatter)
                         -> fmt::Result {
                            formatter.write_str("Expression or literal value")
                        }
                        fn visit_bool<E>(self, v: bool)
                         -> StdResult<Self::Value, E> where E: de::Error {
                            Ok(Box::new(ValueVisitor.visit_bool(v)?))
                        }
                        fn visit_i64<E>(self, v: i64)
                         -> StdResult<Self::Value, E> where E: de::Error {
                            Ok(Box::new(ValueVisitor.visit_i64(v)?))
                        }
                        fn visit_u64<E>(self, v: u64)
                         -> StdResult<Self::Value, E> where E: de::Error {
                            Ok(Box::new(ValueVisitor.visit_u64(v)?))
                        }
                        fn visit_f64<E>(self, v: f64)
                         -> StdResult<Self::Value, E> where E: de::Error {
                            Ok(Box::new(ValueVisitor.visit_f64(v)?))
                        }
                        fn visit_str<E>(self, v: &str)
                         -> StdResult<Self::Value, E> where E: de::Error {
                            Ok(Box::new(ValueVisitor.visit_str(v)?))
                        }
                        fn visit_none<E>(self) -> StdResult<Self::Value, E>
                         where E: de::Error {
                            Ok(Box::new(ValueVisitor.visit_none()?))
                        }
                        fn visit_seq<A>(self, mut seq: A)
                         -> StdResult<Self::Value, A::Error> where
                         A: SeqAccess<'de> {
                            let name: String =
                                seq.next_element()?.ok_or_else(||
                                                                   de::Error::invalid_length(0,
                                                                                             &self))?;
                            fn deser<'a, A: SeqAccess<'a>, T, F>(seq: A, f: F)
                             -> StdResult<Box<dyn Expression>, A::Error> where
                             T: Expression,
                             F: FnOnce(de::value::SeqAccessDeserializer<A>) ->
                             StdResult<T, A::Error> {
                                Ok(Box::new(f(de::value::SeqAccessDeserializer::new(seq))?))
                            }
                            let expected_type =
                                if TYPE.is_set() {
                                    TYPE.with(|t| t.clone())
                                } else { Type::Any };
                            TYPE.set(&expected_type,
                                     ||
                                         {
                                             NAME.set(&name,
                                                      ||
                                                          {
                                                              match name.deref()
                                                                  {
                                                                  "array" |
                                                                  "boolean" |
                                                                  "collator" |
                                                                  "literal" |
                                                                  "number" |
                                                                  "object" |
                                                                  "string" |
                                                                  "to-color" |
                                                                  "to-number"
                                                                  |
                                                                  "to-string"
                                                                  | "typeof"
                                                                  =>
                                                                  deser(seq,
                                                                        |a|
                                                                            types::Types::deserialize(a)),
                                                                  "feature-state"
                                                                  |
                                                                  "geometry-type"
                                                                  | "id" |
                                                                  "properties"
                                                                  =>
                                                                  deser(seq,
                                                                        |a|
                                                                            feature::FeatureExpr::deserialize(a)),
                                                                  "at" | "get"
                                                                  | "has" |
                                                                  "length" =>
                                                                  deser(seq,
                                                                        |a|
                                                                            lookup::Lookup::deserialize(a)),
                                                                  "zoom" =>
                                                                  Ok(Box::new(zoom::Zoom{})
                                                                         as
                                                                         Box<dyn Expression>),
                                                                  "interpolate"
                                                                  =>
                                                                  deser(seq,
                                                                        |a|
                                                                            interp::Interpolate::deserialize(a)),
                                                                  "step" =>
                                                                  deser(seq,
                                                                        |a|
                                                                            interp::Step::deserialize(a)),
                                                                  "!" | "!=" |
                                                                  "<" | "<=" |
                                                                  "==" | ">" |
                                                                  ">=" | "all"
                                                                  | "any" |
                                                                  "case" |
                                                                  "coalesce" |
                                                                  "match" =>
                                                                  deser(seq,
                                                                        |a|
                                                                            decision::Decision::deserialize(a)),
                                                                  "let" |
                                                                  "var" =>
                                                                  deser(seq,
                                                                        |a|
                                                                            variables::Variable::deserialize(a)),
                                                                  "concat" |
                                                                  "downcase" |
                                                                  "is-supported-script"
                                                                  |
                                                                  "resolved-locale"
                                                                  | "upcase"
                                                                  =>
                                                                  deser(seq,
                                                                        |a|
                                                                            string::Str::deserialize(a)),
                                                                  "rgb" |
                                                                  "rgba" |
                                                                  "to-rgba" =>
                                                                  deser(seq,
                                                                        |a|
                                                                            color::ColorExpr::deserialize(a)),
                                                                  "-" | "*" |
                                                                  "/" | "%" |
                                                                  "^" | "+" |
                                                                  "abs" |
                                                                  "acos" |
                                                                  "asin" |
                                                                  "atan" |
                                                                  "ceil" |
                                                                  "cos" | "e"
                                                                  | "floor " |
                                                                  "ln" | "ln2"
                                                                  | "log10" |
                                                                  "log2" |
                                                                  "max" |
                                                                  "min" | "pi"
                                                                  | "round" |
                                                                  "sin" |
                                                                  "sqrt" |
                                                                  "tan" =>
                                                                  deser(seq,
                                                                        |a|
                                                                            math::Math::deserialize(a)),
                                                                  _ => {
                                                                      return Err(A::Error::custom(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["",
                                                                                                                                                          " is not a valid expression identifier"],
                                                                                                                                                        &match (&name,)
                                                                                                                                                             {
                                                                                                                                                             (arg0,)
                                                                                                                                                             =>
                                                                                                                                                             [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                          ::std::fmt::Display::fmt)],
                                                                                                                                                         },
                                                                                                                                                        &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                                           ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                                       format:
                                                                                                                                                                                           ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                                              ' ',
                                                                                                                                                                                                                          align:
                                                                                                                                                                                                                              ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                                          flags:
                                                                                                                                                                                                                              0u32,
                                                                                                                                                                                                                          precision:
                                                                                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                                          width:
                                                                                                                                                                                                                              ::std::fmt::rt::v1::Count::Implied,},}]))));
                                                                  }
                                                              }
                                                          })
                                         })
                        }
                    }
                    Ok(Expr(deserializer.deserialize_any(ExprVisitor)?))
                }
            }
            impl Expression for Expr {
                fn is_zoom(&self) -> bool {
                    let x = self.0.deref().is_zoom();
                    x
                }
                fn is_feature(&self) -> bool {
                    let f = self.0.deref().is_feature();
                    f
                }
                fn eval(&self, ctx: &EvaluationContext) -> eval::ExprResult {
                    self.0.deref().eval(ctx)
                }
            }
            pub trait Expression: Debug + 'static + ExprClone {
                fn is_zoom(&self)
                -> bool;
                fn is_feature(&self)
                -> bool;
                fn eval(&self, ctx: &eval::EvaluationContext)
                -> ExprResult;
            }
            pub trait ExprClone {
                fn clone_box(&self)
                -> Box<dyn Expression>;
            }
            impl <T> ExprClone for T where T: 'static + Expression + Clone {
                fn clone_box(&self) -> Box<dyn Expression> {
                    Box::new(self.clone())
                }
            }
            impl Clone for Box<dyn Expression> {
                fn clone(&self) -> Box<dyn Expression> { self.clone_box() }
            }
            pub trait DescribeType: Debug + 'static {
                fn describe_type()
                -> Type;
            }
            macro_rules! describe_type(( $ ( $ type : ty ) * , $ t : expr ) =>
                                       {
                                       describe_type ! {
                                       @ inner $ ( $ type ) * , $ t }
                                       describe_type ! {
                                       @ inner $ ( Option < $ type > ) * , $ t
                                       } describe_type ! {
                                       @ inner $ ( [ $ type ; 2 ] ) * , Type
                                       :: Array } describe_type ! {
                                       @ inner $ ( [ $ type ; 3 ] ) * , Type
                                       :: Array } describe_type ! {
                                       @ inner $ ( [ $ type ; 4 ] ) * , Type
                                       :: Array } describe_type ! {
                                       @ inner $ ( Vec < $ type > ) * , Type
                                       :: Array } } ; (
                                       @ inner $ ( $ type : ty ) * , $ t :
                                       expr ) => {
                                       $ (
                                       impl DescribeType for $ type {
                                       fn describe_type (  ) -> Type { $ t } }
                                       ) * } ;);
            impl DescribeType for Color {
                fn describe_type() -> Type { Type::Color }
            }
            impl DescribeType for Option<Color> {
                fn describe_type() -> Type { Type::Color }
            }
            impl DescribeType for [Color; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [Color; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [Color; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<Color> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for i32 {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for u32 {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for isize {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for usize {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for f32 {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for f64 {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for Option<i32> {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for Option<u32> {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for Option<isize> {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for Option<usize> {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for Option<f32> {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for Option<f64> {
                fn describe_type() -> Type { Type::Number }
            }
            impl DescribeType for [i32; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [u32; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [isize; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [usize; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [f32; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [f64; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [i32; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [u32; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [isize; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [usize; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [f32; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [f64; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [i32; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [u32; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [isize; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [usize; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [f32; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [f64; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<i32> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<u32> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<isize> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<usize> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<f32> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<f64> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for String {
                fn describe_type() -> Type { Type::String }
            }
            impl DescribeType for Option<String> {
                fn describe_type() -> Type { Type::String }
            }
            impl DescribeType for [String; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [String; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [String; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<String> {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for bool {
                fn describe_type() -> Type { Type::Boolean }
            }
            impl DescribeType for Option<bool> {
                fn describe_type() -> Type { Type::Boolean }
            }
            impl DescribeType for [bool; 2] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [bool; 3] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for [bool; 4] {
                fn describe_type() -> Type { Type::Array }
            }
            impl DescribeType for Vec<bool> {
                fn describe_type() -> Type { Type::Array }
            }
            /// Utility structs that passes expected type into `Deserialize` implementation of `BaseExpr`, through
            /// scoped thread local variable
            pub struct TypedExpr<T: DescribeType>(pub Expr,
                                                  ::std::marker::PhantomData<T>);
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::fmt::Debug + DescribeType> ::std::fmt::Debug for
             TypedExpr<T> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        TypedExpr(ref __self_0_0, ref __self_0_1) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("TypedExpr");
                            let _ =
                                debug_trait_builder.field(&&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field(&&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::clone::Clone + DescribeType> ::std::clone::Clone
             for TypedExpr<T> {
                #[inline]
                fn clone(&self) -> TypedExpr<T> {
                    match *self {
                        TypedExpr(ref __self_0_0, ref __self_0_1) =>
                        TypedExpr(::std::clone::Clone::clone(&(*__self_0_0)),
                                  ::std::clone::Clone::clone(&(*__self_0_1))),
                    }
                }
            }
            impl <T: DescribeType> TypedExpr<T> {
                #[inline]
                pub fn is_zoom(&self) -> bool { self.0.is_zoom() }
                #[inline]
                pub fn is_feature(&self) -> bool { self.0.is_feature() }
            }
            impl <'de, T: DescribeType> Deserialize<'de> for TypedExpr<T> {
                fn deserialize<D>(deserializer: D)
                 -> StdResult<Self, D::Error> where D: Deserializer<'de> {
                    TYPE.set(&T::describe_type(),
                             ||
                                 {
                                     Ok(TypedExpr(Deserialize::deserialize(deserializer)?,
                                                  ::std::marker::PhantomData))
                                 })
                }
            }
            impl <T: DescribeType + Clone> Expression for TypedExpr<T> {
                fn is_zoom(&self) -> bool { self.0.is_zoom() }
                #[inline(never)]
                fn is_feature(&self) -> bool { self.0.is_feature() }
                fn eval(&self, ctx: &EvaluationContext) -> ExprResult {
                    self.0.eval(ctx)
                }
            }
        }
        mod filter {
            use prelude::*;
            #[serde(untagged)]
            pub enum PropKey {

                #[serde(rename = "$type")]
                Type,

                #[serde(rename = "$id")]
                Id,
                Key(String),
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for PropKey {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&PropKey::Type,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Type");
                            debug_trait_builder.finish()
                        }
                        (&PropKey::Id,) => {
                            let mut debug_trait_builder = f.debug_tuple("Id");
                            debug_trait_builder.finish()
                        }
                        (&PropKey::Key(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Key");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[allow(non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications)]
            const _IMPL_DESERIALIZE_FOR_PropKey: () =
                {
                    #[allow(unknown_lints)]
                    #[allow(rust_2018_idioms)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try(( $ __expr : expr ) => {
                                     match $ __expr {
                                     _serde :: export :: Ok ( __val ) => __val
                                     , _serde :: export :: Err ( __err ) => {
                                     return _serde :: export :: Err ( __err )
                                     ; } } });
                    #[automatically_derived]
                    impl <'de> _serde::Deserialize<'de> for PropKey {
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            let __content =
                                match <_serde::private::de::Content as
                                          _serde::Deserialize>::deserialize(__deserializer)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            if let _serde::export::Ok(__ok) =
                                   match _serde::Deserializer::deserialize_any(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                                                                               _serde::private::de::UntaggedUnitVisitor::new("PropKey",
                                                                                                                             "Type"))
                                       {
                                       _serde::export::Ok(()) =>
                                       _serde::export::Ok(PropKey::Type),
                                       _serde::export::Err(__err) =>
                                       _serde::export::Err(__err),
                                   } {
                                return _serde::export::Ok(__ok);
                            }
                            if let _serde::export::Ok(__ok) =
                                   match _serde::Deserializer::deserialize_any(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                                                                               _serde::private::de::UntaggedUnitVisitor::new("PropKey",
                                                                                                                             "Id"))
                                       {
                                       _serde::export::Ok(()) =>
                                       _serde::export::Ok(PropKey::Id),
                                       _serde::export::Err(__err) =>
                                       _serde::export::Err(__err),
                                   } {
                                return _serde::export::Ok(__ok);
                            }
                            if let _serde::export::Ok(__ok) =
                                   _serde::export::Result::map(<String as
                                                                   _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                               PropKey::Key) {
                                return _serde::export::Ok(__ok);
                            }
                            _serde::export::Err(_serde::de::Error::custom("data did not match any variant of untagged enum PropKey"))
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for PropKey {
                #[inline]
                fn clone(&self) -> PropKey {
                    match (&*self,) {
                        (&PropKey::Type,) => PropKey::Type,
                        (&PropKey::Id,) => PropKey::Id,
                        (&PropKey::Key(ref __self_0),) =>
                        PropKey::Key(::std::clone::Clone::clone(&(*__self_0))),
                    }
                }
            }
            pub enum Filter {
                Raw(bool),
                Has(PropKey),
                NotHas(PropKey),
                In(PropKey, Vec<Value>),
                NotIn(PropKey, Vec<Value>),
                Eq(PropKey, Value),
                Neq(PropKey, Value),
                Gt(PropKey, Value),
                Geq(PropKey, Value),
                Lt(PropKey, Value),
                Leq(PropKey, Value),
                All(Vec<Filter>),
                Any(Vec<Filter>),
                None(Vec<Filter>),
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for Filter {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&Filter::Raw(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Raw");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Has(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Has");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&Filter::NotHas(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("NotHas");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&Filter::In(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder = f.debug_tuple("In");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::NotIn(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("NotIn");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Eq(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder = f.debug_tuple("Eq");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Neq(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Neq");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Gt(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder = f.debug_tuple("Gt");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Geq(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Geq");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Lt(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder = f.debug_tuple("Lt");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Leq(ref __self_0, ref __self_1),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Leq");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            let _ = debug_trait_builder.field(&&(*__self_1));
                            debug_trait_builder.finish()
                        }
                        (&Filter::All(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("All");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&Filter::Any(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Any");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&Filter::None(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("None");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Filter {
                #[inline]
                fn clone(&self) -> Filter {
                    match (&*self,) {
                        (&Filter::Raw(ref __self_0),) =>
                        Filter::Raw(::std::clone::Clone::clone(&(*__self_0))),
                        (&Filter::Has(ref __self_0),) =>
                        Filter::Has(::std::clone::Clone::clone(&(*__self_0))),
                        (&Filter::NotHas(ref __self_0),) =>
                        Filter::NotHas(::std::clone::Clone::clone(&(*__self_0))),
                        (&Filter::In(ref __self_0, ref __self_1),) =>
                        Filter::In(::std::clone::Clone::clone(&(*__self_0)),
                                   ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::NotIn(ref __self_0, ref __self_1),) =>
                        Filter::NotIn(::std::clone::Clone::clone(&(*__self_0)),
                                      ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::Eq(ref __self_0, ref __self_1),) =>
                        Filter::Eq(::std::clone::Clone::clone(&(*__self_0)),
                                   ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::Neq(ref __self_0, ref __self_1),) =>
                        Filter::Neq(::std::clone::Clone::clone(&(*__self_0)),
                                    ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::Gt(ref __self_0, ref __self_1),) =>
                        Filter::Gt(::std::clone::Clone::clone(&(*__self_0)),
                                   ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::Geq(ref __self_0, ref __self_1),) =>
                        Filter::Geq(::std::clone::Clone::clone(&(*__self_0)),
                                    ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::Lt(ref __self_0, ref __self_1),) =>
                        Filter::Lt(::std::clone::Clone::clone(&(*__self_0)),
                                   ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::Leq(ref __self_0, ref __self_1),) =>
                        Filter::Leq(::std::clone::Clone::clone(&(*__self_0)),
                                    ::std::clone::Clone::clone(&(*__self_1))),
                        (&Filter::All(ref __self_0),) =>
                        Filter::All(::std::clone::Clone::clone(&(*__self_0))),
                        (&Filter::Any(ref __self_0),) =>
                        Filter::Any(::std::clone::Clone::clone(&(*__self_0))),
                        (&Filter::None(ref __self_0),) =>
                        Filter::None(::std::clone::Clone::clone(&(*__self_0))),
                    }
                }
            }
            use ::common::serde::{self, Serialize, Deserialize, Serializer,
                                  Deserializer};
            use ::common::json;
            fn from_jvalue<T: ::common::serde::de::DeserializeOwned>(val:
                                                                         &json::Value)
             -> StdResult<T, json::Error> {
                return json::from_value(val.clone());
            }
            impl <'de> Deserialize<'de> for Filter {
                fn deserialize<D>(deserializer: D)
                 -> StdResult<Self, <D as Deserializer<'de>>::Error> where
                 D: Deserializer<'de> {
                    #[serde(untagged)]
                    enum Help { Bool(bool), Arr(Vec<json::Value>), }
                    #[allow(non_upper_case_globals,
                            unused_attributes,
                            unused_qualifications)]
                    const _IMPL_DESERIALIZE_FOR_Help: () =
                        {
                            #[allow(unknown_lints)]
                            #[allow(rust_2018_idioms)]
                            extern crate serde as _serde;
                            #[allow(unused_macros)]
                            macro_rules! try(( $ __expr : expr ) => {
                                             match $ __expr {
                                             _serde :: export :: Ok ( __val )
                                             => __val , _serde :: export ::
                                             Err ( __err ) => {
                                             return _serde :: export :: Err (
                                             __err ) ; } } });
                            #[automatically_derived]
                            impl <'de> _serde::Deserialize<'de> for Help {
                                fn deserialize<__D>(__deserializer: __D)
                                 -> _serde::export::Result<Self, __D::Error>
                                 where __D: _serde::Deserializer<'de> {
                                    let __content =
                                        match <_serde::private::de::Content as
                                                  _serde::Deserialize>::deserialize(__deserializer)
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    if let _serde::export::Ok(__ok) =
                                           _serde::export::Result::map(<bool
                                                                           as
                                                                           _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                                       Help::Bool)
                                           {
                                        return _serde::export::Ok(__ok);
                                    }
                                    if let _serde::export::Ok(__ok) =
                                           _serde::export::Result::map(<Vec<json::Value>
                                                                           as
                                                                           _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                                       Help::Arr)
                                           {
                                        return _serde::export::Ok(__ok);
                                    }
                                    _serde::export::Err(_serde::de::Error::custom("data did not match any variant of untagged enum Help"))
                                }
                            }
                        };
                    let data: Help = Deserialize::deserialize(deserializer)?;
                    if let Help::Bool(b) = data { return Ok(Filter::Raw(b)); }
                    let mut data =
                        if let Help::Arr(d) = data {
                            d
                        } else {
                            {
                                {
                                    ::rt::begin_panic("explicit panic",
                                                      &("rmaps/src/map/style/filter.rs",
                                                        60u32, 13u32))
                                }
                            }
                        };
                    let serde_err =
                        |_e| { serde::de::Error::custom("Invalid filter") };
                    match data[..] {
                        [json::Value::String(ref first), ref mut rest..] => {
                            return Ok(match (first.as_ref(), rest) {
                                          ("has", [key]) => {
                                              Filter::Has(from_jvalue(key).map_err(serde_err)?)
                                          }
                                          ("!has", [key]) => {
                                              Filter::NotHas(from_jvalue(key).map_err(serde_err)?)
                                          }
                                          ("==", [key, value]) => {
                                              Filter::Eq(from_jvalue(key).map_err(serde_err)?,
                                                         from_jvalue(value).map_err(serde_err)?)
                                          }
                                          ("!=", [key, value]) => {
                                              Filter::Neq(from_jvalue(key).map_err(serde_err)?,
                                                          from_jvalue(value).map_err(serde_err)?)
                                          }
                                          (">", [key, value]) => {
                                              Filter::Gt(from_jvalue(key).map_err(serde_err)?,
                                                         from_jvalue(value).map_err(serde_err)?)
                                          }
                                          (">=", [key, value]) => {
                                              Filter::Geq(from_jvalue(key).map_err(serde_err)?,
                                                          from_jvalue(value).map_err(serde_err)?)
                                          }
                                          ("<", [key, value]) => {
                                              Filter::Lt(from_jvalue(key).map_err(serde_err)?,
                                                         from_jvalue(value).map_err(serde_err)?)
                                          }
                                          ("<=", [key, value]) => {
                                              Filter::Leq(from_jvalue(key).map_err(serde_err)?,
                                                          from_jvalue(value).map_err(serde_err)?)
                                          }
                                          ("in", [key, rest..]) => {
                                              let vals =
                                                  rest.iter().map(|v|
                                                                      from_jvalue(v).map_err(serde_err)).collect::<StdResult<Vec<_>,
                                                                                                                             _>>()?;
                                              Filter::In(from_jvalue(key).map_err(serde_err)?,
                                                         vals)
                                          }
                                          ("!in", [key, rest..]) => {
                                              let vals =
                                                  rest.iter().map(|v|
                                                                      from_jvalue(v).map_err(serde_err)).collect::<StdResult<Vec<_>,
                                                                                                                             _>>()?;
                                              Filter::NotIn(from_jvalue(key).map_err(serde_err)?,
                                                            vals)
                                          }
                                          ("all", rest) => {
                                              let filters =
                                                  rest.iter().map(|v|
                                                                      from_jvalue(v).map_err(serde_err)).collect::<StdResult<Vec<Filter>,
                                                                                                                             _>>()?;
                                              Filter::All(filters)
                                          }
                                          ("any", rest) => {
                                              let filters =
                                                  rest.iter().map(|v|
                                                                      from_jvalue(v).map_err(serde_err)).collect::<StdResult<Vec<Filter>,
                                                                                                                             _>>()?;
                                              Filter::Any(filters)
                                          }
                                          ("none", rest) => {
                                              let filters =
                                                  rest.iter().map(|v|
                                                                      from_jvalue(v).map_err(serde_err)).collect::<StdResult<Vec<Filter>,
                                                                                                                             _>>()?;
                                              Filter::None(filters)
                                          }
                                          _ => {
                                              return Err(serde::de::Error::custom("Invalid filter"));
                                          }
                                      });
                        }
                        _ => { }
                    }
                    {
                        ::rt::begin_panic("not yet implemented",
                                          &("rmaps/src/map/style/filter.rs",
                                            153u32, 9u32))
                    }
                }
            }
            pub struct FilterEvaluator<'a> {
                feature: &'a ::mvt::Feature,
            }
            use common::geometry::Value;
            impl <'a> FilterEvaluator<'a> {
                fn new(feature: &'a ::mvt::Feature) -> Self {
                    FilterEvaluator{feature,}
                }
                fn satisfies_opt(feature: &::mvt::Feature,
                                 filter: &Option<Filter>) -> bool {
                    return if let Some(filter) = filter {
                               FilterEvaluator::new(feature).evaluate(filter)
                           } else { true };
                }
                fn satisfies(feature: &::mvt::Feature, filter: &Filter)
                 -> bool {
                    FilterEvaluator::new(feature).evaluate(filter)
                }
                fn id(&self) -> u64 { return self.feature.id; }
                fn typ(&self) -> String { self.feature.typ.to_string() }
                fn get(&self, key: &PropKey) -> Option<Value> {
                    match key {
                        PropKey::Id => Some(Value::UInt(self.feature.id)),
                        PropKey::Type => Some(Value::String(self.typ())),
                        PropKey::Key(k) =>
                        self.feature.get(k).map(|v| v.clone()),
                    }
                }
                fn evaluate(&self, filter: &Filter) -> bool {
                    return match filter {
                               Filter::Raw(v) => *v,
                               Filter::Has(PropKey::Id) => true,
                               Filter::Has(PropKey::Type) => true,
                               Filter::Has(PropKey::Key(ref key)) =>
                               self.feature.tags.key_idxs.contains_key(key),
                               Filter::NotHas(k) =>
                               !self.evaluate(&Filter::Has(k.clone())),
                               Filter::In(k, vals) =>
                               vals.iter().any(|v|
                                                   Some(v) ==
                                                       self.get(k).as_ref()),
                               Filter::NotIn(k, vals) =>
                               !vals.iter().any(|v|
                                                    Some(v) ==
                                                        self.get(k).as_ref()),
                               Filter::Eq(k, v) =>
                               Some(v) == self.get(k).as_ref(),
                               Filter::Neq(k, v) =>
                               Some(v) != self.get(k).as_ref(),
                               Filter::Gt(k, v) =>
                               Some(v) > self.get(k).as_ref(),
                               Filter::Geq(k, v) =>
                               Some(v) >= self.get(k).as_ref(),
                               Filter::Lt(k, v) =>
                               Some(v) < self.get(k).as_ref(),
                               Filter::Leq(k, v) =>
                               Some(v) <= self.get(k).as_ref(),
                               Filter::All(filters) =>
                               filters.iter().all(|f| self.evaluate(f)),
                               Filter::Any(filters) =>
                               filters.iter().any(|f| self.evaluate(f)),
                               Filter::None(filters) =>
                               !filters.iter().any(|f| self.evaluate(f)),
                               _ => false,
                           };
                }
            }
        }
        mod layers {
            use prelude::*;
            pub mod background {
                use prelude::*;
                use super::{LayerCommon, StyleLayer, BaseLayout, Visibility,
                            StyleProp};
                pub struct BackgroundLayer {
                    #[serde(flatten)]
                    pub common: LayerCommon,
                    #[serde(default = "Default::default")]
                    pub layout: BaseLayout,
                    #[serde(default = "Default::default")]
                    pub paint: BackgroundPaint,
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for BackgroundLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            BackgroundLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("BackgroundLayer");
                                let _ =
                                    debug_trait_builder.field("common",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("layout",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("paint",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_BackgroundLayer: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for
                         BackgroundLayer {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field<'de> {
                                    __field1,
                                    __field2,
                                    __other(_serde::private::de::Content<'de>),
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field<'de>;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_bool<__E>(self, __value: bool)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))
                                    }
                                    fn visit_i8<__E>(self, __value: i8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))
                                    }
                                    fn visit_i16<__E>(self, __value: i16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))
                                    }
                                    fn visit_i32<__E>(self, __value: i32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))
                                    }
                                    fn visit_i64<__E>(self, __value: i64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))
                                    }
                                    fn visit_u8<__E>(self, __value: u8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))
                                    }
                                    fn visit_u16<__E>(self, __value: u16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))
                                    }
                                    fn visit_u32<__E>(self, __value: u32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))
                                    }
                                    fn visit_f32<__E>(self, __value: f32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))
                                    }
                                    fn visit_f64<__E>(self, __value: f64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))
                                    }
                                    fn visit_char<__E>(self, __value: char)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))
                                    }
                                    fn visit_unit<__E>(self)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))
                                    }
                                    fn visit_borrowed_str<__E>(self,
                                                               __value:
                                                                   &'de str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Str(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_borrowed_bytes<__E>(self,
                                                                 __value:
                                                                     &'de [u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Bytes(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::String(__value.to_string());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::ByteBuf(__value.to_vec());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field<'de> {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<BackgroundLayer>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    BackgroundLayer;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct BackgroundLayer")
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field1:
                                                _serde::export::Option<BaseLayout> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<BackgroundPaint> =
                                            _serde::export::None;
                                        let mut __collect =
                                            _serde::export::Vec::<_serde::export::Option<(_serde::private::de::Content,
                                                                                          _serde::private::de::Content)>>::new();
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("layout"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<BaseLayout>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("paint"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<BackgroundPaint>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__other(__name) => {
                                                    __collect.push(_serde::export::Some((__name,
                                                                                         match _serde::de::MapAccess::next_value(&mut __map)
                                                                                             {
                                                                                             _serde::export::Ok(__val)
                                                                                             =>
                                                                                             __val,
                                                                                             _serde::export::Err(__err)
                                                                                             =>
                                                                                             {
                                                                                                 return _serde::export::Err(__err);
                                                                                             }
                                                                                         })));
                                                }
                                            }
                                        }
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        let __field0: LayerCommon =
                                            match _serde::de::Deserialize::deserialize(_serde::private::de::FlatMapDeserializer(&mut __collect,
                                                                                                                                _serde::export::PhantomData))
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        _serde::export::Ok(BackgroundLayer{common:
                                                                               __field0,
                                                                           layout:
                                                                               __field1,
                                                                           paint:
                                                                               __field2,})
                                    }
                                }
                                _serde::Deserializer::deserialize_map(__deserializer,
                                                                      __Visitor{marker:
                                                                                    _serde::export::PhantomData::<BackgroundLayer>,
                                                                                lifetime:
                                                                                    _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for BackgroundLayer {
                    #[inline]
                    fn clone(&self) -> BackgroundLayer {
                        match *self {
                            BackgroundLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } =>
                            BackgroundLayer{common:
                                                ::std::clone::Clone::clone(&(*__self_0_0)),
                                            layout:
                                                ::std::clone::Clone::clone(&(*__self_0_1)),
                                            paint:
                                                ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                impl StyleLayer for BackgroundLayer {
                    type
                    PaintType
                    =
                    BackgroundPaint;
                    type
                    LayoutType
                    =
                    BaseLayout;
                    fn get_paint(&self) -> &<Self as StyleLayer>::PaintType {
                        &self.paint
                    }
                    fn get_layout(&self)
                     -> &<Self as StyleLayer>::LayoutType {
                        &self.layout
                    }
                }
                pub struct BackgroundPaint {
                    #[serde(rename = "background-color")]
                    #[serde(default = "default_background_color")]
                    pub color: StyleProp<Color>,
                    #[serde(rename = "background-opacity")]
                    #[serde(default = "default_backround_opacity")]
                    pub opacity: StyleProp<f32>,
                    #[serde(rename = "background-pattern")]
                    #[serde(default)]
                    pub pattern: StyleProp<Option<String>>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_BackgroundPaint: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for
                         BackgroundPaint {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            0u64 =>
                                            _serde::export::Ok(__Field::__field0),
                                            1u64 =>
                                            _serde::export::Ok(__Field::__field1),
                                            2u64 =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ =>
                                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                 &"field index 0 <= i < 3")),
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "background-color" =>
                                            _serde::export::Ok(__Field::__field0),
                                            "background-opacity" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "background-pattern" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"background-color" =>
                                            _serde::export::Ok(__Field::__field0),
                                            b"background-opacity" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"background-pattern" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<BackgroundPaint>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    BackgroundPaint;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct BackgroundPaint")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(self, mut __seq: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::SeqAccess<'de> {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Color>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                 &"struct BackgroundPaint with 3 elements"));
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<f32>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                                 &"struct BackgroundPaint with 3 elements"));
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Option<String>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                                 &"struct BackgroundPaint with 3 elements"));
                                                }
                                            };
                                        _serde::export::Ok(BackgroundPaint{color:
                                                                               __field0,
                                                                           opacity:
                                                                               __field1,
                                                                           pattern:
                                                                               __field2,})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field0:
                                                _serde::export::Option<StyleProp<Color>> =
                                            _serde::export::None;
                                        let mut __field1:
                                                _serde::export::Option<StyleProp<f32>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<StyleProp<Option<String>>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("background-color"));
                                                    }
                                                    __field0 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Color>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("background-opacity"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<f32>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("background-pattern"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Option<String>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                _ => {
                                                    let _ =
                                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                }
                                            }
                                        }
                                        let __field0 =
                                            match __field0 {
                                                _serde::export::Some(__field0)
                                                => __field0,
                                                _serde::export::None =>
                                                default_background_color(),
                                            };
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                default_backround_opacity(),
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                _serde::export::Default::default(),
                                            };
                                        _serde::export::Ok(BackgroundPaint{color:
                                                                               __field0,
                                                                           opacity:
                                                                               __field1,
                                                                           pattern:
                                                                               __field2,})
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["background-color",
                                      "background-opacity",
                                      "background-pattern"];
                                _serde::Deserializer::deserialize_struct(__deserializer,
                                                                         "BackgroundPaint",
                                                                         FIELDS,
                                                                         __Visitor{marker:
                                                                                       _serde::export::PhantomData::<BackgroundPaint>,
                                                                                   lifetime:
                                                                                       _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for BackgroundPaint {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            BackgroundPaint {
                            color: ref __self_0_0,
                            opacity: ref __self_0_1,
                            pattern: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("BackgroundPaint");
                                let _ =
                                    debug_trait_builder.field("color",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("opacity",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("pattern",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for BackgroundPaint {
                    #[inline]
                    fn clone(&self) -> BackgroundPaint {
                        match *self {
                            BackgroundPaint {
                            color: ref __self_0_0,
                            opacity: ref __self_0_1,
                            pattern: ref __self_0_2 } =>
                            BackgroundPaint{color:
                                                ::std::clone::Clone::clone(&(*__self_0_0)),
                                            opacity:
                                                ::std::clone::Clone::clone(&(*__self_0_1)),
                                            pattern:
                                                ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                fn default_background_color() -> StyleProp<Color> {
                    return StyleProp::Value(Color([0., 0., 0., 1.]));
                }
                fn default_backround_opacity() -> StyleProp<f32> {
                    return StyleProp::Value(1.0);
                }
                impl Default for BackgroundPaint {
                    fn default() -> Self {
                        BackgroundPaint{color: default_background_color(),
                                        opacity: default_backround_opacity(),
                                        pattern: StyleProp::Value(None),}
                    }
                }
            }
            pub mod fill {
                use prelude::*;
                use super::{LayerCommon, StyleLayer, BaseLayout, Visibility,
                            StyleProp};
                pub struct FillLayer {
                    #[serde(flatten)]
                    pub common: LayerCommon,
                    #[serde(default = "BaseLayout::default")]
                    pub layout: BaseLayout,
                    #[serde(default = "FillPaint::default")]
                    pub paint: FillPaint,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_FillLayer: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for FillLayer {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field<'de> {
                                    __field1,
                                    __field2,
                                    __other(_serde::private::de::Content<'de>),
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field<'de>;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_bool<__E>(self, __value: bool)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))
                                    }
                                    fn visit_i8<__E>(self, __value: i8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))
                                    }
                                    fn visit_i16<__E>(self, __value: i16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))
                                    }
                                    fn visit_i32<__E>(self, __value: i32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))
                                    }
                                    fn visit_i64<__E>(self, __value: i64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))
                                    }
                                    fn visit_u8<__E>(self, __value: u8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))
                                    }
                                    fn visit_u16<__E>(self, __value: u16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))
                                    }
                                    fn visit_u32<__E>(self, __value: u32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))
                                    }
                                    fn visit_f32<__E>(self, __value: f32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))
                                    }
                                    fn visit_f64<__E>(self, __value: f64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))
                                    }
                                    fn visit_char<__E>(self, __value: char)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))
                                    }
                                    fn visit_unit<__E>(self)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))
                                    }
                                    fn visit_borrowed_str<__E>(self,
                                                               __value:
                                                                   &'de str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Str(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_borrowed_bytes<__E>(self,
                                                                 __value:
                                                                     &'de [u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Bytes(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::String(__value.to_string());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::ByteBuf(__value.to_vec());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field<'de> {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<FillLayer>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    FillLayer;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct FillLayer")
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field1:
                                                _serde::export::Option<BaseLayout> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<FillPaint> =
                                            _serde::export::None;
                                        let mut __collect =
                                            _serde::export::Vec::<_serde::export::Option<(_serde::private::de::Content,
                                                                                          _serde::private::de::Content)>>::new();
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("layout"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<BaseLayout>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("paint"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<FillPaint>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__other(__name) => {
                                                    __collect.push(_serde::export::Some((__name,
                                                                                         match _serde::de::MapAccess::next_value(&mut __map)
                                                                                             {
                                                                                             _serde::export::Ok(__val)
                                                                                             =>
                                                                                             __val,
                                                                                             _serde::export::Err(__err)
                                                                                             =>
                                                                                             {
                                                                                                 return _serde::export::Err(__err);
                                                                                             }
                                                                                         })));
                                                }
                                            }
                                        }
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                BaseLayout::default(),
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                FillPaint::default(),
                                            };
                                        let __field0: LayerCommon =
                                            match _serde::de::Deserialize::deserialize(_serde::private::de::FlatMapDeserializer(&mut __collect,
                                                                                                                                _serde::export::PhantomData))
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        _serde::export::Ok(FillLayer{common:
                                                                         __field0,
                                                                     layout:
                                                                         __field1,
                                                                     paint:
                                                                         __field2,})
                                    }
                                }
                                _serde::Deserializer::deserialize_map(__deserializer,
                                                                      __Visitor{marker:
                                                                                    _serde::export::PhantomData::<FillLayer>,
                                                                                lifetime:
                                                                                    _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FillLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FillLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("FillLayer");
                                let _ =
                                    debug_trait_builder.field("common",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("layout",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("paint",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for FillLayer {
                    #[inline]
                    fn clone(&self) -> FillLayer {
                        match *self {
                            FillLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } =>
                            FillLayer{common:
                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                      layout:
                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                      paint:
                                          ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                impl StyleLayer for FillLayer {
                    type
                    PaintType
                    =
                    FillPaint;
                    type
                    LayoutType
                    =
                    BaseLayout;
                    fn get_paint(&self) -> &Self::PaintType { &self.paint }
                    fn get_layout(&self) -> &Self::LayoutType { &self.layout }
                }
                pub struct FillPaint {
                    #[serde(rename = "fill-antialias")]
                    #[serde(default)]
                    pub antialias: StyleProp<bool>,
                    #[serde(rename = "fill-opacity")]
                    #[serde(default = "Default::default")]
                    pub opacity: StyleProp<f32>,
                    #[serde(rename = "fill-color")]
                    #[serde(default = "Default::default")]
                    pub color: StyleProp<Color>,
                    #[serde(rename = "fill-outline-color")]
                    #[serde(default = "Default::default")]
                    pub outline_color: StyleProp<Color>,
                    #[serde(rename = "fill-translate")]
                    #[serde(default = "Default::default")]
                    pub translate: StyleProp<[f32; 2]>,
                    #[serde(rename = "fill-translate-anchor")]
                    #[serde(default = "Default::default")]
                    pub translate_anchor: StyleProp<Option<String>>,
                    #[serde(rename = "fill-pattern")]
                    #[serde(default = "Default::default")]
                    pub pattern: StyleProp<Option<String>>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_FillPaint: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for FillPaint {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __field4,
                                    __field5,
                                    __field6,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            0u64 =>
                                            _serde::export::Ok(__Field::__field0),
                                            1u64 =>
                                            _serde::export::Ok(__Field::__field1),
                                            2u64 =>
                                            _serde::export::Ok(__Field::__field2),
                                            3u64 =>
                                            _serde::export::Ok(__Field::__field3),
                                            4u64 =>
                                            _serde::export::Ok(__Field::__field4),
                                            5u64 =>
                                            _serde::export::Ok(__Field::__field5),
                                            6u64 =>
                                            _serde::export::Ok(__Field::__field6),
                                            _ =>
                                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                 &"field index 0 <= i < 7")),
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "fill-antialias" =>
                                            _serde::export::Ok(__Field::__field0),
                                            "fill-opacity" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "fill-color" =>
                                            _serde::export::Ok(__Field::__field2),
                                            "fill-outline-color" =>
                                            _serde::export::Ok(__Field::__field3),
                                            "fill-translate" =>
                                            _serde::export::Ok(__Field::__field4),
                                            "fill-translate-anchor" =>
                                            _serde::export::Ok(__Field::__field5),
                                            "fill-pattern" =>
                                            _serde::export::Ok(__Field::__field6),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"fill-antialias" =>
                                            _serde::export::Ok(__Field::__field0),
                                            b"fill-opacity" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"fill-color" =>
                                            _serde::export::Ok(__Field::__field2),
                                            b"fill-outline-color" =>
                                            _serde::export::Ok(__Field::__field3),
                                            b"fill-translate" =>
                                            _serde::export::Ok(__Field::__field4),
                                            b"fill-translate-anchor" =>
                                            _serde::export::Ok(__Field::__field5),
                                            b"fill-pattern" =>
                                            _serde::export::Ok(__Field::__field6),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<FillPaint>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    FillPaint;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct FillPaint")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(self, mut __seq: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::SeqAccess<'de> {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<bool>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                 &"struct FillPaint with 7 elements"));
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<f32>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                                 &"struct FillPaint with 7 elements"));
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Color>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                                 &"struct FillPaint with 7 elements"));
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Color>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                                 &"struct FillPaint with 7 elements"));
                                                }
                                            };
                                        let __field4 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<[f32; 2]>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                                 &"struct FillPaint with 7 elements"));
                                                }
                                            };
                                        let __field5 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Option<String>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                                 &"struct FillPaint with 7 elements"));
                                                }
                                            };
                                        let __field6 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Option<String>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                                 &"struct FillPaint with 7 elements"));
                                                }
                                            };
                                        _serde::export::Ok(FillPaint{antialias:
                                                                         __field0,
                                                                     opacity:
                                                                         __field1,
                                                                     color:
                                                                         __field2,
                                                                     outline_color:
                                                                         __field3,
                                                                     translate:
                                                                         __field4,
                                                                     translate_anchor:
                                                                         __field5,
                                                                     pattern:
                                                                         __field6,})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field0:
                                                _serde::export::Option<StyleProp<bool>> =
                                            _serde::export::None;
                                        let mut __field1:
                                                _serde::export::Option<StyleProp<f32>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<StyleProp<Color>> =
                                            _serde::export::None;
                                        let mut __field3:
                                                _serde::export::Option<StyleProp<Color>> =
                                            _serde::export::None;
                                        let mut __field4:
                                                _serde::export::Option<StyleProp<[f32; 2]>> =
                                            _serde::export::None;
                                        let mut __field5:
                                                _serde::export::Option<StyleProp<Option<String>>> =
                                            _serde::export::None;
                                        let mut __field6:
                                                _serde::export::Option<StyleProp<Option<String>>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("fill-antialias"));
                                                    }
                                                    __field0 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<bool>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("fill-opacity"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<f32>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("fill-color"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Color>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field3 => {
                                                    if _serde::export::Option::is_some(&__field3)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("fill-outline-color"));
                                                    }
                                                    __field3 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Color>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field4 => {
                                                    if _serde::export::Option::is_some(&__field4)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("fill-translate"));
                                                    }
                                                    __field4 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<[f32; 2]>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field5 => {
                                                    if _serde::export::Option::is_some(&__field5)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("fill-translate-anchor"));
                                                    }
                                                    __field5 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Option<String>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field6 => {
                                                    if _serde::export::Option::is_some(&__field6)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("fill-pattern"));
                                                    }
                                                    __field6 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Option<String>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                _ => {
                                                    let _ =
                                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                }
                                            }
                                        }
                                        let __field0 =
                                            match __field0 {
                                                _serde::export::Some(__field0)
                                                => __field0,
                                                _serde::export::None =>
                                                _serde::export::Default::default(),
                                            };
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        let __field3 =
                                            match __field3 {
                                                _serde::export::Some(__field3)
                                                => __field3,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        let __field4 =
                                            match __field4 {
                                                _serde::export::Some(__field4)
                                                => __field4,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        let __field5 =
                                            match __field5 {
                                                _serde::export::Some(__field5)
                                                => __field5,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        let __field6 =
                                            match __field6 {
                                                _serde::export::Some(__field6)
                                                => __field6,
                                                _serde::export::None =>
                                                Default::default(),
                                            };
                                        _serde::export::Ok(FillPaint{antialias:
                                                                         __field0,
                                                                     opacity:
                                                                         __field1,
                                                                     color:
                                                                         __field2,
                                                                     outline_color:
                                                                         __field3,
                                                                     translate:
                                                                         __field4,
                                                                     translate_anchor:
                                                                         __field5,
                                                                     pattern:
                                                                         __field6,})
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["fill-antialias", "fill-opacity",
                                      "fill-color", "fill-outline-color",
                                      "fill-translate",
                                      "fill-translate-anchor",
                                      "fill-pattern"];
                                _serde::Deserializer::deserialize_struct(__deserializer,
                                                                         "FillPaint",
                                                                         FIELDS,
                                                                         __Visitor{marker:
                                                                                       _serde::export::PhantomData::<FillPaint>,
                                                                                   lifetime:
                                                                                       _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::default::Default for FillPaint {
                    #[inline]
                    fn default() -> FillPaint {
                        FillPaint{antialias:
                                      ::std::default::Default::default(),
                                  opacity: ::std::default::Default::default(),
                                  color: ::std::default::Default::default(),
                                  outline_color:
                                      ::std::default::Default::default(),
                                  translate:
                                      ::std::default::Default::default(),
                                  translate_anchor:
                                      ::std::default::Default::default(),
                                  pattern:
                                      ::std::default::Default::default(),}
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for FillPaint {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            FillPaint {
                            antialias: ref __self_0_0,
                            opacity: ref __self_0_1,
                            color: ref __self_0_2,
                            outline_color: ref __self_0_3,
                            translate: ref __self_0_4,
                            translate_anchor: ref __self_0_5,
                            pattern: ref __self_0_6 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("FillPaint");
                                let _ =
                                    debug_trait_builder.field("antialias",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("opacity",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("color",
                                                              &&(*__self_0_2));
                                let _ =
                                    debug_trait_builder.field("outline_color",
                                                              &&(*__self_0_3));
                                let _ =
                                    debug_trait_builder.field("translate",
                                                              &&(*__self_0_4));
                                let _ =
                                    debug_trait_builder.field("translate_anchor",
                                                              &&(*__self_0_5));
                                let _ =
                                    debug_trait_builder.field("pattern",
                                                              &&(*__self_0_6));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for FillPaint {
                    #[inline]
                    fn clone(&self) -> FillPaint {
                        match *self {
                            FillPaint {
                            antialias: ref __self_0_0,
                            opacity: ref __self_0_1,
                            color: ref __self_0_2,
                            outline_color: ref __self_0_3,
                            translate: ref __self_0_4,
                            translate_anchor: ref __self_0_5,
                            pattern: ref __self_0_6 } =>
                            FillPaint{antialias:
                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                      opacity:
                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                      color:
                                          ::std::clone::Clone::clone(&(*__self_0_2)),
                                      outline_color:
                                          ::std::clone::Clone::clone(&(*__self_0_3)),
                                      translate:
                                          ::std::clone::Clone::clone(&(*__self_0_4)),
                                      translate_anchor:
                                          ::std::clone::Clone::clone(&(*__self_0_5)),
                                      pattern:
                                          ::std::clone::Clone::clone(&(*__self_0_6)),},
                        }
                    }
                }
            }
            pub mod line {
                use prelude::*;
                use super::{LayerCommon, BaseLayout, Visibility, StyleProp};
                pub struct LineLayer {
                    #[serde(flatten)]
                    pub common: LayerCommon,
                    pub layout: Option<LineLayout>,
                    pub paint: Option<LinePaint>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_LineLayer: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for LineLayer {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field<'de> {
                                    __field1,
                                    __field2,
                                    __other(_serde::private::de::Content<'de>),
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field<'de>;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_bool<__E>(self, __value: bool)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))
                                    }
                                    fn visit_i8<__E>(self, __value: i8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))
                                    }
                                    fn visit_i16<__E>(self, __value: i16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))
                                    }
                                    fn visit_i32<__E>(self, __value: i32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))
                                    }
                                    fn visit_i64<__E>(self, __value: i64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))
                                    }
                                    fn visit_u8<__E>(self, __value: u8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))
                                    }
                                    fn visit_u16<__E>(self, __value: u16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))
                                    }
                                    fn visit_u32<__E>(self, __value: u32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))
                                    }
                                    fn visit_f32<__E>(self, __value: f32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))
                                    }
                                    fn visit_f64<__E>(self, __value: f64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))
                                    }
                                    fn visit_char<__E>(self, __value: char)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))
                                    }
                                    fn visit_unit<__E>(self)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))
                                    }
                                    fn visit_borrowed_str<__E>(self,
                                                               __value:
                                                                   &'de str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Str(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_borrowed_bytes<__E>(self,
                                                                 __value:
                                                                     &'de [u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Bytes(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::String(__value.to_string());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::ByteBuf(__value.to_vec());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field<'de> {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<LineLayer>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    LineLayer;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct LineLayer")
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field1:
                                                _serde::export::Option<Option<LineLayout>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<Option<LinePaint>> =
                                            _serde::export::None;
                                        let mut __collect =
                                            _serde::export::Vec::<_serde::export::Option<(_serde::private::de::Content,
                                                                                          _serde::private::de::Content)>>::new();
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("layout"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<LineLayout>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("paint"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<LinePaint>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__other(__name) => {
                                                    __collect.push(_serde::export::Some((__name,
                                                                                         match _serde::de::MapAccess::next_value(&mut __map)
                                                                                             {
                                                                                             _serde::export::Ok(__val)
                                                                                             =>
                                                                                             __val,
                                                                                             _serde::export::Err(__err)
                                                                                             =>
                                                                                             {
                                                                                                 return _serde::export::Err(__err);
                                                                                             }
                                                                                         })));
                                                }
                                            }
                                        }
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("layout")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("paint")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field0: LayerCommon =
                                            match _serde::de::Deserialize::deserialize(_serde::private::de::FlatMapDeserializer(&mut __collect,
                                                                                                                                _serde::export::PhantomData))
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        _serde::export::Ok(LineLayer{common:
                                                                         __field0,
                                                                     layout:
                                                                         __field1,
                                                                     paint:
                                                                         __field2,})
                                    }
                                }
                                _serde::Deserializer::deserialize_map(__deserializer,
                                                                      __Visitor{marker:
                                                                                    _serde::export::PhantomData::<LineLayer>,
                                                                                lifetime:
                                                                                    _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for LineLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            LineLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("LineLayer");
                                let _ =
                                    debug_trait_builder.field("common",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("layout",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("paint",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for LineLayer {
                    #[inline]
                    fn clone(&self) -> LineLayer {
                        match *self {
                            LineLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } =>
                            LineLayer{common:
                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                      layout:
                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                      paint:
                                          ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                pub struct LineLayout {
                    #[serde(rename = "line-cap")]
                    cap: Option<StyleProp<String>>,
                    #[serde(rename = "line-join")]
                    join: Option<StyleProp<String>>,
                    #[serde(rename = "line-miter-limit")]
                    miter_limit: Option<StyleProp<f32>>,
                    #[serde(rename = "line-round-limit")]
                    round_limit: Option<StyleProp<f32>>,
                    visibility: Option<Visibility>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_LineLayout: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for LineLayout {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __field4,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            0u64 =>
                                            _serde::export::Ok(__Field::__field0),
                                            1u64 =>
                                            _serde::export::Ok(__Field::__field1),
                                            2u64 =>
                                            _serde::export::Ok(__Field::__field2),
                                            3u64 =>
                                            _serde::export::Ok(__Field::__field3),
                                            4u64 =>
                                            _serde::export::Ok(__Field::__field4),
                                            _ =>
                                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                 &"field index 0 <= i < 5")),
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "line-cap" =>
                                            _serde::export::Ok(__Field::__field0),
                                            "line-join" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "line-miter-limit" =>
                                            _serde::export::Ok(__Field::__field2),
                                            "line-round-limit" =>
                                            _serde::export::Ok(__Field::__field3),
                                            "visibility" =>
                                            _serde::export::Ok(__Field::__field4),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"line-cap" =>
                                            _serde::export::Ok(__Field::__field0),
                                            b"line-join" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"line-miter-limit" =>
                                            _serde::export::Ok(__Field::__field2),
                                            b"line-round-limit" =>
                                            _serde::export::Ok(__Field::__field3),
                                            b"visibility" =>
                                            _serde::export::Ok(__Field::__field4),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<LineLayout>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    LineLayout;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct LineLayout")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(self, mut __seq: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::SeqAccess<'de> {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<String>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                 &"struct LineLayout with 5 elements"));
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<String>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                                 &"struct LineLayout with 5 elements"));
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                                 &"struct LineLayout with 5 elements"));
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                                 &"struct LineLayout with 5 elements"));
                                                }
                                            };
                                        let __field4 =
                                            match match _serde::de::SeqAccess::next_element::<Option<Visibility>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                                 &"struct LineLayout with 5 elements"));
                                                }
                                            };
                                        _serde::export::Ok(LineLayout{cap:
                                                                          __field0,
                                                                      join:
                                                                          __field1,
                                                                      miter_limit:
                                                                          __field2,
                                                                      round_limit:
                                                                          __field3,
                                                                      visibility:
                                                                          __field4,})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field0:
                                                _serde::export::Option<Option<StyleProp<String>>> =
                                            _serde::export::None;
                                        let mut __field1:
                                                _serde::export::Option<Option<StyleProp<String>>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field3:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field4:
                                                _serde::export::Option<Option<Visibility>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-cap"));
                                                    }
                                                    __field0 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<String>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-join"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<String>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-miter-limit"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field3 => {
                                                    if _serde::export::Option::is_some(&__field3)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-round-limit"));
                                                    }
                                                    __field3 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field4 => {
                                                    if _serde::export::Option::is_some(&__field4)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("visibility"));
                                                    }
                                                    __field4 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Visibility>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                _ => {
                                                    let _ =
                                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                }
                                            }
                                        }
                                        let __field0 =
                                            match __field0 {
                                                _serde::export::Some(__field0)
                                                => __field0,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-cap")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-join")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-miter-limit")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field3 =
                                            match __field3 {
                                                _serde::export::Some(__field3)
                                                => __field3,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-round-limit")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field4 =
                                            match __field4 {
                                                _serde::export::Some(__field4)
                                                => __field4,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("visibility")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        _serde::export::Ok(LineLayout{cap:
                                                                          __field0,
                                                                      join:
                                                                          __field1,
                                                                      miter_limit:
                                                                          __field2,
                                                                      round_limit:
                                                                          __field3,
                                                                      visibility:
                                                                          __field4,})
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["line-cap", "line-join",
                                      "line-miter-limit", "line-round-limit",
                                      "visibility"];
                                _serde::Deserializer::deserialize_struct(__deserializer,
                                                                         "LineLayout",
                                                                         FIELDS,
                                                                         __Visitor{marker:
                                                                                       _serde::export::PhantomData::<LineLayout>,
                                                                                   lifetime:
                                                                                       _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for LineLayout {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            LineLayout {
                            cap: ref __self_0_0,
                            join: ref __self_0_1,
                            miter_limit: ref __self_0_2,
                            round_limit: ref __self_0_3,
                            visibility: ref __self_0_4 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("LineLayout");
                                let _ =
                                    debug_trait_builder.field("cap",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("join",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("miter_limit",
                                                              &&(*__self_0_2));
                                let _ =
                                    debug_trait_builder.field("round_limit",
                                                              &&(*__self_0_3));
                                let _ =
                                    debug_trait_builder.field("visibility",
                                                              &&(*__self_0_4));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for LineLayout {
                    #[inline]
                    fn clone(&self) -> LineLayout {
                        match *self {
                            LineLayout {
                            cap: ref __self_0_0,
                            join: ref __self_0_1,
                            miter_limit: ref __self_0_2,
                            round_limit: ref __self_0_3,
                            visibility: ref __self_0_4 } =>
                            LineLayout{cap:
                                           ::std::clone::Clone::clone(&(*__self_0_0)),
                                       join:
                                           ::std::clone::Clone::clone(&(*__self_0_1)),
                                       miter_limit:
                                           ::std::clone::Clone::clone(&(*__self_0_2)),
                                       round_limit:
                                           ::std::clone::Clone::clone(&(*__self_0_3)),
                                       visibility:
                                           ::std::clone::Clone::clone(&(*__self_0_4)),},
                        }
                    }
                }
                pub struct LinePaint {
                    #[serde(rename = "line-opacity")]
                    opacity: Option<StyleProp<f32>>,
                    #[serde(rename = "line-color")]
                    color: Option<StyleProp<Color>>,
                    #[serde(rename = "line-translate")]
                    translate: Option<StyleProp<[f32; 2]>>,
                    #[serde(rename = "line-translate-anchor")]
                    translate_anchor: Option<String>,
                    #[serde(rename = "line-width")]
                    width: Option<StyleProp<f32>>,
                    #[serde(rename = "line-gap_width")]
                    gap_width: Option<StyleProp<f32>>,
                    #[serde(rename = "line-offset")]
                    offset: Option<StyleProp<f32>>,
                    #[serde(rename = "line-blur")]
                    blur: Option<StyleProp<f32>>,
                    #[serde(rename = "line-dasharray")]
                    dash_array: Option<StyleProp<Vec<f32>>>,
                    #[serde(rename = "line-pattern")]
                    pattern: Option<StyleProp<String>>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_LinePaint: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for LinePaint {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __field4,
                                    __field5,
                                    __field6,
                                    __field7,
                                    __field8,
                                    __field9,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            0u64 =>
                                            _serde::export::Ok(__Field::__field0),
                                            1u64 =>
                                            _serde::export::Ok(__Field::__field1),
                                            2u64 =>
                                            _serde::export::Ok(__Field::__field2),
                                            3u64 =>
                                            _serde::export::Ok(__Field::__field3),
                                            4u64 =>
                                            _serde::export::Ok(__Field::__field4),
                                            5u64 =>
                                            _serde::export::Ok(__Field::__field5),
                                            6u64 =>
                                            _serde::export::Ok(__Field::__field6),
                                            7u64 =>
                                            _serde::export::Ok(__Field::__field7),
                                            8u64 =>
                                            _serde::export::Ok(__Field::__field8),
                                            9u64 =>
                                            _serde::export::Ok(__Field::__field9),
                                            _ =>
                                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                 &"field index 0 <= i < 10")),
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "line-opacity" =>
                                            _serde::export::Ok(__Field::__field0),
                                            "line-color" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "line-translate" =>
                                            _serde::export::Ok(__Field::__field2),
                                            "line-translate-anchor" =>
                                            _serde::export::Ok(__Field::__field3),
                                            "line-width" =>
                                            _serde::export::Ok(__Field::__field4),
                                            "line-gap_width" =>
                                            _serde::export::Ok(__Field::__field5),
                                            "line-offset" =>
                                            _serde::export::Ok(__Field::__field6),
                                            "line-blur" =>
                                            _serde::export::Ok(__Field::__field7),
                                            "line-dasharray" =>
                                            _serde::export::Ok(__Field::__field8),
                                            "line-pattern" =>
                                            _serde::export::Ok(__Field::__field9),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"line-opacity" =>
                                            _serde::export::Ok(__Field::__field0),
                                            b"line-color" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"line-translate" =>
                                            _serde::export::Ok(__Field::__field2),
                                            b"line-translate-anchor" =>
                                            _serde::export::Ok(__Field::__field3),
                                            b"line-width" =>
                                            _serde::export::Ok(__Field::__field4),
                                            b"line-gap_width" =>
                                            _serde::export::Ok(__Field::__field5),
                                            b"line-offset" =>
                                            _serde::export::Ok(__Field::__field6),
                                            b"line-blur" =>
                                            _serde::export::Ok(__Field::__field7),
                                            b"line-dasharray" =>
                                            _serde::export::Ok(__Field::__field8),
                                            b"line-pattern" =>
                                            _serde::export::Ok(__Field::__field9),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<LinePaint>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    LinePaint;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct LinePaint")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(self, mut __seq: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::SeqAccess<'de> {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<Color>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<[f32; 2]>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field4 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field5 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field6 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field7 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field8 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<Vec<f32>>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(8usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        let __field9 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<String>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(9usize,
                                                                                                                 &"struct LinePaint with 10 elements"));
                                                }
                                            };
                                        _serde::export::Ok(LinePaint{opacity:
                                                                         __field0,
                                                                     color:
                                                                         __field1,
                                                                     translate:
                                                                         __field2,
                                                                     translate_anchor:
                                                                         __field3,
                                                                     width:
                                                                         __field4,
                                                                     gap_width:
                                                                         __field5,
                                                                     offset:
                                                                         __field6,
                                                                     blur:
                                                                         __field7,
                                                                     dash_array:
                                                                         __field8,
                                                                     pattern:
                                                                         __field9,})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field0:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field1:
                                                _serde::export::Option<Option<StyleProp<Color>>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<Option<StyleProp<[f32; 2]>>> =
                                            _serde::export::None;
                                        let mut __field3:
                                                _serde::export::Option<Option<String>> =
                                            _serde::export::None;
                                        let mut __field4:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field5:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field6:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field7:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field8:
                                                _serde::export::Option<Option<StyleProp<Vec<f32>>>> =
                                            _serde::export::None;
                                        let mut __field9:
                                                _serde::export::Option<Option<StyleProp<String>>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-opacity"));
                                                    }
                                                    __field0 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-color"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<Color>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-translate"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<[f32; 2]>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field3 => {
                                                    if _serde::export::Option::is_some(&__field3)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-translate-anchor"));
                                                    }
                                                    __field3 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field4 => {
                                                    if _serde::export::Option::is_some(&__field4)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-width"));
                                                    }
                                                    __field4 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field5 => {
                                                    if _serde::export::Option::is_some(&__field5)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-gap_width"));
                                                    }
                                                    __field5 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field6 => {
                                                    if _serde::export::Option::is_some(&__field6)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-offset"));
                                                    }
                                                    __field6 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field7 => {
                                                    if _serde::export::Option::is_some(&__field7)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-blur"));
                                                    }
                                                    __field7 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field8 => {
                                                    if _serde::export::Option::is_some(&__field8)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-dasharray"));
                                                    }
                                                    __field8 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<Vec<f32>>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field9 => {
                                                    if _serde::export::Option::is_some(&__field9)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("line-pattern"));
                                                    }
                                                    __field9 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<String>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                _ => {
                                                    let _ =
                                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                }
                                            }
                                        }
                                        let __field0 =
                                            match __field0 {
                                                _serde::export::Some(__field0)
                                                => __field0,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-opacity")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-color")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-translate")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field3 =
                                            match __field3 {
                                                _serde::export::Some(__field3)
                                                => __field3,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-translate-anchor")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field4 =
                                            match __field4 {
                                                _serde::export::Some(__field4)
                                                => __field4,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-width")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field5 =
                                            match __field5 {
                                                _serde::export::Some(__field5)
                                                => __field5,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-gap_width")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field6 =
                                            match __field6 {
                                                _serde::export::Some(__field6)
                                                => __field6,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-offset")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field7 =
                                            match __field7 {
                                                _serde::export::Some(__field7)
                                                => __field7,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-blur")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field8 =
                                            match __field8 {
                                                _serde::export::Some(__field8)
                                                => __field8,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-dasharray")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field9 =
                                            match __field9 {
                                                _serde::export::Some(__field9)
                                                => __field9,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("line-pattern")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        _serde::export::Ok(LinePaint{opacity:
                                                                         __field0,
                                                                     color:
                                                                         __field1,
                                                                     translate:
                                                                         __field2,
                                                                     translate_anchor:
                                                                         __field3,
                                                                     width:
                                                                         __field4,
                                                                     gap_width:
                                                                         __field5,
                                                                     offset:
                                                                         __field6,
                                                                     blur:
                                                                         __field7,
                                                                     dash_array:
                                                                         __field8,
                                                                     pattern:
                                                                         __field9,})
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["line-opacity", "line-color",
                                      "line-translate",
                                      "line-translate-anchor", "line-width",
                                      "line-gap_width", "line-offset",
                                      "line-blur", "line-dasharray",
                                      "line-pattern"];
                                _serde::Deserializer::deserialize_struct(__deserializer,
                                                                         "LinePaint",
                                                                         FIELDS,
                                                                         __Visitor{marker:
                                                                                       _serde::export::PhantomData::<LinePaint>,
                                                                                   lifetime:
                                                                                       _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for LinePaint {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            LinePaint {
                            opacity: ref __self_0_0,
                            color: ref __self_0_1,
                            translate: ref __self_0_2,
                            translate_anchor: ref __self_0_3,
                            width: ref __self_0_4,
                            gap_width: ref __self_0_5,
                            offset: ref __self_0_6,
                            blur: ref __self_0_7,
                            dash_array: ref __self_0_8,
                            pattern: ref __self_0_9 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("LinePaint");
                                let _ =
                                    debug_trait_builder.field("opacity",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("color",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("translate",
                                                              &&(*__self_0_2));
                                let _ =
                                    debug_trait_builder.field("translate_anchor",
                                                              &&(*__self_0_3));
                                let _ =
                                    debug_trait_builder.field("width",
                                                              &&(*__self_0_4));
                                let _ =
                                    debug_trait_builder.field("gap_width",
                                                              &&(*__self_0_5));
                                let _ =
                                    debug_trait_builder.field("offset",
                                                              &&(*__self_0_6));
                                let _ =
                                    debug_trait_builder.field("blur",
                                                              &&(*__self_0_7));
                                let _ =
                                    debug_trait_builder.field("dash_array",
                                                              &&(*__self_0_8));
                                let _ =
                                    debug_trait_builder.field("pattern",
                                                              &&(*__self_0_9));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for LinePaint {
                    #[inline]
                    fn clone(&self) -> LinePaint {
                        match *self {
                            LinePaint {
                            opacity: ref __self_0_0,
                            color: ref __self_0_1,
                            translate: ref __self_0_2,
                            translate_anchor: ref __self_0_3,
                            width: ref __self_0_4,
                            gap_width: ref __self_0_5,
                            offset: ref __self_0_6,
                            blur: ref __self_0_7,
                            dash_array: ref __self_0_8,
                            pattern: ref __self_0_9 } =>
                            LinePaint{opacity:
                                          ::std::clone::Clone::clone(&(*__self_0_0)),
                                      color:
                                          ::std::clone::Clone::clone(&(*__self_0_1)),
                                      translate:
                                          ::std::clone::Clone::clone(&(*__self_0_2)),
                                      translate_anchor:
                                          ::std::clone::Clone::clone(&(*__self_0_3)),
                                      width:
                                          ::std::clone::Clone::clone(&(*__self_0_4)),
                                      gap_width:
                                          ::std::clone::Clone::clone(&(*__self_0_5)),
                                      offset:
                                          ::std::clone::Clone::clone(&(*__self_0_6)),
                                      blur:
                                          ::std::clone::Clone::clone(&(*__self_0_7)),
                                      dash_array:
                                          ::std::clone::Clone::clone(&(*__self_0_8)),
                                      pattern:
                                          ::std::clone::Clone::clone(&(*__self_0_9)),},
                        }
                    }
                }
            }
            pub mod raster {
                use prelude::*;
                use super::{LayerCommon, BaseLayout, Visibility, StyleProp};
                pub struct RasterLayer {
                    #[serde(flatten)]
                    pub common: LayerCommon,
                    #[serde(default = "BaseLayout::default")]
                    pub layout: BaseLayout,
                    pub paint: Option<RasterPaint>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_RasterLayer: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for RasterLayer {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field<'de> {
                                    __field1,
                                    __field2,
                                    __other(_serde::private::de::Content<'de>),
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field<'de>;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_bool<__E>(self, __value: bool)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))
                                    }
                                    fn visit_i8<__E>(self, __value: i8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))
                                    }
                                    fn visit_i16<__E>(self, __value: i16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))
                                    }
                                    fn visit_i32<__E>(self, __value: i32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))
                                    }
                                    fn visit_i64<__E>(self, __value: i64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))
                                    }
                                    fn visit_u8<__E>(self, __value: u8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))
                                    }
                                    fn visit_u16<__E>(self, __value: u16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))
                                    }
                                    fn visit_u32<__E>(self, __value: u32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))
                                    }
                                    fn visit_f32<__E>(self, __value: f32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))
                                    }
                                    fn visit_f64<__E>(self, __value: f64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))
                                    }
                                    fn visit_char<__E>(self, __value: char)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))
                                    }
                                    fn visit_unit<__E>(self)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))
                                    }
                                    fn visit_borrowed_str<__E>(self,
                                                               __value:
                                                                   &'de str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Str(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_borrowed_bytes<__E>(self,
                                                                 __value:
                                                                     &'de [u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Bytes(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::String(__value.to_string());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::ByteBuf(__value.to_vec());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field<'de> {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<RasterLayer>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    RasterLayer;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct RasterLayer")
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field1:
                                                _serde::export::Option<BaseLayout> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<Option<RasterPaint>> =
                                            _serde::export::None;
                                        let mut __collect =
                                            _serde::export::Vec::<_serde::export::Option<(_serde::private::de::Content,
                                                                                          _serde::private::de::Content)>>::new();
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("layout"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<BaseLayout>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("paint"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<RasterPaint>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__other(__name) => {
                                                    __collect.push(_serde::export::Some((__name,
                                                                                         match _serde::de::MapAccess::next_value(&mut __map)
                                                                                             {
                                                                                             _serde::export::Ok(__val)
                                                                                             =>
                                                                                             __val,
                                                                                             _serde::export::Err(__err)
                                                                                             =>
                                                                                             {
                                                                                                 return _serde::export::Err(__err);
                                                                                             }
                                                                                         })));
                                                }
                                            }
                                        }
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                BaseLayout::default(),
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("paint")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field0: LayerCommon =
                                            match _serde::de::Deserialize::deserialize(_serde::private::de::FlatMapDeserializer(&mut __collect,
                                                                                                                                _serde::export::PhantomData))
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        _serde::export::Ok(RasterLayer{common:
                                                                           __field0,
                                                                       layout:
                                                                           __field1,
                                                                       paint:
                                                                           __field2,})
                                    }
                                }
                                _serde::Deserializer::deserialize_map(__deserializer,
                                                                      __Visitor{marker:
                                                                                    _serde::export::PhantomData::<RasterLayer>,
                                                                                lifetime:
                                                                                    _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for RasterLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            RasterLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("RasterLayer");
                                let _ =
                                    debug_trait_builder.field("common",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("layout",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("paint",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for RasterLayer {
                    #[inline]
                    fn clone(&self) -> RasterLayer {
                        match *self {
                            RasterLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } =>
                            RasterLayer{common:
                                            ::std::clone::Clone::clone(&(*__self_0_0)),
                                        layout:
                                            ::std::clone::Clone::clone(&(*__self_0_1)),
                                        paint:
                                            ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                pub struct RasterPaint {
                    #[serde(rename = "raster-opacity")]
                    opacity: Option<StyleProp<f32>>,
                    #[serde(rename = "raster-hue-rotate")]
                    hue_rotate: Option<StyleProp<f32>>,
                    #[serde(rename = "raster-brightness-min")]
                    brightness_min: Option<StyleProp<f32>>,
                    #[serde(rename = "raster-brightness-max")]
                    brightness_max: Option<StyleProp<f32>>,
                    #[serde(rename = "raster-saturation")]
                    saturation: Option<StyleProp<f32>>,
                    #[serde(rename = "raster-contrast")]
                    contrast: Option<StyleProp<f32>>,
                    #[serde(rename = "raster-fade-duration")]
                    fade_duration: Option<StyleProp<f32>>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_RasterPaint: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for RasterPaint {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __field4,
                                    __field5,
                                    __field6,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            0u64 =>
                                            _serde::export::Ok(__Field::__field0),
                                            1u64 =>
                                            _serde::export::Ok(__Field::__field1),
                                            2u64 =>
                                            _serde::export::Ok(__Field::__field2),
                                            3u64 =>
                                            _serde::export::Ok(__Field::__field3),
                                            4u64 =>
                                            _serde::export::Ok(__Field::__field4),
                                            5u64 =>
                                            _serde::export::Ok(__Field::__field5),
                                            6u64 =>
                                            _serde::export::Ok(__Field::__field6),
                                            _ =>
                                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                 &"field index 0 <= i < 7")),
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "raster-opacity" =>
                                            _serde::export::Ok(__Field::__field0),
                                            "raster-hue-rotate" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "raster-brightness-min" =>
                                            _serde::export::Ok(__Field::__field2),
                                            "raster-brightness-max" =>
                                            _serde::export::Ok(__Field::__field3),
                                            "raster-saturation" =>
                                            _serde::export::Ok(__Field::__field4),
                                            "raster-contrast" =>
                                            _serde::export::Ok(__Field::__field5),
                                            "raster-fade-duration" =>
                                            _serde::export::Ok(__Field::__field6),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"raster-opacity" =>
                                            _serde::export::Ok(__Field::__field0),
                                            b"raster-hue-rotate" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"raster-brightness-min" =>
                                            _serde::export::Ok(__Field::__field2),
                                            b"raster-brightness-max" =>
                                            _serde::export::Ok(__Field::__field3),
                                            b"raster-saturation" =>
                                            _serde::export::Ok(__Field::__field4),
                                            b"raster-contrast" =>
                                            _serde::export::Ok(__Field::__field5),
                                            b"raster-fade-duration" =>
                                            _serde::export::Ok(__Field::__field6),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<RasterPaint>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    RasterPaint;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct RasterPaint")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(self, mut __seq: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::SeqAccess<'de> {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                 &"struct RasterPaint with 7 elements"));
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                                 &"struct RasterPaint with 7 elements"));
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                                 &"struct RasterPaint with 7 elements"));
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                                 &"struct RasterPaint with 7 elements"));
                                                }
                                            };
                                        let __field4 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                                 &"struct RasterPaint with 7 elements"));
                                                }
                                            };
                                        let __field5 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                                 &"struct RasterPaint with 7 elements"));
                                                }
                                            };
                                        let __field6 =
                                            match match _serde::de::SeqAccess::next_element::<Option<StyleProp<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                                 &"struct RasterPaint with 7 elements"));
                                                }
                                            };
                                        _serde::export::Ok(RasterPaint{opacity:
                                                                           __field0,
                                                                       hue_rotate:
                                                                           __field1,
                                                                       brightness_min:
                                                                           __field2,
                                                                       brightness_max:
                                                                           __field3,
                                                                       saturation:
                                                                           __field4,
                                                                       contrast:
                                                                           __field5,
                                                                       fade_duration:
                                                                           __field6,})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field0:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field1:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field3:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field4:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field5:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        let mut __field6:
                                                _serde::export::Option<Option<StyleProp<f32>>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("raster-opacity"));
                                                    }
                                                    __field0 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("raster-hue-rotate"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("raster-brightness-min"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field3 => {
                                                    if _serde::export::Option::is_some(&__field3)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("raster-brightness-max"));
                                                    }
                                                    __field3 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field4 => {
                                                    if _serde::export::Option::is_some(&__field4)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("raster-saturation"));
                                                    }
                                                    __field4 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field5 => {
                                                    if _serde::export::Option::is_some(&__field5)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("raster-contrast"));
                                                    }
                                                    __field5 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field6 => {
                                                    if _serde::export::Option::is_some(&__field6)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("raster-fade-duration"));
                                                    }
                                                    __field6 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<StyleProp<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                _ => {
                                                    let _ =
                                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                }
                                            }
                                        }
                                        let __field0 =
                                            match __field0 {
                                                _serde::export::Some(__field0)
                                                => __field0,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("raster-opacity")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("raster-hue-rotate")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("raster-brightness-min")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field3 =
                                            match __field3 {
                                                _serde::export::Some(__field3)
                                                => __field3,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("raster-brightness-max")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field4 =
                                            match __field4 {
                                                _serde::export::Some(__field4)
                                                => __field4,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("raster-saturation")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field5 =
                                            match __field5 {
                                                _serde::export::Some(__field5)
                                                => __field5,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("raster-contrast")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field6 =
                                            match __field6 {
                                                _serde::export::Some(__field6)
                                                => __field6,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("raster-fade-duration")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        _serde::export::Ok(RasterPaint{opacity:
                                                                           __field0,
                                                                       hue_rotate:
                                                                           __field1,
                                                                       brightness_min:
                                                                           __field2,
                                                                       brightness_max:
                                                                           __field3,
                                                                       saturation:
                                                                           __field4,
                                                                       contrast:
                                                                           __field5,
                                                                       fade_duration:
                                                                           __field6,})
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["raster-opacity", "raster-hue-rotate",
                                      "raster-brightness-min",
                                      "raster-brightness-max",
                                      "raster-saturation", "raster-contrast",
                                      "raster-fade-duration"];
                                _serde::Deserializer::deserialize_struct(__deserializer,
                                                                         "RasterPaint",
                                                                         FIELDS,
                                                                         __Visitor{marker:
                                                                                       _serde::export::PhantomData::<RasterPaint>,
                                                                                   lifetime:
                                                                                       _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for RasterPaint {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            RasterPaint {
                            opacity: ref __self_0_0,
                            hue_rotate: ref __self_0_1,
                            brightness_min: ref __self_0_2,
                            brightness_max: ref __self_0_3,
                            saturation: ref __self_0_4,
                            contrast: ref __self_0_5,
                            fade_duration: ref __self_0_6 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("RasterPaint");
                                let _ =
                                    debug_trait_builder.field("opacity",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("hue_rotate",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("brightness_min",
                                                              &&(*__self_0_2));
                                let _ =
                                    debug_trait_builder.field("brightness_max",
                                                              &&(*__self_0_3));
                                let _ =
                                    debug_trait_builder.field("saturation",
                                                              &&(*__self_0_4));
                                let _ =
                                    debug_trait_builder.field("contrast",
                                                              &&(*__self_0_5));
                                let _ =
                                    debug_trait_builder.field("fade_duration",
                                                              &&(*__self_0_6));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for RasterPaint {
                    #[inline]
                    fn clone(&self) -> RasterPaint {
                        match *self {
                            RasterPaint {
                            opacity: ref __self_0_0,
                            hue_rotate: ref __self_0_1,
                            brightness_min: ref __self_0_2,
                            brightness_max: ref __self_0_3,
                            saturation: ref __self_0_4,
                            contrast: ref __self_0_5,
                            fade_duration: ref __self_0_6 } =>
                            RasterPaint{opacity:
                                            ::std::clone::Clone::clone(&(*__self_0_0)),
                                        hue_rotate:
                                            ::std::clone::Clone::clone(&(*__self_0_1)),
                                        brightness_min:
                                            ::std::clone::Clone::clone(&(*__self_0_2)),
                                        brightness_max:
                                            ::std::clone::Clone::clone(&(*__self_0_3)),
                                        saturation:
                                            ::std::clone::Clone::clone(&(*__self_0_4)),
                                        contrast:
                                            ::std::clone::Clone::clone(&(*__self_0_5)),
                                        fade_duration:
                                            ::std::clone::Clone::clone(&(*__self_0_6)),},
                        }
                    }
                }
            }
            pub mod symbol {
                use prelude::*;
                use super::{LayerCommon, BaseLayout, Visibility, StyleProp};
                pub struct SymbolLayer {
                    #[serde(flatten)]
                    pub common: LayerCommon,
                    pub layout: Option<SymbolLayout>,
                    pub paint: Option<SymbolPaint>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_SymbolLayer: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for SymbolLayer {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field<'de> {
                                    __field1,
                                    __field2,
                                    __other(_serde::private::de::Content<'de>),
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field<'de>;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_bool<__E>(self, __value: bool)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))
                                    }
                                    fn visit_i8<__E>(self, __value: i8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))
                                    }
                                    fn visit_i16<__E>(self, __value: i16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))
                                    }
                                    fn visit_i32<__E>(self, __value: i32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))
                                    }
                                    fn visit_i64<__E>(self, __value: i64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))
                                    }
                                    fn visit_u8<__E>(self, __value: u8)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))
                                    }
                                    fn visit_u16<__E>(self, __value: u16)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))
                                    }
                                    fn visit_u32<__E>(self, __value: u32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))
                                    }
                                    fn visit_f32<__E>(self, __value: f32)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))
                                    }
                                    fn visit_f64<__E>(self, __value: f64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))
                                    }
                                    fn visit_char<__E>(self, __value: char)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))
                                    }
                                    fn visit_unit<__E>(self)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))
                                    }
                                    fn visit_borrowed_str<__E>(self,
                                                               __value:
                                                                   &'de str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Str(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_borrowed_bytes<__E>(self,
                                                                 __value:
                                                                     &'de [u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::Bytes(__value);
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::String(__value.to_string());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"layout" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"paint" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                let __value =
                                                    _serde::private::de::Content::ByteBuf(__value.to_vec());
                                                _serde::export::Ok(__Field::__other(__value))
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field<'de> {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<SymbolLayer>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    SymbolLayer;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct SymbolLayer")
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field1:
                                                _serde::export::Option<Option<SymbolLayout>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<Option<SymbolPaint>> =
                                            _serde::export::None;
                                        let mut __collect =
                                            _serde::export::Vec::<_serde::export::Option<(_serde::private::de::Content,
                                                                                          _serde::private::de::Content)>>::new();
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("layout"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<SymbolLayout>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("paint"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<SymbolPaint>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__other(__name) => {
                                                    __collect.push(_serde::export::Some((__name,
                                                                                         match _serde::de::MapAccess::next_value(&mut __map)
                                                                                             {
                                                                                             _serde::export::Ok(__val)
                                                                                             =>
                                                                                             __val,
                                                                                             _serde::export::Err(__err)
                                                                                             =>
                                                                                             {
                                                                                                 return _serde::export::Err(__err);
                                                                                             }
                                                                                         })));
                                                }
                                            }
                                        }
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("layout")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("paint")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        let __field0: LayerCommon =
                                            match _serde::de::Deserialize::deserialize(_serde::private::de::FlatMapDeserializer(&mut __collect,
                                                                                                                                _serde::export::PhantomData))
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        _serde::export::Ok(SymbolLayer{common:
                                                                           __field0,
                                                                       layout:
                                                                           __field1,
                                                                       paint:
                                                                           __field2,})
                                    }
                                }
                                _serde::Deserializer::deserialize_map(__deserializer,
                                                                      __Visitor{marker:
                                                                                    _serde::export::PhantomData::<SymbolLayer>,
                                                                                lifetime:
                                                                                    _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for SymbolLayer {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            SymbolLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("SymbolLayer");
                                let _ =
                                    debug_trait_builder.field("common",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("layout",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("paint",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for SymbolLayer {
                    #[inline]
                    fn clone(&self) -> SymbolLayer {
                        match *self {
                            SymbolLayer {
                            common: ref __self_0_0,
                            layout: ref __self_0_1,
                            paint: ref __self_0_2 } =>
                            SymbolLayer{common:
                                            ::std::clone::Clone::clone(&(*__self_0_0)),
                                        layout:
                                            ::std::clone::Clone::clone(&(*__self_0_1)),
                                        paint:
                                            ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                pub struct SymbolLayout {
                    #[serde(default, rename = "symbol-placement")]
                    placement: StyleProp<Option<String>>,
                    #[serde(default, rename = "symbol-spacing")]
                    spacing: StyleProp<Option<f32>>,
                    #[serde(rename = "symbol-avoid-edges")]
                    avoid_edges: Option<bool>,
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_SymbolLayout: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for SymbolLayout {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            0u64 =>
                                            _serde::export::Ok(__Field::__field0),
                                            1u64 =>
                                            _serde::export::Ok(__Field::__field1),
                                            2u64 =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ =>
                                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                 &"field index 0 <= i < 3")),
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            "symbol-placement" =>
                                            _serde::export::Ok(__Field::__field0),
                                            "symbol-spacing" =>
                                            _serde::export::Ok(__Field::__field1),
                                            "symbol-avoid-edges" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            b"symbol-placement" =>
                                            _serde::export::Ok(__Field::__field0),
                                            b"symbol-spacing" =>
                                            _serde::export::Ok(__Field::__field1),
                                            b"symbol-avoid-edges" =>
                                            _serde::export::Ok(__Field::__field2),
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<SymbolLayout>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    SymbolLayout;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct SymbolLayout")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(self, mut __seq: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::SeqAccess<'de> {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Option<String>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                                 &"struct SymbolLayout with 3 elements"));
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<StyleProp<Option<f32>>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                                 &"struct SymbolLayout with 3 elements"));
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<Option<bool>>(&mut __seq)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                                _serde::export::Some(__value)
                                                => __value,
                                                _serde::export::None => {
                                                    return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                                 &"struct SymbolLayout with 3 elements"));
                                                }
                                            };
                                        _serde::export::Ok(SymbolLayout{placement:
                                                                            __field0,
                                                                        spacing:
                                                                            __field1,
                                                                        avoid_edges:
                                                                            __field2,})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        let mut __field0:
                                                _serde::export::Option<StyleProp<Option<String>>> =
                                            _serde::export::None;
                                        let mut __field1:
                                                _serde::export::Option<StyleProp<Option<f32>>> =
                                            _serde::export::None;
                                        let mut __field2:
                                                _serde::export::Option<Option<bool>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("symbol-placement"));
                                                    }
                                                    __field0 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Option<String>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("symbol-spacing"));
                                                    }
                                                    __field1 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<Option<f32>>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2)
                                                       {
                                                        return _serde::export::Err(<__A::Error
                                                                                       as
                                                                                       _serde::de::Error>::duplicate_field("symbol-avoid-edges"));
                                                    }
                                                    __field2 =
                                                        _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<bool>>(&mut __map)
                                                                                 {
                                                                                 _serde::export::Ok(__val)
                                                                                 =>
                                                                                 __val,
                                                                                 _serde::export::Err(__err)
                                                                                 =>
                                                                                 {
                                                                                     return _serde::export::Err(__err);
                                                                                 }
                                                                             });
                                                }
                                                _ => {
                                                    let _ =
                                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                }
                                            }
                                        }
                                        let __field0 =
                                            match __field0 {
                                                _serde::export::Some(__field0)
                                                => __field0,
                                                _serde::export::None =>
                                                _serde::export::Default::default(),
                                            };
                                        let __field1 =
                                            match __field1 {
                                                _serde::export::Some(__field1)
                                                => __field1,
                                                _serde::export::None =>
                                                _serde::export::Default::default(),
                                            };
                                        let __field2 =
                                            match __field2 {
                                                _serde::export::Some(__field2)
                                                => __field2,
                                                _serde::export::None =>
                                                match _serde::private::de::missing_field("symbol-avoid-edges")
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            };
                                        _serde::export::Ok(SymbolLayout{placement:
                                                                            __field0,
                                                                        spacing:
                                                                            __field1,
                                                                        avoid_edges:
                                                                            __field2,})
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["symbol-placement", "symbol-spacing",
                                      "symbol-avoid-edges"];
                                _serde::Deserializer::deserialize_struct(__deserializer,
                                                                         "SymbolLayout",
                                                                         FIELDS,
                                                                         __Visitor{marker:
                                                                                       _serde::export::PhantomData::<SymbolLayout>,
                                                                                   lifetime:
                                                                                       _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for SymbolLayout {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            SymbolLayout {
                            placement: ref __self_0_0,
                            spacing: ref __self_0_1,
                            avoid_edges: ref __self_0_2 } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("SymbolLayout");
                                let _ =
                                    debug_trait_builder.field("placement",
                                                              &&(*__self_0_0));
                                let _ =
                                    debug_trait_builder.field("spacing",
                                                              &&(*__self_0_1));
                                let _ =
                                    debug_trait_builder.field("avoid_edges",
                                                              &&(*__self_0_2));
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for SymbolLayout {
                    #[inline]
                    fn clone(&self) -> SymbolLayout {
                        match *self {
                            SymbolLayout {
                            placement: ref __self_0_0,
                            spacing: ref __self_0_1,
                            avoid_edges: ref __self_0_2 } =>
                            SymbolLayout{placement:
                                             ::std::clone::Clone::clone(&(*__self_0_0)),
                                         spacing:
                                             ::std::clone::Clone::clone(&(*__self_0_1)),
                                         avoid_edges:
                                             ::std::clone::Clone::clone(&(*__self_0_2)),},
                        }
                    }
                }
                pub struct SymbolPaint {
                }
                #[allow(non_upper_case_globals,
                        unused_attributes,
                        unused_qualifications)]
                const _IMPL_DESERIALIZE_FOR_SymbolPaint: () =
                    {
                        #[allow(unknown_lints)]
                        #[allow(rust_2018_idioms)]
                        extern crate serde as _serde;
                        #[allow(unused_macros)]
                        macro_rules! try(( $ __expr : expr ) => {
                                         match $ __expr {
                                         _serde :: export :: Ok ( __val ) =>
                                         __val , _serde :: export :: Err (
                                         __err ) => {
                                         return _serde :: export :: Err (
                                         __err ) ; } } });
                        #[automatically_derived]
                        impl <'de> _serde::Deserialize<'de> for SymbolPaint {
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                #[allow(non_camel_case_types)]
                                enum __Field { __ignore, }
                                struct __FieldVisitor;
                                impl <'de> _serde::de::Visitor<'de> for
                                 __FieldVisitor {
                                    type
                                    Value
                                    =
                                    __Field;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "field identifier")
                                    }
                                    fn visit_u64<__E>(self, __value: u64)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            _ =>
                                            _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                                 &"field index 0 <= i < 0")),
                                        }
                                    }
                                    fn visit_str<__E>(self, __value: &str)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                    fn visit_bytes<__E>(self, __value: &[u8])
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __E> where
                                     __E: _serde::de::Error {
                                        match __value {
                                            _ => {
                                                _serde::export::Ok(__Field::__ignore)
                                            }
                                        }
                                    }
                                }
                                impl <'de> _serde::Deserialize<'de> for
                                 __Field {
                                    #[inline]
                                    fn deserialize<__D>(__deserializer: __D)
                                     ->
                                         _serde::export::Result<Self,
                                                                __D::Error>
                                     where __D: _serde::Deserializer<'de> {
                                        _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                     __FieldVisitor)
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<SymbolPaint>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl <'de> _serde::de::Visitor<'de> for
                                 __Visitor<'de> {
                                    type
                                    Value
                                    =
                                    SymbolPaint;
                                    fn expecting(&self,
                                                 __formatter:
                                                     &mut _serde::export::Formatter)
                                     -> _serde::export::fmt::Result {
                                        _serde::export::Formatter::write_str(__formatter,
                                                                             "struct SymbolPaint")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(self, _: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::SeqAccess<'de> {
                                        _serde::export::Ok(SymbolPaint{})
                                    }
                                    #[inline]
                                    fn visit_map<__A>(self, mut __map: __A)
                                     ->
                                         _serde::export::Result<Self::Value,
                                                                __A::Error>
                                     where __A: _serde::de::MapAccess<'de> {
                                        while let _serde::export::Some(__key)
                                                  =
                                                  match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                      {
                                                      _serde::export::Ok(__val)
                                                      => __val,
                                                      _serde::export::Err(__err)
                                                      => {
                                                          return _serde::export::Err(__err);
                                                      }
                                                  } {
                                            match __key {
                                                _ => {
                                                    let _ =
                                                        match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                            {
                                                            _serde::export::Ok(__val)
                                                            => __val,
                                                            _serde::export::Err(__err)
                                                            => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        };
                                                }
                                            }
                                        }
                                        _serde::export::Ok(SymbolPaint{})
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[];
                                _serde::Deserializer::deserialize_struct(__deserializer,
                                                                         "SymbolPaint",
                                                                         FIELDS,
                                                                         __Visitor{marker:
                                                                                       _serde::export::PhantomData::<SymbolPaint>,
                                                                                   lifetime:
                                                                                       _serde::export::PhantomData,})
                            }
                        }
                    };
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::fmt::Debug for SymbolPaint {
                    fn fmt(&self, f: &mut ::std::fmt::Formatter)
                     -> ::std::fmt::Result {
                        match *self {
                            SymbolPaint {  } => {
                                let mut debug_trait_builder =
                                    f.debug_struct("SymbolPaint");
                                debug_trait_builder.finish()
                            }
                        }
                    }
                }
                #[automatically_derived]
                #[allow(unused_qualifications)]
                impl ::std::clone::Clone for SymbolPaint {
                    #[inline]
                    fn clone(&self) -> SymbolPaint {
                        match *self { SymbolPaint {  } => SymbolPaint{}, }
                    }
                }
            }
            pub use self::background::*;
            pub use self::fill::*;
            pub use self::line::*;
            pub use self::raster::*;
            pub use self::symbol::*;
            use super::filter::Filter;
            pub struct LayerCommon {
                pub id: String,
                pub source: Option<String>,
                #[serde(rename = "source-layer")]
                pub source_layer: Option<String>,
                pub minzoom: Option<f32>,
                pub maxzoom: Option<f32>,
                pub filter: Option<Filter>,
            }
            #[allow(non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications)]
            const _IMPL_DESERIALIZE_FOR_LayerCommon: () =
                {
                    #[allow(unknown_lints)]
                    #[allow(rust_2018_idioms)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try(( $ __expr : expr ) => {
                                     match $ __expr {
                                     _serde :: export :: Ok ( __val ) => __val
                                     , _serde :: export :: Err ( __err ) => {
                                     return _serde :: export :: Err ( __err )
                                     ; } } });
                    #[automatically_derived]
                    impl <'de> _serde::Deserialize<'de> for LayerCommon {
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            #[allow(non_camel_case_types)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __field3,
                                __field4,
                                __field5,
                                __ignore,
                            }
                            struct __FieldVisitor;
                            impl <'de> _serde::de::Visitor<'de> for
                             __FieldVisitor {
                                type
                                Value
                                =
                                __Field;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "field identifier")
                                }
                                fn visit_u64<__E>(self, __value: u64)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        0u64 =>
                                        _serde::export::Ok(__Field::__field0),
                                        1u64 =>
                                        _serde::export::Ok(__Field::__field1),
                                        2u64 =>
                                        _serde::export::Ok(__Field::__field2),
                                        3u64 =>
                                        _serde::export::Ok(__Field::__field3),
                                        4u64 =>
                                        _serde::export::Ok(__Field::__field4),
                                        5u64 =>
                                        _serde::export::Ok(__Field::__field5),
                                        _ =>
                                        _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                             &"field index 0 <= i < 6")),
                                    }
                                }
                                fn visit_str<__E>(self, __value: &str)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        "id" =>
                                        _serde::export::Ok(__Field::__field0),
                                        "source" =>
                                        _serde::export::Ok(__Field::__field1),
                                        "source-layer" =>
                                        _serde::export::Ok(__Field::__field2),
                                        "minzoom" =>
                                        _serde::export::Ok(__Field::__field3),
                                        "maxzoom" =>
                                        _serde::export::Ok(__Field::__field4),
                                        "filter" =>
                                        _serde::export::Ok(__Field::__field5),
                                        _ => {
                                            _serde::export::Ok(__Field::__ignore)
                                        }
                                    }
                                }
                                fn visit_bytes<__E>(self, __value: &[u8])
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        b"id" =>
                                        _serde::export::Ok(__Field::__field0),
                                        b"source" =>
                                        _serde::export::Ok(__Field::__field1),
                                        b"source-layer" =>
                                        _serde::export::Ok(__Field::__field2),
                                        b"minzoom" =>
                                        _serde::export::Ok(__Field::__field3),
                                        b"maxzoom" =>
                                        _serde::export::Ok(__Field::__field4),
                                        b"filter" =>
                                        _serde::export::Ok(__Field::__field5),
                                        _ => {
                                            _serde::export::Ok(__Field::__ignore)
                                        }
                                    }
                                }
                            }
                            impl <'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(__deserializer: __D)
                                 -> _serde::export::Result<Self, __D::Error>
                                 where __D: _serde::Deserializer<'de> {
                                    _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                 __FieldVisitor)
                                }
                            }
                            struct __Visitor<'de> {
                                marker: _serde::export::PhantomData<LayerCommon>,
                                lifetime: _serde::export::PhantomData<&'de ()>,
                            }
                            impl <'de> _serde::de::Visitor<'de> for
                             __Visitor<'de> {
                                type
                                Value
                                =
                                LayerCommon;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "struct LayerCommon")
                                }
                                #[inline]
                                fn visit_seq<__A>(self, mut __seq: __A)
                                 ->
                                     _serde::export::Result<Self::Value,
                                                            __A::Error> where
                                 __A: _serde::de::SeqAccess<'de> {
                                    let __field0 =
                                        match match _serde::de::SeqAccess::next_element::<String>(&mut __seq)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                            _serde::export::Some(__value) =>
                                            __value,
                                            _serde::export::None => {
                                                return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                             &"struct LayerCommon with 6 elements"));
                                            }
                                        };
                                    let __field1 =
                                        match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                            _serde::export::Some(__value) =>
                                            __value,
                                            _serde::export::None => {
                                                return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                             &"struct LayerCommon with 6 elements"));
                                            }
                                        };
                                    let __field2 =
                                        match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                            _serde::export::Some(__value) =>
                                            __value,
                                            _serde::export::None => {
                                                return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                             &"struct LayerCommon with 6 elements"));
                                            }
                                        };
                                    let __field3 =
                                        match match _serde::de::SeqAccess::next_element::<Option<f32>>(&mut __seq)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                            _serde::export::Some(__value) =>
                                            __value,
                                            _serde::export::None => {
                                                return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                             &"struct LayerCommon with 6 elements"));
                                            }
                                        };
                                    let __field4 =
                                        match match _serde::de::SeqAccess::next_element::<Option<f32>>(&mut __seq)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                            _serde::export::Some(__value) =>
                                            __value,
                                            _serde::export::None => {
                                                return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                             &"struct LayerCommon with 6 elements"));
                                            }
                                        };
                                    let __field5 =
                                        match match _serde::de::SeqAccess::next_element::<Option<Filter>>(&mut __seq)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                            _serde::export::Some(__value) =>
                                            __value,
                                            _serde::export::None => {
                                                return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                             &"struct LayerCommon with 6 elements"));
                                            }
                                        };
                                    _serde::export::Ok(LayerCommon{id:
                                                                       __field0,
                                                                   source:
                                                                       __field1,
                                                                   source_layer:
                                                                       __field2,
                                                                   minzoom:
                                                                       __field3,
                                                                   maxzoom:
                                                                       __field4,
                                                                   filter:
                                                                       __field5,})
                                }
                                #[inline]
                                fn visit_map<__A>(self, mut __map: __A)
                                 ->
                                     _serde::export::Result<Self::Value,
                                                            __A::Error> where
                                 __A: _serde::de::MapAccess<'de> {
                                    let mut __field0:
                                            _serde::export::Option<String> =
                                        _serde::export::None;
                                    let mut __field1:
                                            _serde::export::Option<Option<String>> =
                                        _serde::export::None;
                                    let mut __field2:
                                            _serde::export::Option<Option<String>> =
                                        _serde::export::None;
                                    let mut __field3:
                                            _serde::export::Option<Option<f32>> =
                                        _serde::export::None;
                                    let mut __field4:
                                            _serde::export::Option<Option<f32>> =
                                        _serde::export::None;
                                    let mut __field5:
                                            _serde::export::Option<Option<Filter>> =
                                        _serde::export::None;
                                    while let _serde::export::Some(__key) =
                                              match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::export::Option::is_some(&__field0)
                                                   {
                                                    return _serde::export::Err(<__A::Error
                                                                                   as
                                                                                   _serde::de::Error>::duplicate_field("id"));
                                                }
                                                __field0 =
                                                    _serde::export::Some(match _serde::de::MapAccess::next_value::<String>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         });
                                            }
                                            __Field::__field1 => {
                                                if _serde::export::Option::is_some(&__field1)
                                                   {
                                                    return _serde::export::Err(<__A::Error
                                                                                   as
                                                                                   _serde::de::Error>::duplicate_field("source"));
                                                }
                                                __field1 =
                                                    _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         });
                                            }
                                            __Field::__field2 => {
                                                if _serde::export::Option::is_some(&__field2)
                                                   {
                                                    return _serde::export::Err(<__A::Error
                                                                                   as
                                                                                   _serde::de::Error>::duplicate_field("source-layer"));
                                                }
                                                __field2 =
                                                    _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         });
                                            }
                                            __Field::__field3 => {
                                                if _serde::export::Option::is_some(&__field3)
                                                   {
                                                    return _serde::export::Err(<__A::Error
                                                                                   as
                                                                                   _serde::de::Error>::duplicate_field("minzoom"));
                                                }
                                                __field3 =
                                                    _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<f32>>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         });
                                            }
                                            __Field::__field4 => {
                                                if _serde::export::Option::is_some(&__field4)
                                                   {
                                                    return _serde::export::Err(<__A::Error
                                                                                   as
                                                                                   _serde::de::Error>::duplicate_field("maxzoom"));
                                                }
                                                __field4 =
                                                    _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<f32>>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         });
                                            }
                                            __Field::__field5 => {
                                                if _serde::export::Option::is_some(&__field5)
                                                   {
                                                    return _serde::export::Err(<__A::Error
                                                                                   as
                                                                                   _serde::de::Error>::duplicate_field("filter"));
                                                }
                                                __field5 =
                                                    _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Filter>>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         });
                                            }
                                            _ => {
                                                let _ =
                                                    match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                            }
                                        }
                                    }
                                    let __field0 =
                                        match __field0 {
                                            _serde::export::Some(__field0) =>
                                            __field0,
                                            _serde::export::None =>
                                            match _serde::private::de::missing_field("id")
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        };
                                    let __field1 =
                                        match __field1 {
                                            _serde::export::Some(__field1) =>
                                            __field1,
                                            _serde::export::None =>
                                            match _serde::private::de::missing_field("source")
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        };
                                    let __field2 =
                                        match __field2 {
                                            _serde::export::Some(__field2) =>
                                            __field2,
                                            _serde::export::None =>
                                            match _serde::private::de::missing_field("source-layer")
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        };
                                    let __field3 =
                                        match __field3 {
                                            _serde::export::Some(__field3) =>
                                            __field3,
                                            _serde::export::None =>
                                            match _serde::private::de::missing_field("minzoom")
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        };
                                    let __field4 =
                                        match __field4 {
                                            _serde::export::Some(__field4) =>
                                            __field4,
                                            _serde::export::None =>
                                            match _serde::private::de::missing_field("maxzoom")
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        };
                                    let __field5 =
                                        match __field5 {
                                            _serde::export::Some(__field5) =>
                                            __field5,
                                            _serde::export::None =>
                                            match _serde::private::de::missing_field("filter")
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        };
                                    _serde::export::Ok(LayerCommon{id:
                                                                       __field0,
                                                                   source:
                                                                       __field1,
                                                                   source_layer:
                                                                       __field2,
                                                                   minzoom:
                                                                       __field3,
                                                                   maxzoom:
                                                                       __field4,
                                                                   filter:
                                                                       __field5,})
                                }
                            }
                            const FIELDS: &'static [&'static str] =
                                &["id", "source", "source-layer", "minzoom",
                                  "maxzoom", "filter"];
                            _serde::Deserializer::deserialize_struct(__deserializer,
                                                                     "LayerCommon",
                                                                     FIELDS,
                                                                     __Visitor{marker:
                                                                                   _serde::export::PhantomData::<LayerCommon>,
                                                                               lifetime:
                                                                                   _serde::export::PhantomData,})
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for LayerCommon {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        LayerCommon {
                        id: ref __self_0_0,
                        source: ref __self_0_1,
                        source_layer: ref __self_0_2,
                        minzoom: ref __self_0_3,
                        maxzoom: ref __self_0_4,
                        filter: ref __self_0_5 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("LayerCommon");
                            let _ =
                                debug_trait_builder.field("id",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("source",
                                                          &&(*__self_0_1));
                            let _ =
                                debug_trait_builder.field("source_layer",
                                                          &&(*__self_0_2));
                            let _ =
                                debug_trait_builder.field("minzoom",
                                                          &&(*__self_0_3));
                            let _ =
                                debug_trait_builder.field("maxzoom",
                                                          &&(*__self_0_4));
                            let _ =
                                debug_trait_builder.field("filter",
                                                          &&(*__self_0_5));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for LayerCommon {
                #[inline]
                fn clone(&self) -> LayerCommon {
                    match *self {
                        LayerCommon {
                        id: ref __self_0_0,
                        source: ref __self_0_1,
                        source_layer: ref __self_0_2,
                        minzoom: ref __self_0_3,
                        maxzoom: ref __self_0_4,
                        filter: ref __self_0_5 } =>
                        LayerCommon{id:
                                        ::std::clone::Clone::clone(&(*__self_0_0)),
                                    source:
                                        ::std::clone::Clone::clone(&(*__self_0_1)),
                                    source_layer:
                                        ::std::clone::Clone::clone(&(*__self_0_2)),
                                    minzoom:
                                        ::std::clone::Clone::clone(&(*__self_0_3)),
                                    maxzoom:
                                        ::std::clone::Clone::clone(&(*__self_0_4)),
                                    filter:
                                        ::std::clone::Clone::clone(&(*__self_0_5)),},
                    }
                }
            }
            pub enum Visibility {

                #[serde(rename = "visible")]
                Visible,

                #[serde(rename = "none")]
                Invisible,
            }
            #[allow(non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications)]
            const _IMPL_DESERIALIZE_FOR_Visibility: () =
                {
                    #[allow(unknown_lints)]
                    #[allow(rust_2018_idioms)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try(( $ __expr : expr ) => {
                                     match $ __expr {
                                     _serde :: export :: Ok ( __val ) => __val
                                     , _serde :: export :: Err ( __err ) => {
                                     return _serde :: export :: Err ( __err )
                                     ; } } });
                    #[automatically_derived]
                    impl <'de> _serde::Deserialize<'de> for Visibility {
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            #[allow(non_camel_case_types)]
                            enum __Field { __field0, __field1, }
                            struct __FieldVisitor;
                            impl <'de> _serde::de::Visitor<'de> for
                             __FieldVisitor {
                                type
                                Value
                                =
                                __Field;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "variant identifier")
                                }
                                fn visit_u64<__E>(self, __value: u64)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        0u64 =>
                                        _serde::export::Ok(__Field::__field0),
                                        1u64 =>
                                        _serde::export::Ok(__Field::__field1),
                                        _ =>
                                        _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                             &"variant index 0 <= i < 2")),
                                    }
                                }
                                fn visit_str<__E>(self, __value: &str)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        "visible" =>
                                        _serde::export::Ok(__Field::__field0),
                                        "none" =>
                                        _serde::export::Ok(__Field::__field1),
                                        _ => {
                                            _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                   VARIANTS))
                                        }
                                    }
                                }
                                fn visit_bytes<__E>(self, __value: &[u8])
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        b"visible" =>
                                        _serde::export::Ok(__Field::__field0),
                                        b"none" =>
                                        _serde::export::Ok(__Field::__field1),
                                        _ => {
                                            let __value =
                                                &_serde::export::from_utf8_lossy(__value);
                                            _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                                   VARIANTS))
                                        }
                                    }
                                }
                            }
                            impl <'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(__deserializer: __D)
                                 -> _serde::export::Result<Self, __D::Error>
                                 where __D: _serde::Deserializer<'de> {
                                    _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                 __FieldVisitor)
                                }
                            }
                            struct __Visitor<'de> {
                                marker: _serde::export::PhantomData<Visibility>,
                                lifetime: _serde::export::PhantomData<&'de ()>,
                            }
                            impl <'de> _serde::de::Visitor<'de> for
                             __Visitor<'de> {
                                type
                                Value
                                =
                                Visibility;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "enum Visibility")
                                }
                                fn visit_enum<__A>(self, __data: __A)
                                 ->
                                     _serde::export::Result<Self::Value,
                                                            __A::Error> where
                                 __A: _serde::de::EnumAccess<'de> {
                                    match match _serde::de::EnumAccess::variant(__data)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        (__Field::__field0, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Visibility::Visible)
                                        }
                                        (__Field::__field1, __variant) => {
                                            match _serde::de::VariantAccess::unit_variant(__variant)
                                                {
                                                _serde::export::Ok(__val) =>
                                                __val,
                                                _serde::export::Err(__err) =>
                                                {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                            _serde::export::Ok(Visibility::Invisible)
                                        }
                                    }
                                }
                            }
                            const VARIANTS: &'static [&'static str] =
                                &["visible", "none"];
                            _serde::Deserializer::deserialize_enum(__deserializer,
                                                                   "Visibility",
                                                                   VARIANTS,
                                                                   __Visitor{marker:
                                                                                 _serde::export::PhantomData::<Visibility>,
                                                                             lifetime:
                                                                                 _serde::export::PhantomData,})
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for Visibility {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&Visibility::Visible,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Visible");
                            debug_trait_builder.finish()
                        }
                        (&Visibility::Invisible,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Invisible");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Visibility {
                #[inline]
                fn clone(&self) -> Visibility {
                    match (&*self,) {
                        (&Visibility::Visible,) => Visibility::Visible,
                        (&Visibility::Invisible,) => Visibility::Invisible,
                    }
                }
            }
            impl Into<bool> for Visibility {
                fn into(self) -> bool {
                    match self { Visibility::Visible => true, _ => false, }
                }
            }
            impl Default for Visibility {
                fn default() -> Self { Visibility::Visible }
            }
            pub struct BaseLayout {
                #[serde(default = "Default::default")]
                pub visibility: StyleProp<String>,
            }
            #[allow(non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications)]
            const _IMPL_DESERIALIZE_FOR_BaseLayout: () =
                {
                    #[allow(unknown_lints)]
                    #[allow(rust_2018_idioms)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try(( $ __expr : expr ) => {
                                     match $ __expr {
                                     _serde :: export :: Ok ( __val ) => __val
                                     , _serde :: export :: Err ( __err ) => {
                                     return _serde :: export :: Err ( __err )
                                     ; } } });
                    #[automatically_derived]
                    impl <'de> _serde::Deserialize<'de> for BaseLayout {
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            #[allow(non_camel_case_types)]
                            enum __Field { __field0, __ignore, }
                            struct __FieldVisitor;
                            impl <'de> _serde::de::Visitor<'de> for
                             __FieldVisitor {
                                type
                                Value
                                =
                                __Field;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "field identifier")
                                }
                                fn visit_u64<__E>(self, __value: u64)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        0u64 =>
                                        _serde::export::Ok(__Field::__field0),
                                        _ =>
                                        _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                             &"field index 0 <= i < 1")),
                                    }
                                }
                                fn visit_str<__E>(self, __value: &str)
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        "visibility" =>
                                        _serde::export::Ok(__Field::__field0),
                                        _ => {
                                            _serde::export::Ok(__Field::__ignore)
                                        }
                                    }
                                }
                                fn visit_bytes<__E>(self, __value: &[u8])
                                 -> _serde::export::Result<Self::Value, __E>
                                 where __E: _serde::de::Error {
                                    match __value {
                                        b"visibility" =>
                                        _serde::export::Ok(__Field::__field0),
                                        _ => {
                                            _serde::export::Ok(__Field::__ignore)
                                        }
                                    }
                                }
                            }
                            impl <'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(__deserializer: __D)
                                 -> _serde::export::Result<Self, __D::Error>
                                 where __D: _serde::Deserializer<'de> {
                                    _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                                 __FieldVisitor)
                                }
                            }
                            struct __Visitor<'de> {
                                marker: _serde::export::PhantomData<BaseLayout>,
                                lifetime: _serde::export::PhantomData<&'de ()>,
                            }
                            impl <'de> _serde::de::Visitor<'de> for
                             __Visitor<'de> {
                                type
                                Value
                                =
                                BaseLayout;
                                fn expecting(&self,
                                             __formatter:
                                                 &mut _serde::export::Formatter)
                                 -> _serde::export::fmt::Result {
                                    _serde::export::Formatter::write_str(__formatter,
                                                                         "struct BaseLayout")
                                }
                                #[inline]
                                fn visit_seq<__A>(self, mut __seq: __A)
                                 ->
                                     _serde::export::Result<Self::Value,
                                                            __A::Error> where
                                 __A: _serde::de::SeqAccess<'de> {
                                    let __field0 =
                                        match match _serde::de::SeqAccess::next_element::<StyleProp<String>>(&mut __seq)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                            _serde::export::Some(__value) =>
                                            __value,
                                            _serde::export::None => {
                                                return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                             &"struct BaseLayout with 1 element"));
                                            }
                                        };
                                    _serde::export::Ok(BaseLayout{visibility:
                                                                      __field0,})
                                }
                                #[inline]
                                fn visit_map<__A>(self, mut __map: __A)
                                 ->
                                     _serde::export::Result<Self::Value,
                                                            __A::Error> where
                                 __A: _serde::de::MapAccess<'de> {
                                    let mut __field0:
                                            _serde::export::Option<StyleProp<String>> =
                                        _serde::export::None;
                                    while let _serde::export::Some(__key) =
                                              match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                                  {
                                                  _serde::export::Ok(__val) =>
                                                  __val,
                                                  _serde::export::Err(__err)
                                                  => {
                                                      return _serde::export::Err(__err);
                                                  }
                                              } {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::export::Option::is_some(&__field0)
                                                   {
                                                    return _serde::export::Err(<__A::Error
                                                                                   as
                                                                                   _serde::de::Error>::duplicate_field("visibility"));
                                                }
                                                __field0 =
                                                    _serde::export::Some(match _serde::de::MapAccess::next_value::<StyleProp<String>>(&mut __map)
                                                                             {
                                                                             _serde::export::Ok(__val)
                                                                             =>
                                                                             __val,
                                                                             _serde::export::Err(__err)
                                                                             =>
                                                                             {
                                                                                 return _serde::export::Err(__err);
                                                                             }
                                                                         });
                                            }
                                            _ => {
                                                let _ =
                                                    match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                        {
                                                        _serde::export::Ok(__val)
                                                        => __val,
                                                        _serde::export::Err(__err)
                                                        => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                            }
                                        }
                                    }
                                    let __field0 =
                                        match __field0 {
                                            _serde::export::Some(__field0) =>
                                            __field0,
                                            _serde::export::None =>
                                            Default::default(),
                                        };
                                    _serde::export::Ok(BaseLayout{visibility:
                                                                      __field0,})
                                }
                            }
                            const FIELDS: &'static [&'static str] =
                                &["visibility"];
                            _serde::Deserializer::deserialize_struct(__deserializer,
                                                                     "BaseLayout",
                                                                     FIELDS,
                                                                     __Visitor{marker:
                                                                                   _serde::export::PhantomData::<BaseLayout>,
                                                                               lifetime:
                                                                                   _serde::export::PhantomData,})
                        }
                    }
                };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for BaseLayout {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        BaseLayout { visibility: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("BaseLayout");
                            let _ =
                                debug_trait_builder.field("visibility",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for BaseLayout {
                #[inline]
                fn clone(&self) -> BaseLayout {
                    match *self {
                        BaseLayout { visibility: ref __self_0_0 } =>
                        BaseLayout{visibility:
                                       ::std::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            impl Default for BaseLayout {
                fn default() -> Self {
                    BaseLayout{visibility: Default::default(),}
                }
            }
            pub trait StyleLayer {
                type
                PaintType;
                type
                LayoutType;
                fn get_paint(&self)
                -> &Self::PaintType;
                fn get_layout(&self)
                -> &Self::LayoutType;
            }
            use super::expr::DescribeType;
            #[serde(untagged)]
            pub enum StyleProp<T: DescribeType + Debug> {
                Value(T),
                Expr(super::expr::TypedExpr<T>),
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::fmt::Debug + DescribeType + Debug>
             ::std::fmt::Debug for StyleProp<T> {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&StyleProp::Value(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Value");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&StyleProp::Expr(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Expr");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl <T: ::std::clone::Clone + DescribeType + Debug>
             ::std::clone::Clone for StyleProp<T> {
                #[inline]
                fn clone(&self) -> StyleProp<T> {
                    match (&*self,) {
                        (&StyleProp::Value(ref __self_0),) =>
                        StyleProp::Value(::std::clone::Clone::clone(&(*__self_0))),
                        (&StyleProp::Expr(ref __self_0),) =>
                        StyleProp::Expr(::std::clone::Clone::clone(&(*__self_0))),
                    }
                }
            }
            #[allow(non_upper_case_globals,
                    unused_attributes,
                    unused_qualifications)]
            const _IMPL_DESERIALIZE_FOR_StyleProp: () =
                {
                    #[allow(unknown_lints)]
                    #[allow(rust_2018_idioms)]
                    extern crate serde as _serde;
                    #[allow(unused_macros)]
                    macro_rules! try(( $ __expr : expr ) => {
                                     match $ __expr {
                                     _serde :: export :: Ok ( __val ) => __val
                                     , _serde :: export :: Err ( __err ) => {
                                     return _serde :: export :: Err ( __err )
                                     ; } } });
                    #[automatically_derived]
                    impl <'de, T: DescribeType + Debug>
                     _serde::Deserialize<'de> for StyleProp<T> where
                     T: _serde::Deserialize<'de> {
                        fn deserialize<__D>(__deserializer: __D)
                         -> _serde::export::Result<Self, __D::Error> where
                         __D: _serde::Deserializer<'de> {
                            let __content =
                                match <_serde::private::de::Content as
                                          _serde::Deserialize>::deserialize(__deserializer)
                                    {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            if let _serde::export::Ok(__ok) =
                                   _serde::export::Result::map(<T as
                                                                   _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                               StyleProp::Value)
                                   {
                                return _serde::export::Ok(__ok);
                            }
                            if let _serde::export::Ok(__ok) =
                                   _serde::export::Result::map(<super::expr::TypedExpr<T>
                                                                   as
                                                                   _serde::Deserialize>::deserialize(_serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content)),
                                                               StyleProp::Expr)
                                   {
                                return _serde::export::Ok(__ok);
                            }
                            _serde::export::Err(_serde::de::Error::custom("data did not match any variant of untagged enum StyleProp"))
                        }
                    }
                };
            impl <T: DescribeType + Debug> StyleProp<T> {
                pub fn is_zoom(&self) -> bool {
                    return if let StyleProp::Expr(e) = self {
                               e.is_zoom()
                           } else { false };
                }
                pub fn is_feature(&self) -> bool {
                    return if let StyleProp::Expr(e) = self {
                               e.is_feature()
                           } else { false };
                }
            }
            impl <T: Debug + Default + super::expr::DescribeType> Default for
             StyleProp<T> {
                fn default() -> Self { StyleProp::Value(Default::default()) }
            }
        }
        pub use self::layers::*;
        pub struct TileJson {
            scheme: Option<String>,
            tiles: Option<Vec<String>>,
            minzoom: Option<f32>,
            maxzoom: Option<f32>,
            bounds: Option<[f32; 4]>,
            #[serde(rename = "tileSize")]
            tile_size: Option<i32>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for TileJson {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    TileJson {
                    scheme: ref __self_0_0,
                    tiles: ref __self_0_1,
                    minzoom: ref __self_0_2,
                    maxzoom: ref __self_0_3,
                    bounds: ref __self_0_4,
                    tile_size: ref __self_0_5 } => {
                        let mut debug_trait_builder =
                            f.debug_struct("TileJson");
                        let _ =
                            debug_trait_builder.field("scheme",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("tiles",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("minzoom",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("maxzoom",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("bounds",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("tile_size",
                                                      &&(*__self_0_5));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(non_upper_case_globals,
                unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_TileJson: () =
            {
                #[allow(unknown_lints)]
                #[allow(rust_2018_idioms)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try(( $ __expr : expr ) => {
                                 match $ __expr {
                                 _serde :: export :: Ok ( __val ) => __val ,
                                 _serde :: export :: Err ( __err ) => {
                                 return _serde :: export :: Err ( __err ) ; }
                                 } });
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for TileJson {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type
                            Value
                            =
                            __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 6")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "scheme" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "tiles" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "minzoom" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "maxzoom" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "bounds" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "tileSize" =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"scheme" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"tiles" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"minzoom" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"maxzoom" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"bounds" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"tileSize" =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TileJson>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type
                            Value
                            =
                            TileJson;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct TileJson")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct TileJson with 6 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Option<Vec<String>>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct TileJson with 6 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Option<f32>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct TileJson with 6 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<f32>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct TileJson with 6 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<Option<[f32; 4]>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct TileJson with 6 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<Option<i32>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct TileJson with 6 elements"));
                                        }
                                    };
                                _serde::export::Ok(TileJson{scheme: __field0,
                                                            tiles: __field1,
                                                            minzoom: __field2,
                                                            maxzoom: __field3,
                                                            bounds: __field4,
                                                            tile_size:
                                                                __field5,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Option<Vec<String>>> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Option<f32>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<f32>> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<Option<[f32; 4]>> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<Option<i32>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("scheme"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("tiles"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<Vec<String>>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("minzoom"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<f32>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("maxzoom"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<f32>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("bounds"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<[f32; 4]>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("tileSize"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<i32>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("scheme")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("tiles")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("minzoom")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("maxzoom")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("bounds")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("tileSize")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(TileJson{scheme: __field0,
                                                            tiles: __field1,
                                                            minzoom: __field2,
                                                            maxzoom: __field3,
                                                            bounds: __field4,
                                                            tile_size:
                                                                __field5,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["scheme", "tiles", "minzoom", "maxzoom",
                              "bounds", "tileSize"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "TileJson",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<TileJson>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for TileJson {
            #[inline]
            fn clone(&self) -> TileJson {
                match *self {
                    TileJson {
                    scheme: ref __self_0_0,
                    tiles: ref __self_0_1,
                    minzoom: ref __self_0_2,
                    maxzoom: ref __self_0_3,
                    bounds: ref __self_0_4,
                    tile_size: ref __self_0_5 } =>
                    TileJson{scheme:
                                 ::std::clone::Clone::clone(&(*__self_0_0)),
                             tiles:
                                 ::std::clone::Clone::clone(&(*__self_0_1)),
                             minzoom:
                                 ::std::clone::Clone::clone(&(*__self_0_2)),
                             maxzoom:
                                 ::std::clone::Clone::clone(&(*__self_0_3)),
                             bounds:
                                 ::std::clone::Clone::clone(&(*__self_0_4)),
                             tile_size:
                                 ::std::clone::Clone::clone(&(*__self_0_5)),},
                }
            }
        }
        pub struct SourceData {
            #[serde(flatten)]
            tilejson: TileJson,
            url: Option<String>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for SourceData {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    SourceData { tilejson: ref __self_0_0, url: ref __self_0_1
                    } => {
                        let mut debug_trait_builder =
                            f.debug_struct("SourceData");
                        let _ =
                            debug_trait_builder.field("tilejson",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("url", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[allow(non_upper_case_globals,
                unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_SourceData: () =
            {
                #[allow(unknown_lints)]
                #[allow(rust_2018_idioms)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try(( $ __expr : expr ) => {
                                 match $ __expr {
                                 _serde :: export :: Ok ( __val ) => __val ,
                                 _serde :: export :: Err ( __err ) => {
                                 return _serde :: export :: Err ( __err ) ; }
                                 } });
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for SourceData {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field<'de> {
                            __field1,
                            __other(_serde::private::de::Content<'de>),
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type
                            Value
                            =
                            __Field<'de>;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_bool<__E>(self, __value: bool)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Bool(__value)))
                            }
                            fn visit_i8<__E>(self, __value: i8)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I8(__value)))
                            }
                            fn visit_i16<__E>(self, __value: i16)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I16(__value)))
                            }
                            fn visit_i32<__E>(self, __value: i32)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I32(__value)))
                            }
                            fn visit_i64<__E>(self, __value: i64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::I64(__value)))
                            }
                            fn visit_u8<__E>(self, __value: u8)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U8(__value)))
                            }
                            fn visit_u16<__E>(self, __value: u16)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U16(__value)))
                            }
                            fn visit_u32<__E>(self, __value: u32)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U32(__value)))
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::U64(__value)))
                            }
                            fn visit_f32<__E>(self, __value: f32)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F32(__value)))
                            }
                            fn visit_f64<__E>(self, __value: f64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::F64(__value)))
                            }
                            fn visit_char<__E>(self, __value: char)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Char(__value)))
                            }
                            fn visit_unit<__E>(self)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                _serde::export::Ok(__Field::__other(_serde::private::de::Content::Unit))
                            }
                            fn visit_borrowed_str<__E>(self,
                                                       __value: &'de str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        let __value =
                                            _serde::private::de::Content::Str(__value);
                                        _serde::export::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_borrowed_bytes<__E>(self,
                                                         __value: &'de [u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        let __value =
                                            _serde::private::de::Content::Bytes(__value);
                                        _serde::export::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        let __value =
                                            _serde::private::de::Content::String(__value.to_string());
                                        _serde::export::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"url" =>
                                    _serde::export::Ok(__Field::__field1),
                                    _ => {
                                        let __value =
                                            _serde::private::de::Content::ByteBuf(__value.to_vec());
                                        _serde::export::Ok(__Field::__other(__value))
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field<'de> {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<SourceData>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type
                            Value
                            =
                            SourceData;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct SourceData")
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field1:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __collect =
                                    _serde::export::Vec::<_serde::export::Option<(_serde::private::de::Content,
                                                                                  _serde::private::de::Content)>>::new();
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("url"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__other(__name) => {
                                            __collect.push(_serde::export::Some((__name,
                                                                                 match _serde::de::MapAccess::next_value(&mut __map)
                                                                                     {
                                                                                     _serde::export::Ok(__val)
                                                                                     =>
                                                                                     __val,
                                                                                     _serde::export::Err(__err)
                                                                                     =>
                                                                                     {
                                                                                         return _serde::export::Err(__err);
                                                                                     }
                                                                                 })));
                                        }
                                    }
                                }
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("url")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field0: TileJson =
                                    match _serde::de::Deserialize::deserialize(_serde::private::de::FlatMapDeserializer(&mut __collect,
                                                                                                                        _serde::export::PhantomData))
                                        {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                _serde::export::Ok(SourceData{tilejson:
                                                                  __field0,
                                                              url: __field1,})
                            }
                        }
                        _serde::Deserializer::deserialize_map(__deserializer,
                                                              __Visitor{marker:
                                                                            _serde::export::PhantomData::<SourceData>,
                                                                        lifetime:
                                                                            _serde::export::PhantomData,})
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for SourceData {
            #[inline]
            fn clone(&self) -> SourceData {
                match *self {
                    SourceData { tilejson: ref __self_0_0, url: ref __self_0_1
                    } =>
                    SourceData{tilejson:
                                   ::std::clone::Clone::clone(&(*__self_0_0)),
                               url:
                                   ::std::clone::Clone::clone(&(*__self_0_1)),},
                }
            }
        }
        pub struct Style {
            pub version: i32,
            pub name: Option<String>,
            pub center: Option<[f64; 2]>,
            pub zoom: Option<f32>,
            pub sources: BTreeMap<String, StyleSource>,
            pub sprite: Option<String>,
            pub glyphs: Option<String>,
            pub layers: Vec<BaseStyleLayer>,
        }
        #[allow(non_upper_case_globals,
                unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_Style: () =
            {
                #[allow(unknown_lints)]
                #[allow(rust_2018_idioms)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try(( $ __expr : expr ) => {
                                 match $ __expr {
                                 _serde :: export :: Ok ( __val ) => __val ,
                                 _serde :: export :: Err ( __err ) => {
                                 return _serde :: export :: Err ( __err ) ; }
                                 } });
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for Style {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                            __field6,
                            __field7,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type
                            Value
                            =
                            __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "field identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    6u64 =>
                                    _serde::export::Ok(__Field::__field6),
                                    7u64 =>
                                    _serde::export::Ok(__Field::__field7),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"field index 0 <= i < 8")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "version" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "name" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "center" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "zoom" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "sources" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "sprite" =>
                                    _serde::export::Ok(__Field::__field5),
                                    "glyphs" =>
                                    _serde::export::Ok(__Field::__field6),
                                    "layers" =>
                                    _serde::export::Ok(__Field::__field7),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"version" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"name" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"center" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"zoom" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"sources" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"sprite" =>
                                    _serde::export::Ok(__Field::__field5),
                                    b"glyphs" =>
                                    _serde::export::Ok(__Field::__field6),
                                    b"layers" =>
                                    _serde::export::Ok(__Field::__field7),
                                    _ => {
                                        _serde::export::Ok(__Field::__ignore)
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<Style>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl <'de> _serde::de::Visitor<'de> for __Visitor<'de>
                         {
                            type
                            Value
                            =
                            Style;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "struct Style")
                            }
                            #[inline]
                            fn visit_seq<__A>(self, mut __seq: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::SeqAccess<'de> {
                                let __field0 =
                                    match match _serde::de::SeqAccess::next_element::<i32>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(0usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(1usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Option<[f64; 2]>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(2usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                let __field3 =
                                    match match _serde::de::SeqAccess::next_element::<Option<f32>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(3usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                let __field4 =
                                    match match _serde::de::SeqAccess::next_element::<BTreeMap<String,
                                                                                               StyleSource>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(4usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                let __field5 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(5usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                let __field6 =
                                    match match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(6usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                let __field7 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<BaseStyleLayer>>(&mut __seq)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                        _serde::export::Some(__value) =>
                                        __value,
                                        _serde::export::None => {
                                            return _serde::export::Err(_serde::de::Error::invalid_length(7usize,
                                                                                                         &"struct Style with 8 elements"));
                                        }
                                    };
                                _serde::export::Ok(Style{version: __field0,
                                                         name: __field1,
                                                         center: __field2,
                                                         zoom: __field3,
                                                         sources: __field4,
                                                         sprite: __field5,
                                                         glyphs: __field6,
                                                         layers: __field7,})
                            }
                            #[inline]
                            fn visit_map<__A>(self, mut __map: __A)
                             ->
                                 _serde::export::Result<Self::Value,
                                                        __A::Error> where
                             __A: _serde::de::MapAccess<'de> {
                                let mut __field0:
                                        _serde::export::Option<i32> =
                                    _serde::export::None;
                                let mut __field1:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field2:
                                        _serde::export::Option<Option<[f64; 2]>> =
                                    _serde::export::None;
                                let mut __field3:
                                        _serde::export::Option<Option<f32>> =
                                    _serde::export::None;
                                let mut __field4:
                                        _serde::export::Option<BTreeMap<String,
                                                                        StyleSource>> =
                                    _serde::export::None;
                                let mut __field5:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field6:
                                        _serde::export::Option<Option<String>> =
                                    _serde::export::None;
                                let mut __field7:
                                        _serde::export::Option<Vec<BaseStyleLayer>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                          match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                              {
                                              _serde::export::Ok(__val) =>
                                              __val,
                                              _serde::export::Err(__err) => {
                                                  return _serde::export::Err(__err);
                                              }
                                          } {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("version"));
                                            }
                                            __field0 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<i32>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("name"));
                                            }
                                            __field1 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("center"));
                                            }
                                            __field2 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<[f64; 2]>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field3 => {
                                            if _serde::export::Option::is_some(&__field3)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("zoom"));
                                            }
                                            __field3 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<f32>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field4 => {
                                            if _serde::export::Option::is_some(&__field4)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("sources"));
                                            }
                                            __field4 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<BTreeMap<String,
                                                                                                                        StyleSource>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field5 => {
                                            if _serde::export::Option::is_some(&__field5)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("sprite"));
                                            }
                                            __field5 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field6 => {
                                            if _serde::export::Option::is_some(&__field6)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("glyphs"));
                                            }
                                            __field6 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        __Field::__field7 => {
                                            if _serde::export::Option::is_some(&__field7)
                                               {
                                                return _serde::export::Err(<__A::Error
                                                                               as
                                                                               _serde::de::Error>::duplicate_field("layers"));
                                            }
                                            __field7 =
                                                _serde::export::Some(match _serde::de::MapAccess::next_value::<Vec<BaseStyleLayer>>(&mut __map)
                                                                         {
                                                                         _serde::export::Ok(__val)
                                                                         =>
                                                                         __val,
                                                                         _serde::export::Err(__err)
                                                                         => {
                                                                             return _serde::export::Err(__err);
                                                                         }
                                                                     });
                                        }
                                        _ => {
                                            let _ =
                                                match _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)
                                                    {
                                                    _serde::export::Ok(__val)
                                                    => __val,
                                                    _serde::export::Err(__err)
                                                    => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                };
                                        }
                                    }
                                }
                                let __field0 =
                                    match __field0 {
                                        _serde::export::Some(__field0) =>
                                        __field0,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("version")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field1 =
                                    match __field1 {
                                        _serde::export::Some(__field1) =>
                                        __field1,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("name")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field2 =
                                    match __field2 {
                                        _serde::export::Some(__field2) =>
                                        __field2,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("center")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field3 =
                                    match __field3 {
                                        _serde::export::Some(__field3) =>
                                        __field3,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("zoom")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field4 =
                                    match __field4 {
                                        _serde::export::Some(__field4) =>
                                        __field4,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("sources")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field5 =
                                    match __field5 {
                                        _serde::export::Some(__field5) =>
                                        __field5,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("sprite")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field6 =
                                    match __field6 {
                                        _serde::export::Some(__field6) =>
                                        __field6,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("glyphs")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                let __field7 =
                                    match __field7 {
                                        _serde::export::Some(__field7) =>
                                        __field7,
                                        _serde::export::None =>
                                        match _serde::private::de::missing_field("layers")
                                            {
                                            _serde::export::Ok(__val) =>
                                            __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    };
                                _serde::export::Ok(Style{version: __field0,
                                                         name: __field1,
                                                         center: __field2,
                                                         zoom: __field3,
                                                         sources: __field4,
                                                         sprite: __field5,
                                                         glyphs: __field6,
                                                         layers: __field7,})
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["version", "name", "center", "zoom", "sources",
                              "sprite", "glyphs", "layers"];
                        _serde::Deserializer::deserialize_struct(__deserializer,
                                                                 "Style",
                                                                 FIELDS,
                                                                 __Visitor{marker:
                                                                               _serde::export::PhantomData::<Style>,
                                                                           lifetime:
                                                                               _serde::export::PhantomData,})
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Style {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    Style {
                    version: ref __self_0_0,
                    name: ref __self_0_1,
                    center: ref __self_0_2,
                    zoom: ref __self_0_3,
                    sources: ref __self_0_4,
                    sprite: ref __self_0_5,
                    glyphs: ref __self_0_6,
                    layers: ref __self_0_7 } => {
                        let mut debug_trait_builder = f.debug_struct("Style");
                        let _ =
                            debug_trait_builder.field("version",
                                                      &&(*__self_0_0));
                        let _ =
                            debug_trait_builder.field("name",
                                                      &&(*__self_0_1));
                        let _ =
                            debug_trait_builder.field("center",
                                                      &&(*__self_0_2));
                        let _ =
                            debug_trait_builder.field("zoom",
                                                      &&(*__self_0_3));
                        let _ =
                            debug_trait_builder.field("sources",
                                                      &&(*__self_0_4));
                        let _ =
                            debug_trait_builder.field("sprite",
                                                      &&(*__self_0_5));
                        let _ =
                            debug_trait_builder.field("glyphs",
                                                      &&(*__self_0_6));
                        let _ =
                            debug_trait_builder.field("layers",
                                                      &&(*__self_0_7));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Style {
            #[inline]
            fn clone(&self) -> Style {
                match *self {
                    Style {
                    version: ref __self_0_0,
                    name: ref __self_0_1,
                    center: ref __self_0_2,
                    zoom: ref __self_0_3,
                    sources: ref __self_0_4,
                    sprite: ref __self_0_5,
                    glyphs: ref __self_0_6,
                    layers: ref __self_0_7 } =>
                    Style{version: ::std::clone::Clone::clone(&(*__self_0_0)),
                          name: ::std::clone::Clone::clone(&(*__self_0_1)),
                          center: ::std::clone::Clone::clone(&(*__self_0_2)),
                          zoom: ::std::clone::Clone::clone(&(*__self_0_3)),
                          sources: ::std::clone::Clone::clone(&(*__self_0_4)),
                          sprite: ::std::clone::Clone::clone(&(*__self_0_5)),
                          glyphs: ::std::clone::Clone::clone(&(*__self_0_6)),
                          layers:
                              ::std::clone::Clone::clone(&(*__self_0_7)),},
                }
            }
        }
        #[serde(tag = "type")]
        pub enum StyleSource {

            #[serde(rename = "vector")]
            Vector(SourceData),

            #[serde(rename = "raster")]
            Raster(SourceData),

            #[serde(rename = "image")]
            Image(SourceData),
        }
        #[allow(non_upper_case_globals,
                unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_StyleSource: () =
            {
                #[allow(unknown_lints)]
                #[allow(rust_2018_idioms)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try(( $ __expr : expr ) => {
                                 match $ __expr {
                                 _serde :: export :: Ok ( __val ) => __val ,
                                 _serde :: export :: Err ( __err ) => {
                                 return _serde :: export :: Err ( __err ) ; }
                                 } });
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for StyleSource {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field { __field0, __field1, __field2, }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type
                            Value
                            =
                            __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"variant index 0 <= i < 3")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "vector" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "raster" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "image" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"vector" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"raster" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"image" =>
                                    _serde::export::Ok(__Field::__field2),
                                    _ => {
                                        let __value =
                                            &_serde::export::from_utf8_lossy(__value);
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        const VARIANTS: &'static [&'static str] =
                            &["vector", "raster", "image"];
                        let __tagged =
                            match _serde::Deserializer::deserialize_any(__deserializer,
                                                                        _serde::private::de::TaggedContentVisitor::<__Field>::new("type"))
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match __tagged.tag {
                            __Field::__field0 =>
                            _serde::export::Result::map(<SourceData as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        StyleSource::Vector),
                            __Field::__field1 =>
                            _serde::export::Result::map(<SourceData as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        StyleSource::Raster),
                            __Field::__field2 =>
                            _serde::export::Result::map(<SourceData as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        StyleSource::Image),
                        }
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for StyleSource {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&StyleSource::Vector(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Vector");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&StyleSource::Raster(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Raster");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&StyleSource::Image(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Image");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for StyleSource {
            #[inline]
            fn clone(&self) -> StyleSource {
                match (&*self,) {
                    (&StyleSource::Vector(ref __self_0),) =>
                    StyleSource::Vector(::std::clone::Clone::clone(&(*__self_0))),
                    (&StyleSource::Raster(ref __self_0),) =>
                    StyleSource::Raster(::std::clone::Clone::clone(&(*__self_0))),
                    (&StyleSource::Image(ref __self_0),) =>
                    StyleSource::Image(::std::clone::Clone::clone(&(*__self_0))),
                }
            }
        }
        impl StyleSource {
            pub fn url_template(&self) -> String {
                match &self {
                    &StyleSource::Vector(ref v) => v,
                    &StyleSource::Raster(ref v) => v,
                    &StyleSource::Image(ref v) => v,
                }.tilejson.tiles.as_ref().unwrap()[0].clone()
            }
        }
        #[serde(tag = "type")]
        pub enum BaseStyleLayer {

            #[serde(rename = "background")]
            Background(BackgroundLayer),

            #[serde(rename = "fill")]
            Fill(FillLayer),

            #[serde(rename = "line")]
            Line(LineLayer),

            #[serde(rename = "symbol")]
            Symbols(SymbolLayer),

            #[serde(rename = "raster")]
            Raster(RasterLayer),

            #[serde(rename = "fill-extrusion")]
            FillExtrusion(json::Value),
        }
        #[allow(non_upper_case_globals,
                unused_attributes,
                unused_qualifications)]
        const _IMPL_DESERIALIZE_FOR_BaseStyleLayer: () =
            {
                #[allow(unknown_lints)]
                #[allow(rust_2018_idioms)]
                extern crate serde as _serde;
                #[allow(unused_macros)]
                macro_rules! try(( $ __expr : expr ) => {
                                 match $ __expr {
                                 _serde :: export :: Ok ( __val ) => __val ,
                                 _serde :: export :: Err ( __err ) => {
                                 return _serde :: export :: Err ( __err ) ; }
                                 } });
                #[automatically_derived]
                impl <'de> _serde::Deserialize<'de> for BaseStyleLayer {
                    fn deserialize<__D>(__deserializer: __D)
                     -> _serde::export::Result<Self, __D::Error> where
                     __D: _serde::Deserializer<'de> {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __field3,
                            __field4,
                            __field5,
                        }
                        struct __FieldVisitor;
                        impl <'de> _serde::de::Visitor<'de> for __FieldVisitor
                         {
                            type
                            Value
                            =
                            __Field;
                            fn expecting(&self,
                                         __formatter:
                                             &mut _serde::export::Formatter)
                             -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(__formatter,
                                                                     "variant identifier")
                            }
                            fn visit_u64<__E>(self, __value: u64)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    0u64 =>
                                    _serde::export::Ok(__Field::__field0),
                                    1u64 =>
                                    _serde::export::Ok(__Field::__field1),
                                    2u64 =>
                                    _serde::export::Ok(__Field::__field2),
                                    3u64 =>
                                    _serde::export::Ok(__Field::__field3),
                                    4u64 =>
                                    _serde::export::Ok(__Field::__field4),
                                    5u64 =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ =>
                                    _serde::export::Err(_serde::de::Error::invalid_value(_serde::de::Unexpected::Unsigned(__value),
                                                                                         &"variant index 0 <= i < 6")),
                                }
                            }
                            fn visit_str<__E>(self, __value: &str)
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    "background" =>
                                    _serde::export::Ok(__Field::__field0),
                                    "fill" =>
                                    _serde::export::Ok(__Field::__field1),
                                    "line" =>
                                    _serde::export::Ok(__Field::__field2),
                                    "symbol" =>
                                    _serde::export::Ok(__Field::__field3),
                                    "raster" =>
                                    _serde::export::Ok(__Field::__field4),
                                    "fill-extrusion" =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ => {
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                            fn visit_bytes<__E>(self, __value: &[u8])
                             -> _serde::export::Result<Self::Value, __E> where
                             __E: _serde::de::Error {
                                match __value {
                                    b"background" =>
                                    _serde::export::Ok(__Field::__field0),
                                    b"fill" =>
                                    _serde::export::Ok(__Field::__field1),
                                    b"line" =>
                                    _serde::export::Ok(__Field::__field2),
                                    b"symbol" =>
                                    _serde::export::Ok(__Field::__field3),
                                    b"raster" =>
                                    _serde::export::Ok(__Field::__field4),
                                    b"fill-extrusion" =>
                                    _serde::export::Ok(__Field::__field5),
                                    _ => {
                                        let __value =
                                            &_serde::export::from_utf8_lossy(__value);
                                        _serde::export::Err(_serde::de::Error::unknown_variant(__value,
                                                                                               VARIANTS))
                                    }
                                }
                            }
                        }
                        impl <'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(__deserializer: __D)
                             -> _serde::export::Result<Self, __D::Error> where
                             __D: _serde::Deserializer<'de> {
                                _serde::Deserializer::deserialize_identifier(__deserializer,
                                                                             __FieldVisitor)
                            }
                        }
                        const VARIANTS: &'static [&'static str] =
                            &["background", "fill", "line", "symbol",
                              "raster", "fill-extrusion"];
                        let __tagged =
                            match _serde::Deserializer::deserialize_any(__deserializer,
                                                                        _serde::private::de::TaggedContentVisitor::<__Field>::new("type"))
                                {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        match __tagged.tag {
                            __Field::__field0 =>
                            _serde::export::Result::map(<BackgroundLayer as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        BaseStyleLayer::Background),
                            __Field::__field1 =>
                            _serde::export::Result::map(<FillLayer as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        BaseStyleLayer::Fill),
                            __Field::__field2 =>
                            _serde::export::Result::map(<LineLayer as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        BaseStyleLayer::Line),
                            __Field::__field3 =>
                            _serde::export::Result::map(<SymbolLayer as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        BaseStyleLayer::Symbols),
                            __Field::__field4 =>
                            _serde::export::Result::map(<RasterLayer as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        BaseStyleLayer::Raster),
                            __Field::__field5 =>
                            _serde::export::Result::map(<json::Value as
                                                            _serde::Deserialize>::deserialize(_serde::private::de::ContentDeserializer::<__D::Error>::new(__tagged.content)),
                                                        BaseStyleLayer::FillExtrusion),
                        }
                    }
                }
            };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for BaseStyleLayer {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match (&*self,) {
                    (&BaseStyleLayer::Background(ref __self_0),) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("Background");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&BaseStyleLayer::Fill(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Fill");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&BaseStyleLayer::Line(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Line");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&BaseStyleLayer::Symbols(ref __self_0),) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("Symbols");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&BaseStyleLayer::Raster(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("Raster");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&BaseStyleLayer::FillExtrusion(ref __self_0),) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("FillExtrusion");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for BaseStyleLayer {
            #[inline]
            fn clone(&self) -> BaseStyleLayer {
                match (&*self,) {
                    (&BaseStyleLayer::Background(ref __self_0),) =>
                    BaseStyleLayer::Background(::std::clone::Clone::clone(&(*__self_0))),
                    (&BaseStyleLayer::Fill(ref __self_0),) =>
                    BaseStyleLayer::Fill(::std::clone::Clone::clone(&(*__self_0))),
                    (&BaseStyleLayer::Line(ref __self_0),) =>
                    BaseStyleLayer::Line(::std::clone::Clone::clone(&(*__self_0))),
                    (&BaseStyleLayer::Symbols(ref __self_0),) =>
                    BaseStyleLayer::Symbols(::std::clone::Clone::clone(&(*__self_0))),
                    (&BaseStyleLayer::Raster(ref __self_0),) =>
                    BaseStyleLayer::Raster(::std::clone::Clone::clone(&(*__self_0))),
                    (&BaseStyleLayer::FillExtrusion(ref __self_0),) =>
                    BaseStyleLayer::FillExtrusion(::std::clone::Clone::clone(&(*__self_0))),
                }
            }
        }
    }
    pub mod storage {
        use prelude::*;
        pub mod resource {
            use prelude::*;
            pub struct TileRequestData {
                pub template: String,
                pub coords: TileCoords,
                pub source: String,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for TileRequestData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        TileRequestData {
                        template: ref __self_0_0,
                        coords: ref __self_0_1,
                        source: ref __self_0_2 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("TileRequestData");
                            let _ =
                                debug_trait_builder.field("template",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("coords",
                                                          &&(*__self_0_1));
                            let _ =
                                debug_trait_builder.field("source",
                                                          &&(*__self_0_2));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for TileRequestData {
                #[inline]
                fn clone(&self) -> TileRequestData {
                    match *self {
                        TileRequestData {
                        template: ref __self_0_0,
                        coords: ref __self_0_1,
                        source: ref __self_0_2 } =>
                        TileRequestData{template:
                                            ::std::clone::Clone::clone(&(*__self_0_0)),
                                        coords:
                                            ::std::clone::Clone::clone(&(*__self_0_1)),
                                        source:
                                            ::std::clone::Clone::clone(&(*__self_0_2)),},
                    }
                }
            }
            pub struct StyleRequestData {
                pub url: String,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for StyleRequestData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        StyleRequestData { url: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("StyleRequestData");
                            let _ =
                                debug_trait_builder.field("url",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for StyleRequestData {
                #[inline]
                fn clone(&self) -> StyleRequestData {
                    match *self {
                        StyleRequestData { url: ref __self_0_0 } =>
                        StyleRequestData{url:
                                             ::std::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            pub struct SourceRequestData {
                pub url: String,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for SourceRequestData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        SourceRequestData { url: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("SourceRequestData");
                            let _ =
                                debug_trait_builder.field("url",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for SourceRequestData {
                #[inline]
                fn clone(&self) -> SourceRequestData {
                    match *self {
                        SourceRequestData { url: ref __self_0_0 } =>
                        SourceRequestData{url:
                                              ::std::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            pub enum LoadPreference {
                None,
                Cache,
                Network,
                CacheOnly,
                NetworkOnly,
                Any,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for LoadPreference {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&LoadPreference::None,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("None");
                            debug_trait_builder.finish()
                        }
                        (&LoadPreference::Cache,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Cache");
                            debug_trait_builder.finish()
                        }
                        (&LoadPreference::Network,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Network");
                            debug_trait_builder.finish()
                        }
                        (&LoadPreference::CacheOnly,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("CacheOnly");
                            debug_trait_builder.finish()
                        }
                        (&LoadPreference::NetworkOnly,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("NetworkOnly");
                            debug_trait_builder.finish()
                        }
                        (&LoadPreference::Any,) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Any");
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for LoadPreference {
                #[inline]
                fn clone(&self) -> LoadPreference {
                    match (&*self,) {
                        (&LoadPreference::None,) => LoadPreference::None,
                        (&LoadPreference::Cache,) => LoadPreference::Cache,
                        (&LoadPreference::Network,) =>
                        LoadPreference::Network,
                        (&LoadPreference::CacheOnly,) =>
                        LoadPreference::CacheOnly,
                        (&LoadPreference::NetworkOnly,) =>
                        LoadPreference::NetworkOnly,
                        (&LoadPreference::Any,) => LoadPreference::Any,
                    }
                }
            }
            pub enum RequestData {
                Tile(TileRequestData),
                StyleJson(StyleRequestData),
                SourceJson(SourceRequestData),
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for RequestData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&RequestData::Tile(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Tile");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&RequestData::StyleJson(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("StyleJson");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&RequestData::SourceJson(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("SourceJson");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for RequestData {
                #[inline]
                fn clone(&self) -> RequestData {
                    match (&*self,) {
                        (&RequestData::Tile(ref __self_0),) =>
                        RequestData::Tile(::std::clone::Clone::clone(&(*__self_0))),
                        (&RequestData::StyleJson(ref __self_0),) =>
                        RequestData::StyleJson(::std::clone::Clone::clone(&(*__self_0))),
                        (&RequestData::SourceJson(ref __self_0),) =>
                        RequestData::SourceJson(::std::clone::Clone::clone(&(*__self_0))),
                    }
                }
            }
            pub struct Request {
                pub load_pref: LoadPreference,
                pub data: RequestData,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for Request {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        Request {
                        load_pref: ref __self_0_0, data: ref __self_0_1 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("Request");
                            let _ =
                                debug_trait_builder.field("load_pref",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("data",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Request {
                #[inline]
                fn clone(&self) -> Request {
                    match *self {
                        Request {
                        load_pref: ref __self_0_0, data: ref __self_0_1 } =>
                        Request{load_pref:
                                    ::std::clone::Clone::clone(&(*__self_0_0)),
                                data:
                                    ::std::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
            impl Request {
                pub fn url<'a>(&'a self) -> String {
                    return match &self.data {
                               RequestData::StyleJson(StyleRequestData {
                                                      ref url, .. }) =>
                               url.to_string(),
                               RequestData::SourceJson(SourceRequestData {
                                                       ref url, .. }) =>
                               url.to_string(),
                               RequestData::Tile(TileRequestData {
                                                 ref template, ref coords, ..
                                                 }) => {
                                   template.replace("{x}",
                                                    &::fmt::format(::std::fmt::Arguments::new_v1_formatted(&[""],
                                                                                                           &match (&coords.x,)
                                                                                                                {
                                                                                                                (arg0,)
                                                                                                                =>
                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                             ::std::fmt::Display::fmt)],
                                                                                                            },
                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                          format:
                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                 ' ',
                                                                                                                                                                             align:
                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                             flags:
                                                                                                                                                                                 0u32,
                                                                                                                                                                             precision:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                             width:
                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))).replace("{y}",
                                                                                                                                                                                                                                    &::fmt::format(::std::fmt::Arguments::new_v1_formatted(&[""],
                                                                                                                                                                                                                                                                                           &match (&coords.y,)
                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                (arg0,)
                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                                                                                                                                             ::std::fmt::Display::fmt)],
                                                                                                                                                                                                                                                                                            },
                                                                                                                                                                                                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                                                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                                                                                                                                                                          format:
                                                                                                                                                                                                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                                                                                                                                                                                 ' ',
                                                                                                                                                                                                                                                                                                                                                             align:
                                                                                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                                                                                                                                                                             flags:
                                                                                                                                                                                                                                                                                                                                                                 0u32,
                                                                                                                                                                                                                                                                                                                                                             precision:
                                                                                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                                                                                                                                                                             width:
                                                                                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}]))).replace("{z}",
                                                                                                                                                                                                                                                                                                                                                                                                                    &::fmt::format(::std::fmt::Arguments::new_v1_formatted(&[""],
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &match (&coords.z,)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (arg0,)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                =>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ::std::fmt::Display::fmt)],
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            },
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          format:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ' ',
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             align:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             flags:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 0u32,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             precision:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             width:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::Count::Implied,},}])))
                               }
                               _ => {
                                   {
                                       {
                                           ::rt::begin_panic("explicit panic",
                                                             &("rmaps/src/map/storage/resource.rs",
                                                               57u32, 17u32))
                                       }
                                   }
                               }
                           };
                }
                pub fn style(url: String) -> Request {
                    Request{load_pref: LoadPreference::Any,
                            data:
                                RequestData::StyleJson(StyleRequestData{url:
                                                                            url,}),}
                }
                pub fn source(url: String) -> Request {
                    Request{load_pref: LoadPreference::Any,
                            data:
                                RequestData::SourceJson(SourceRequestData{url:
                                                                              url,}),}
                }
                pub fn tile(src_id: String, url_template: String,
                            coords: TileCoords) -> Request {
                    Request{load_pref: LoadPreference::Any,
                            data:
                                RequestData::Tile(TileRequestData{template:
                                                                      url_template,
                                                                  coords,
                                                                  source:
                                                                      src_id,}),}
                }
                pub fn is_style(&self) -> bool {
                    return if let RequestData::StyleJson(..) = self.data {
                               true
                           } else { false };
                }
                pub fn is_source(&self) -> bool {
                    return if let RequestData::SourceJson(..) = self.data {
                               true
                           } else { false };
                }
                pub fn is_tile(&self) -> bool {
                    return if let RequestData::Tile(..) = self.data {
                               true
                           } else { false };
                }
                pub fn style_data(&self) -> Option<&StyleRequestData> {
                    return match self.data {
                               RequestData::StyleJson(ref s) => Some(s),
                               _ => None,
                           };
                }
                pub fn source_data(&self) -> Option<&SourceRequestData> {
                    return match self.data {
                               RequestData::SourceJson(ref s) => Some(s),
                               _ => None,
                           };
                }
                pub fn tile_data(&self) -> Option<&TileRequestData> {
                    return match self.data {
                               RequestData::Tile(ref s) => Some(s),
                               _ => None,
                           };
                }
            }
            use prelude::*;
            pub struct Resource {
                pub req: Request,
                pub data: Vec<u8>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for Resource {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        Resource { req: ref __self_0_0, data: ref __self_0_1 }
                        => {
                            let mut debug_trait_builder =
                                f.debug_struct("Resource");
                            let _ =
                                debug_trait_builder.field("req",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("data",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for Resource {
                #[inline]
                fn clone(&self) -> Resource {
                    match *self {
                        Resource { req: ref __self_0_0, data: ref __self_0_1 }
                        =>
                        Resource{req:
                                     ::std::clone::Clone::clone(&(*__self_0_0)),
                                 data:
                                     ::std::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
        }
        pub mod local {
            use prelude::*;
            use super::*;
            use std::io::Read;
            pub struct LocalFileSource {
            }
            impl Actor for LocalFileSource {
                type
                Context
                =
                Context<Self>;
            }
            impl Handler<super::ResourceRequest> for LocalFileSource {
                type
                Result
                =
                ();
                fn handle(&mut self, msg: ResourceRequest,
                          _ctx: &mut Context<Self>) {
                    let req = &msg.0;
                    let url = { req.url().to_string() };
                    let pos = url.find("://");
                    let path = url.split_at(pos.unwrap() + 3).1;
                    ::io::_print(::std::fmt::Arguments::new_v1_formatted(&["Local  Retrieving  ",
                                                                           "\n"],
                                                                         &match (&path,)
                                                                              {
                                                                              (arg0,)
                                                                              =>
                                                                              [::std::fmt::ArgumentV1::new(arg0,
                                                                                                           ::std::fmt::Debug::fmt)],
                                                                          },
                                                                         &[::std::fmt::rt::v1::Argument{position:
                                                                                                            ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                        format:
                                                                                                            ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                               ' ',
                                                                                                                                           align:
                                                                                                                                               ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                           flags:
                                                                                                                                               0u32,
                                                                                                                                           precision:
                                                                                                                                               ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                           width:
                                                                                                                                               ::std::fmt::rt::v1::Count::Implied,},}]));
                    let mut f = ::std::fs::File::open(path).unwrap();
                    let mut data = <[_]>::into_vec(box []);
                    f.read_to_end(&mut data).unwrap();
                    let resp = Resource{req: req.clone(), data,};
                    msg.1.do_send(super::ResourceCallback(Ok(resp))).unwrap();
                }
            }
            impl LocalFileSource {
                pub fn new() -> LocalFileSource { LocalFileSource{} }
                pub fn spawn() -> Addr<Syn, Self> {
                    start_in_thread(|| Self::new())
                }
            }
        }
        pub mod network {
            use prelude::*;
            use actix_web::client;
            use common::actix_web::HttpMessage;
            use super::*;
            pub struct NetworkFileSource {
            }
            impl Actor for NetworkFileSource {
                type
                Context
                =
                Context<Self>;
            }
            impl Handler<super::ResourceRequest> for NetworkFileSource {
                type
                Result
                =
                ();
                fn handle(&mut self, msg: ResourceRequest,
                          _ctx: &mut Context<Self>) {
                    let fut =
                        client::get(msg.0.url().clone()).timeout(::std::time::Duration::from_secs(15)).finish().unwrap().send().timeout(::std::time::Duration::from_secs(15)).map_err(|x|
                                                                                                                                                                                          {
                                                                                                                                                                                              ::io::_print(::std::fmt::Arguments::new_v1_formatted(&["Retrieval failed: ",
                                                                                                                                                                                                                                                     "\n"],
                                                                                                                                                                                                                                                   &match (&x,)
                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                        (arg0,)
                                                                                                                                                                                                                                                        =>
                                                                                                                                                                                                                                                        [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                                                                                                     ::std::fmt::Display::fmt)],
                                                                                                                                                                                                                                                    },
                                                                                                                                                                                                                                                   &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                                                                                                                                      ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                                                                                                                                  format:
                                                                                                                                                                                                                                                                                      ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                                                                                                                                         ' ',
                                                                                                                                                                                                                                                                                                                     align:
                                                                                                                                                                                                                                                                                                                         ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                                                                                                                                     flags:
                                                                                                                                                                                                                                                                                                                         0u32,
                                                                                                                                                                                                                                                                                                                     precision:
                                                                                                                                                                                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                                                                                                                                     width:
                                                                                                                                                                                                                                                                                                                         ::std::fmt::rt::v1::Count::Implied,},}]));
                                                                                                                                                                                              x.into()
                                                                                                                                                                                          }).and_then(move
                                                                                                                                                                                                          |res|
                                                                                                                                                                                                          res.body().map_err(|e|
                                                                                                                                                                                                                                 e.into())).then(move
                                                                                                                                                                                                                                                     |body|
                                                                                                                                                                                                                                                     {
                                                                                                                                                                                                                                                         match body
                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                             Ok(data)
                                                                                                                                                                                                                                                             =>
                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                 let resource =
                                                                                                                                                                                                                                                                     super::Resource{req:
                                                                                                                                                                                                                                                                                         msg.0.clone(),
                                                                                                                                                                                                                                                                                     data:
                                                                                                                                                                                                                                                                                         data.to_vec(),};
                                                                                                                                                                                                                                                                 msg.1.do_send(super::ResourceCallback(Ok(resource))).unwrap();
                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                             Err(e)
                                                                                                                                                                                                                                                             =>
                                                                                                                                                                                                                                                             {
                                                                                                                                                                                                                                                                 msg.1.do_send(super::ResourceCallback(Err(e))).unwrap()
                                                                                                                                                                                                                                                             }
                                                                                                                                                                                                                                                         }
                                                                                                                                                                                                                                                         Ok(())
                                                                                                                                                                                                                                                     });
                    Arbiter::handle().spawn(fut);
                }
            }
            impl NetworkFileSource {
                pub fn new() -> Self { return NetworkFileSource{}; }
                pub fn spawn() -> Addr<Syn, Self> {
                    start_in_thread(|| NetworkFileSource::new())
                }
            }
        }
        mod url {
            use ::prelude::*;
            const ACCESS_TOKEN: &str =
                "pk.eyJ1Ijoic2VtdGV4enYiLCJhIjoiY2luc3hvamlvMDBsdnZza2wybndkZmY1bCJ9.6p1bjo8wrzd5jmp9KdinwQ";
            const BASE: &str = "https://api.mapbox.com/";
            pub fn is_mapbox_url(url: &str) -> bool {
                return url.starts_with("mapbox://")
            }
        }
        pub use self::resource::*;
        pub struct ResourceCallback(pub Result<Resource>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ResourceCallback {
            fn fmt(&self, f: &mut ::std::fmt::Formatter)
             -> ::std::fmt::Result {
                match *self {
                    ResourceCallback(ref __self_0_0) => {
                        let mut debug_trait_builder =
                            f.debug_tuple("ResourceCallback");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        impl Message for ResourceCallback {
            type
            Result
            =
            ();
        }
        pub struct ResourceRequest(pub Request,
                                   pub Recipient<Syn, ResourceCallback>);
        impl Message for ResourceRequest {
            type
            Result
            =
            ();
        }
        pub struct DefaultFileSource {
            local: SyncAddr<local::LocalFileSource>,
            network: SyncAddr<network::NetworkFileSource>,
        }
        impl Actor for DefaultFileSource {
            type
            Context
            =
            Context<DefaultFileSource>;
        }
        impl Handler<ResourceRequest> for DefaultFileSource {
            type
            Result
            =
            ();
            fn handle(&mut self, msg: ResourceRequest,
                      _ctx: &mut Context<Self>) {
                let url = { msg.0.url().to_string() };
                if url.starts_with("file://") || url.starts_with("local://") {
                    self.local.do_send(msg);
                } else if url.starts_with("http://") ||
                              url.starts_with("https://") {
                    self.network.do_send(msg);
                } else {
                    {
                        ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["No data source available for "],
                                                                                       &match (&url,)
                                                                                            {
                                                                                            (arg0,)
                                                                                            =>
                                                                                            [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                         ::std::fmt::Debug::fmt)],
                                                                                        },
                                                                                       &[::std::fmt::rt::v1::Argument{position:
                                                                                                                          ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                      format:
                                                                                                                          ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                             ' ',
                                                                                                                                                         align:
                                                                                                                                                             ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                         flags:
                                                                                                                                                             0u32,
                                                                                                                                                         precision:
                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                         width:
                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,},}]),
                                              &("rmaps/src/map/storage/mod.rs",
                                                44u32, 13u32))
                    };
                }
            }
        }
        impl DefaultFileSource {
            pub fn new() -> Self {
                DefaultFileSource{local: local::LocalFileSource::spawn(),
                                  network:
                                      network::NetworkFileSource::spawn(),}
            }
            pub fn spawn() -> Addr<Syn, Self> {
                start_in_thread::<DefaultFileSource,
                                  _>(|| DefaultFileSource::new())
            }
        }
    }
    pub mod tiles {
        use prelude::*;
        pub mod data {
            use prelude::*;
            use ::map::style;
            pub struct RasterTileData {
                pub image: Vec<u8>,
                pub dims: (u32, u32),
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for RasterTileData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        RasterTileData {
                        image: ref __self_0_0, dims: ref __self_0_1 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("RasterTileData");
                            let _ =
                                debug_trait_builder.field("image",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("dims",
                                                          &&(*__self_0_1));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for RasterTileData {
                #[inline]
                fn clone(&self) -> RasterTileData {
                    match *self {
                        RasterTileData {
                        image: ref __self_0_0, dims: ref __self_0_1 } =>
                        RasterTileData{image:
                                           ::std::clone::Clone::clone(&(*__self_0_0)),
                                       dims:
                                           ::std::clone::Clone::clone(&(*__self_0_1)),},
                    }
                }
            }
            pub struct VectorTileData {
                pub layers: Vec<::mvt::Layer>,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for VectorTileData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        VectorTileData { layers: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("VectorTileData");
                            let _ =
                                debug_trait_builder.field("layers",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for VectorTileData {
                #[inline]
                fn clone(&self) -> VectorTileData {
                    match *self {
                        VectorTileData { layers: ref __self_0_0 } =>
                        VectorTileData{layers:
                                           ::std::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            pub enum DecodedTileData {
                Vector(VectorTileData),
                Raster(RasterTileData),
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for DecodedTileData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match (&*self,) {
                        (&DecodedTileData::Vector(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Vector");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                        (&DecodedTileData::Raster(ref __self_0),) => {
                            let mut debug_trait_builder =
                                f.debug_tuple("Raster");
                            let _ = debug_trait_builder.field(&&(*__self_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for DecodedTileData {
                #[inline]
                fn clone(&self) -> DecodedTileData {
                    match (&*self,) {
                        (&DecodedTileData::Vector(ref __self_0),) =>
                        DecodedTileData::Vector(::std::clone::Clone::clone(&(*__self_0))),
                        (&DecodedTileData::Raster(ref __self_0),) =>
                        DecodedTileData::Raster(::std::clone::Clone::clone(&(*__self_0))),
                    }
                }
            }
            pub struct TileData {
                pub coord: TileCoords,
                pub source: String,
                pub data: DecodedTileData,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for TileData {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        TileData {
                        coord: ref __self_0_0,
                        source: ref __self_0_1,
                        data: ref __self_0_2 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("TileData");
                            let _ =
                                debug_trait_builder.field("coord",
                                                          &&(*__self_0_0));
                            let _ =
                                debug_trait_builder.field("source",
                                                          &&(*__self_0_1));
                            let _ =
                                debug_trait_builder.field("data",
                                                          &&(*__self_0_2));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for TileData {
                #[inline]
                fn clone(&self) -> TileData {
                    match *self {
                        TileData {
                        coord: ref __self_0_0,
                        source: ref __self_0_1,
                        data: ref __self_0_2 } =>
                        TileData{coord:
                                     ::std::clone::Clone::clone(&(*__self_0_0)),
                                 source:
                                     ::std::clone::Clone::clone(&(*__self_0_1)),
                                 data:
                                     ::std::clone::Clone::clone(&(*__self_0_2)),},
                    }
                }
            }
            pub struct TileDataWorker();
            impl Actor for TileDataWorker {
                type
                Context
                =
                Context<Self>;
            }
            pub struct DecodeTile {
                pub res: ::map::storage::Resource,
                pub source_name: String,
                pub source: ::map::style::StyleSource,
                pub cb: Recipient<Syn, TileReady>,
            }
            pub struct TileReady {
                pub data: TileData,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::fmt::Debug for TileReady {
                fn fmt(&self, f: &mut ::std::fmt::Formatter)
                 -> ::std::fmt::Result {
                    match *self {
                        TileReady { data: ref __self_0_0 } => {
                            let mut debug_trait_builder =
                                f.debug_struct("TileReady");
                            let _ =
                                debug_trait_builder.field("data",
                                                          &&(*__self_0_0));
                            debug_trait_builder.finish()
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::std::clone::Clone for TileReady {
                #[inline]
                fn clone(&self) -> TileReady {
                    match *self {
                        TileReady { data: ref __self_0_0 } =>
                        TileReady{data:
                                      ::std::clone::Clone::clone(&(*__self_0_0)),},
                    }
                }
            }
            impl Message for DecodeTile {
                type
                Result
                =
                ();
            }
            impl Message for TileReady {
                type
                Result
                =
                ();
            }
            impl Handler<DecodeTile> for TileDataWorker {
                type
                Result
                =
                ();
                fn handle(&mut self, msg: DecodeTile,
                          ctx: &mut Context<Self>) {
                    let data =
                        match msg.source {
                            ::map::style::StyleSource::Raster(_) => {
                                let data = &msg.res.data;
                                let format =
                                    ::image::guess_format(data).unwrap();
                                let decoded =
                                    ::image::load_from_memory_with_format(data,
                                                                          format).unwrap().to_rgba();
                                let dims = decoded.dimensions();
                                let data =
                                    RasterTileData{image: decoded.into_raw(),
                                                   dims,};
                                TileData{coord:
                                             msg.res.req.tile_data().unwrap().coords,
                                         data: DecodedTileData::Raster(data),
                                         source: msg.source_name,}
                            }
                            ::map::style::StyleSource::Vector(_) => {
                                use mvt::prost::Message;
                                let data = &msg.res.data;
                                let vt =
                                    ::mvt::vector_tile::Tile::decode(data).unwrap();
                                let tile = ::mvt::Tile::from(vt);
                                TileData{coord:
                                             msg.res.req.tile_data().unwrap().coords,
                                         data:
                                             DecodedTileData::Vector(VectorTileData{layers:
                                                                                        tile.layers,}),
                                         source: msg.source_name,}
                            }
                            _ => {
                                {
                                    ::rt::begin_panic("Unhandled source decoding error",
                                                      &("rmaps/src/map/tiles/data.rs",
                                                        97u32, 17u32))
                                }
                            }
                        };
                    msg.cb.do_send(TileReady{data: data,}).unwrap();
                }
            }
            impl TileDataWorker {
                pub fn new() -> Self { return TileDataWorker(); }
                pub fn spawn() -> Addr<Syn, TileDataWorker> {
                    start_in_thread(|| { Self::new() })
                }
            }
        }
        use std::collections::BTreeSet;
        pub trait TileObserver {
            fn tile_changed();
        }
        pub struct TileStorage {
            pub in_flight: BTreeSet<TileCoords>,
            pub available: BTreeSet<TileCoords>,
        }
        impl TileStorage {
            pub fn new() -> Self {
                TileStorage{in_flight: BTreeSet::new(),
                            available: BTreeSet::new(),}
            }
            pub fn needed_tiles(&self) -> Vec<TileCoords> {
                if self.available.is_empty() && self.in_flight.is_empty() {
                    return <[_]>::into_vec(box [TileCoords::new(0, 0, 0)]);
                }
                return self.available.iter().filter(|x|
                                                        x.z <
                                                            4).flat_map(|x|
                                                                            Vec::from(&x.children()[..])).filter(|t|
                                                                                                                     !self.in_flight.contains(&t)).filter(|t|
                                                                                                                                                              !self.available.contains(&t)).take(4).collect();
            }
            pub fn requested_tile(&mut self, coords: &TileCoords) {
                self.in_flight.insert(coords.clone());
            }
            pub fn finished_tile(&mut self, coords: &TileCoords) {
                self.in_flight.remove(coords);
                self.available.insert(coords.clone());
            }
        }
    }
    pub struct MapView {
        addr: Addr<Unsync, MapViewImpl>,
        sys: SystemRunner,
    }
    impl MapView {
        pub fn new(f: &Display) -> Self {
            let sys = System::new("Map");
            let _impl = MapViewImpl::new(f);
            let addr = _impl.start();
            return MapView{sys, addr,};
        }
        pub fn do_run<R>(&mut self,
                         f: impl FnOnce(Addr<Unsync, MapViewImpl>) -> R)
         -> R {
            let addr = self.addr.clone();
            let res =
                self.sys.run_until_complete(::common::futures::future::lazy(||
                                                                                {
                                                                                    Ok::<R,
                                                                                         !>(f(addr))
                                                                                }));
            self.sys.pulse();
            res.unwrap()
        }
        pub fn render(&mut self, surface: glium::Frame) {
            self.do_run(|add|
                            { add.do_send(MapMethodArgs::Render(surface)); });
        }
        pub fn set_style_url(&mut self, url: &str) {
            self.do_run(|add|
                            {
                                add.do_send(MapMethodArgs::SetStyleUrl(url.into()));
                            });
        }
        pub fn get_camera(&mut self) -> Camera {
            self.do_run(|add|
                            {
                                add.send(Invoke::new(|i: &mut MapViewImpl|
                                                         {
                                                             i.camera.clone()
                                                         }))
                            }).wait().unwrap().unwrap()
        }
        pub fn set_camera(&mut self, camera: Camera) {
            self.do_run(|add|
                            {
                                add.send(Invoke::new(|i: &mut MapViewImpl|
                                                         {
                                                             i.camera =
                                                                 camera;
                                                         }))
                            }).wait().unwrap().unwrap()
        }
        pub fn clicked(&mut self, point: PixelPoint) {
            self.do_run(|add|
                            {
                                add.send(Invoke::new(move
                                                         |i: &mut MapViewImpl|
                                                         {
                                                             i.clicked(point);
                                                         }))
                            }).wait().unwrap().unwrap()
        }
    }
    pub struct MapViewImpl {
        addr: Option<Addr<Unsync, MapViewImpl>>,
        sync_addr: Option<Addr<Syn, MapViewImpl>>,
        camera: Camera,
        renderer: render::Renderer,
        source: Addr<Syn, storage::DefaultFileSource>,
        tile_worker: Addr<Syn, tiles::data::TileDataWorker>,
        facade: Box<glium::Display>,
        style: Option<style::Style>,
        tile_storage: tiles::TileStorage,
    }
    impl Actor for MapViewImpl {
        type
        Context
        =
        Context<Self>;
        fn started(&mut self, ctx: &mut <Self as Actor>::Context) {
            self.addr = Some(ctx.address());
            self.sync_addr = Some(ctx.address());
        }
    }
    use self::tiles::data;
    impl Handler<storage::ResourceCallback> for MapViewImpl {
        type
        Result
        =
        ();
        fn handle(&mut self, msg: storage::ResourceCallback,
                  _ctx: &mut Context<Self>) {
            match msg.0 {
                Ok(res) => {
                    match res.req.data {
                        storage::RequestData::StyleJson { .. } => {
                            let parsed = json::from_slice(&res.data).unwrap();
                            self.set_style(parsed);
                        }
                        storage::RequestData::Tile(storage::TileRequestData {
                                                   coords, ref source, .. })
                        => {
                            self.tile_storage.finished_tile(&coords);
                            let source_data =
                                self.style.as_ref().unwrap().sources.get(source).unwrap().clone();
                            let rq =
                                tiles::data::DecodeTile{source: source_data,
                                                        source_name:
                                                            source.clone(),
                                                        res: res.clone(),
                                                        cb:
                                                            self.sync_addr.as_ref().unwrap().clone().recipient(),};
                            self.tile_worker.do_send(rq);
                        }
                        _ => {
                            {
                                ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["Resource "],
                                                                                               &match (&res,)
                                                                                                    {
                                                                                                    (arg0,)
                                                                                                    =>
                                                                                                    [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                 ::std::fmt::Debug::fmt)],
                                                                                                },
                                                                                               &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                  ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                              format:
                                                                                                                                  ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                     ' ',
                                                                                                                                                                 align:
                                                                                                                                                                     ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                 flags:
                                                                                                                                                                     0u32,
                                                                                                                                                                 precision:
                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                 width:
                                                                                                                                                                     ::std::fmt::rt::v1::Count::Implied,},}]),
                                                      &("rmaps/src/map/mod.rs",
                                                        123u32, 25u32))
                            };
                        }
                    }
                }
                Err(_e) => { }
            }
        }
    }
    impl Handler<tiles::data::TileReady> for MapViewImpl {
        type
        Result
        =
        ();
        fn handle(&mut self, msg: tiles::data::TileReady,
                  ctx: &mut Context<Self>) {
            let data = Rc::new(msg.data);
            self.renderer.tile_ready(data);
        }
    }
    impl MapViewImpl {
        pub fn new(f: &Display) -> Self {
            let src_add = storage::DefaultFileSource::spawn();
            let tile_worker_add = tiles::data::TileDataWorker::spawn();
            let mut camera: Camera = Default::default();
            camera.pos = Mercator::latlng_to_world(LatLng::new(49, 16));
            let m =
                MapViewImpl{addr: None,
                            sync_addr: None,
                            camera,
                            renderer: render::Renderer::new(&f),
                            source: src_add,
                            tile_worker: tile_worker_add,
                            facade: Box::new((*f).clone()),
                            style: None,
                            tile_storage: tiles::TileStorage::new(),};
            return m;
        }
        pub fn set_style(&mut self, style: style::Style) {
            self.renderer.style_changed(&style).unwrap();
            self.style = Some(style);
        }
        pub fn set_style_url(&mut self, url: &str) {
            ::io::_print(::std::fmt::Arguments::new_v1_formatted(&["Setting style url : ",
                                                                   "\n"],
                                                                 &match (&url,)
                                                                      {
                                                                      (arg0,)
                                                                      =>
                                                                      [::std::fmt::ArgumentV1::new(arg0,
                                                                                                   ::std::fmt::Debug::fmt)],
                                                                  },
                                                                 &[::std::fmt::rt::v1::Argument{position:
                                                                                                    ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                format:
                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                       ' ',
                                                                                                                                   align:
                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                   flags:
                                                                                                                                       0u32,
                                                                                                                                   precision:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                   width:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},}]));
            let req = storage::Request::style(url.into());
            let addr: Addr<Syn, MapViewImpl> =
                self.sync_addr.clone().unwrap().into();
            self.source.do_send(storage::ResourceRequest(req,
                                                         addr.recipient()));
        }
        pub fn clicked(&mut self, pixel: PixelPoint) {
            ::io::_print(::std::fmt::Arguments::new_v1_formatted(&["PIXEL : ",
                                                                   "\n"],
                                                                 &match (&pixel,)
                                                                      {
                                                                      (arg0,)
                                                                      =>
                                                                      [::std::fmt::ArgumentV1::new(arg0,
                                                                                                   ::std::fmt::Debug::fmt)],
                                                                  },
                                                                 &[::std::fmt::rt::v1::Argument{position:
                                                                                                    ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                format:
                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                       ' ',
                                                                                                                                   align:
                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                   flags:
                                                                                                                                       0u32,
                                                                                                                                   precision:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                   width:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},}]));
            let dev = self.camera.window_to_device(pixel);
            ::io::_print(::std::fmt::Arguments::new_v1_formatted(&["DEVICE : ",
                                                                   "\n"],
                                                                 &match (&dev,)
                                                                      {
                                                                      (arg0,)
                                                                      =>
                                                                      [::std::fmt::ArgumentV1::new(arg0,
                                                                                                   ::std::fmt::Debug::fmt)],
                                                                  },
                                                                 &[::std::fmt::rt::v1::Argument{position:
                                                                                                    ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                format:
                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                       ' ',
                                                                                                                                   align:
                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                   flags:
                                                                                                                                       0u32,
                                                                                                                                   precision:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                   width:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},}]));
            let world = self.camera.device_to_world(dev);
            ::io::_print(::std::fmt::Arguments::new_v1_formatted(&["WORLD : ",
                                                                   "\n"],
                                                                 &match (&world,)
                                                                      {
                                                                      (arg0,)
                                                                      =>
                                                                      [::std::fmt::ArgumentV1::new(arg0,
                                                                                                   ::std::fmt::Debug::fmt)],
                                                                  },
                                                                 &[::std::fmt::rt::v1::Argument{position:
                                                                                                    ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                format:
                                                                                                    ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                       ' ',
                                                                                                                                   align:
                                                                                                                                       ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                   flags:
                                                                                                                                       0u32,
                                                                                                                                   precision:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                   width:
                                                                                                                                       ::std::fmt::rt::v1::Count::Implied,},}]));
        }
        pub fn render(&mut self, target: &mut glium::Frame) {
            let projection = self.camera.projection();
            let view = self.camera.view();
            let params =
                self::render::RenderParams{disp: self.facade.deref(),
                                           frame: target,
                                           projection,
                                           view,
                                           camera: &self.camera,
                                           frame_start: PreciseTime::now(),};
            self.renderer.render(params).unwrap();
            if let Some(ref style) = self.style {
                for (src_id, src) in style.sources.iter() {
                    let needed = self.tile_storage.needed_tiles();
                    for coord in needed {
                        self.tile_storage.requested_tile(&coord);
                        let req =
                            storage::Request::tile(src_id.clone(),
                                                   src.url_template(), coord);
                        let addr: Addr<Syn, MapViewImpl> =
                            self.sync_addr.clone().unwrap().into();
                        self.source.do_send(storage::ResourceRequest(req,
                                                                     addr.recipient()));
                    }
                }
            }
        }
    }
    pub enum MapMethodArgs { Render(glium::Frame), SetStyleUrl(String), }
    impl Message for MapMethodArgs {
        type
        Result
        =
        ();
    }
    impl Handler<MapMethodArgs> for MapViewImpl {
        type
        Result
        =
        ();
        fn handle(&mut self, msg: MapMethodArgs, _ctx: &mut Self::Context)
         -> () {
            match msg {
                MapMethodArgs::Render(mut frame) => {
                    self.render(&mut frame);
                    frame.finish().unwrap();
                }
                MapMethodArgs::SetStyleUrl(url) => {
                    self.set_style_url(&url)
                }
            };
        }
    }
    pub struct Invoke<A, F, R> where A: Actor, F: FnOnce(&mut A) -> R,
               R: 'static {
        f: F,
        _a: ::std::marker::PhantomData<A>,
        _r: ::std::marker::PhantomData<R>,
    }
    impl <A, F, R> Invoke<A, F, R> where A: Actor, F: FnOnce(&mut A) -> R,
     R: 'static {
        fn new(f: F) -> Self {
            Invoke{f: f,
                   _a: ::std::marker::PhantomData,
                   _r: ::std::marker::PhantomData,}
        }
    }
    impl <A, F, R> Message for Invoke<A, F, R> where A: Actor,
     F: FnOnce(&mut A) -> R, R: 'static {
        type
        Result
        =
        Result<R>;
    }
    impl <F, R> Handler<Invoke<MapViewImpl, F, R>> for MapViewImpl where
     F: FnOnce(&mut MapViewImpl) -> R, R: 'static {
        type
        Result
        =
        Result<R>;
        fn handle(&mut self, msg: Invoke<MapViewImpl, F, R>,
                  _ctx: &mut Context<Self>) -> Result<R> {
            Ok((msg.f)(self))
        }
    }
}
use prelude::*;
pub fn init() {
    use common::prelude::*;
    ::std::thread::spawn(move ||
                             {
                                 let sys = actix::System::new("test");
                                 sys.run();
                             });
}
