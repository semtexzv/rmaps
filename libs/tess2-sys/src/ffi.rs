/* automatically generated by rust-bindgen */

pub const TessWindingRule_TESS_WINDING_ODD: TessWindingRule = 0;
pub const TessWindingRule_TESS_WINDING_NONZERO: TessWindingRule = 1;
pub const TessWindingRule_TESS_WINDING_POSITIVE: TessWindingRule = 2;
pub const TessWindingRule_TESS_WINDING_NEGATIVE: TessWindingRule = 3;
pub const TessWindingRule_TESS_WINDING_ABS_GEQ_TWO: TessWindingRule = 4;
pub type TessWindingRule = u32;
pub const TessElementType_TESS_POLYGONS: TessElementType = 0;
pub const TessElementType_TESS_CONNECTED_POLYGONS: TessElementType = 1;
pub const TessElementType_TESS_BOUNDARY_CONTOURS: TessElementType = 2;
pub type TessElementType = u32;
pub type TESSreal = f32;
pub type TESSindex = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TESStesselator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TESSalloc {
    pub memalloc: ::std::option::Option<
        unsafe extern "C" fn(userData: *mut ::std::os::raw::c_void, size: ::std::os::raw::c_uint)
            -> *mut ::std::os::raw::c_void,
    >,
    pub memrealloc: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            size: ::std::os::raw::c_uint,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub memfree: ::std::option::Option<
        unsafe extern "C" fn(
            userData: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
        ),
    >,
    pub userData: *mut ::std::os::raw::c_void,
    pub meshEdgeBucketSize: ::std::os::raw::c_int,
    pub meshVertexBucketSize: ::std::os::raw::c_int,
    pub meshFaceBucketSize: ::std::os::raw::c_int,
    pub dictNodeBucketSize: ::std::os::raw::c_int,
    pub regionBucketSize: ::std::os::raw::c_int,
    pub extraVertices: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TESSalloc() {
    assert_eq!(
        ::std::mem::size_of::<TESSalloc>(),
        56usize,
        concat!("Size of: ", stringify!(TESSalloc))
    );
    assert_eq!(
        ::std::mem::align_of::<TESSalloc>(),
        8usize,
        concat!("Alignment of ", stringify!(TESSalloc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).memalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(memalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).memrealloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(memrealloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).memfree as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(memfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).userData as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(userData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).meshEdgeBucketSize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(meshEdgeBucketSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).meshVertexBucketSize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(meshVertexBucketSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).meshFaceBucketSize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(meshFaceBucketSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).dictNodeBucketSize as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(dictNodeBucketSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).regionBucketSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(regionBucketSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TESSalloc>())).extraVertices as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(TESSalloc),
            "::",
            stringify!(extraVertices)
        )
    );
}
extern "C" {
    pub fn tessNewTess(alloc: *mut TESSalloc) -> *mut TESStesselator;
}
extern "C" {
    pub fn tessDeleteTess(tess: *mut TESStesselator);
}
extern "C" {
    pub fn tessAddContour(
        tess: *mut TESStesselator,
        size: ::std::os::raw::c_int,
        pointer: *const ::std::os::raw::c_void,
        stride: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn tessTesselate(
        tess: *mut TESStesselator,
        windingRule: ::std::os::raw::c_int,
        elementType: ::std::os::raw::c_int,
        polySize: ::std::os::raw::c_int,
        vertexSize: ::std::os::raw::c_int,
        normal: *const TESSreal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tessGetVertexCount(tess: *mut TESStesselator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tessGetVertices(tess: *mut TESStesselator) -> *const TESSreal;
}
extern "C" {
    pub fn tessGetVertexIndices(tess: *mut TESStesselator) -> *const TESSindex;
}
extern "C" {
    pub fn tessGetElementCount(tess: *mut TESStesselator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tessGetElements(tess: *mut TESStesselator) -> *const TESSindex;
}
