pub fn event_loop() {
}

pub unsafe fn dealloc( ptr: *mut u8, capacity: usize ) {
    exports::__web_free( ptr, capacity );
}

pub mod exports {
    use std::mem;

    extern "C" {
        pub fn __js_0( code: *const u8 ) -> i32;
        // Autogenerated with the following Ruby script:
        // params = []
        // 1.upto( 17 ) do |nth|
        //     params << "a#{nth}: i32"
        //     puts "pub fn __js_#{nth}( #{params.join ', '}, code: *const u8 ) -> i32;"
        // end
        pub fn __js_1( a1: i32, code: *const u8 ) -> i32;
        pub fn __js_2( a1: i32, a2: i32, code: *const u8 ) -> i32;
        pub fn __js_3( a1: i32, a2: i32, a3: i32, code: *const u8 ) -> i32;
        pub fn __js_4( a1: i32, a2: i32, a3: i32, a4: i32, code: *const u8 ) -> i32;
        pub fn __js_5( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, code: *const u8 ) -> i32;
        pub fn __js_6( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, code: *const u8 ) -> i32;
        pub fn __js_7( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, code: *const u8 ) -> i32;
        pub fn __js_8( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, code: *const u8 ) -> i32;
        pub fn __js_9( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, code: *const u8 ) -> i32;
        pub fn __js_10( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, code: *const u8 ) -> i32;
        pub fn __js_11( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, a11: i32, code: *const u8 ) -> i32;
        pub fn __js_12( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, a11: i32, a12: i32, code: *const u8 ) -> i32;
        pub fn __js_13( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, a11: i32, a12: i32, a13: i32, code: *const u8 ) -> i32;
        pub fn __js_14( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, a11: i32, a12: i32, a13: i32, a14: i32, code: *const u8 ) -> i32;
        pub fn __js_15( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, a11: i32, a12: i32, a13: i32, a14: i32, a15: i32, code: *const u8 ) -> i32;
        pub fn __js_16( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, a11: i32, a12: i32, a13: i32, a14: i32, a15: i32, a16: i32, code: *const u8 ) -> i32;
        pub fn __js_17( a1: i32, a2: i32, a3: i32, a4: i32, a5: i32, a6: i32, a7: i32, a8: i32, a9: i32, a10: i32, a11: i32, a12: i32, a13: i32, a14: i32, a15: i32, a16: i32, a17: i32, code: *const u8 ) -> i32;
    }

    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn __web_malloc( size: usize ) -> *mut u8 {
        let mut buffer = Vec::with_capacity( size );
        let ptr = buffer.as_mut_ptr();
        mem::forget( buffer );
        ptr
    }

    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn __web_free( ptr: *mut u8, capacity: usize ) {
        unsafe  {
            let _ = Vec::from_raw_parts( ptr, 0, capacity );
        }
    }
}
